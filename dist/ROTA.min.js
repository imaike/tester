!function(I){function g(A){if(C[A])return C[A].exports;var t=C[A]={i:A,l:!1,exports:{}};return I[A].call(t.exports,t,t.exports,g),t.l=!0,t.exports}var C={};g.m=I,g.c=C,g.i=function(I){return I},g.d=function(I,C,A){g.o(I,C)||Object.defineProperty(I,C,{configurable:!1,enumerable:!0,get:A})},g.n=function(I){var C=I&&I.__esModule?function(){return I.default}:function(){return I};return g.d(C,"a",C),C},g.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},g.p="",g(g.s=12)}({12:function(module,exports){eval('//Ken-Q Analysis\n//Copyright (C) 2016 Shawn Banasick\n//\n//    This program is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, either version 3 of the License, or\n//    (at your option) any later version.\n\n\n// JSlint declarations\n/* global window, d3, performance, sessionStorage, QAV, $, resources, LOAD, document, evenRound, UTIL, _ */\n\n(function (ROTA, QAV, undefined) {\n\n\n    // reset \'has split factor\' marker on page load\n    (function () {\n        var hasSplitFactor = 0;\n        QAV.setState("hasSplitFactor", hasSplitFactor);\n    })();\n\n    // ************************************************************  VIEW CONTROLER\n    // **********  re-initialize chart after save rotation or varimax *************\n    // ****************************************************************************\n\n    ROTA.reInitializePlotAndChart = function () {\n        // data to initialize D3 chart\n\n        var testVar = $.fn.dataTable.isDataTable(\'#twoFactorDisplayTable\');\n\n        if (testVar) {\n            var emptyArray = [{\n                "respondent": "",\n                "factor1": 0,\n                "factor2": 0\n            }];\n            var emptyArray2 = [];\n            ROTA.drawD3Chart(emptyArray);\n            var isNewSelection = false;\n            ROTA.updateDatatable1(emptyArray2, isNewSelection);\n        }\n    };\n\n\n    // **************************************************************** model state\n    // *********  save rotation counter *******************************************\n    // ****************************************************************************\n\n    // always reset to zero on centroid extraction (in centroid.js file)\n    ROTA.saveRotationArchiveCounter = function (option) {\n        var saveRotationCounter = QAV.getState("saveRotationCounter");\n        if (option === "increase") {\n            saveRotationCounter = saveRotationCounter + 1;\n            QAV.setState("saveRotationCounter", saveRotationCounter);\n        } else if (option === "decrease") {\n            saveRotationCounter = saveRotationCounter - 1;\n            QAV.setState("saveRotationCounter", saveRotationCounter);\n        } else if (option === "get") {\n            return saveRotationCounter;\n        } else if (option === "reset") {\n            QAV.setState("saveRotationCounter", 1);\n        }\n    };\n\n    // ****************************************************************  view\n    // ****  Rotation button state    ***************************************\n    // **********************************************************************\n\n    ROTA.saveRotationButtonColor = function (rotationDegreeDisplayValue) {\n        var saveRotButton = $("#saveRotationButton");\n        if (rotationDegreeDisplayValue !== 0) {\n            saveRotButton.removeClass("saveRotationButtonGray");\n            saveRotButton.addClass("saveRotationButtonYellow");\n        } else {\n            saveRotButton.removeClass("saveRotationButtonYellow");\n            saveRotButton.addClass("saveRotationButtonGray");\n        }\n    };\n\n    // *****************************************************************************\n    // *************    D3 Code Save as Image   ************************************\n    // *****************************************************************************\n    //\n    // example - http://plnkr.co/edit/MkZcXJPS7hrcWh3M0MZ1?p=preview\n    // http://www.inkfood.com/svg-to-canvas/\n    // https: //github.com/sampumon/SVG.toDataURL\n    // change data format to JSON\n\n\n    // ************************************************************  view controller\n    // *************    SAVE SELECTED factors for rotation   ***********************\n    // *****************************************************************************\n    ROTA.setRotationFactorsFromCheckbox = function () {\n\n        // get the factors to send to 2 factor chart\n        var pullFactors = [];\n        var checkboxes = document.getElementsByName(\'radioCheck\');\n        for (var i = 0; i < checkboxes.length; i++) {\n            if (checkboxes[i].checked) {\n                pullFactors.push(checkboxes[i].value);\n            }\n        }\n\n        // account for sending null set on page load to display empty chart\n        if (pullFactors !== null) {\n            var rotationFactorA = pullFactors[0];\n            var rotationFactorB = pullFactors[1];\n            QAV.setState("rotationFactorA", rotationFactorA);\n            QAV.setState("rotationFactorB", rotationFactorB);\n\n        }\n        return pullFactors;\n    };\n\n    // *******************************************************************  data model\n    // *************   Data format array to object   *********************************\n    // *******************************************************************************\n\n    // CALLED BY "DISPLAY FACTORS FOR ROTATION BUTTON"\n    ROTA.doD3ChartDataPrep = function (rotFacStateArray) {\n        var rotationFactorA = QAV.getState("rotationFactorA");\n        var rotationFactorB = QAV.getState("rotationFactorB");\n        var step4 = QAV.getState("qavRespondentNames");\n        var fSigCriterionResults = QAV.getState("fSigCriterionResults");\n\n        var chartData = _.cloneDeep(rotFacStateArray);\n        var dataValuesArray = [];\n        var initialTwoFactorTableArray = [];\n        var step1, step3, ilen, factorNameArrayFrag, respondent2, factor1c, factor2c;\n        var tempObj;\n\n        ilen = chartData.length;\n        for (var i = 0; i < ilen; i++) {\n            step1 = chartData[i];\n            step3 = fSigCriterionResults[i];\n\n            // CONVERT ARRAY TO OBJECT for D3js chart\n            tempObj = {\n                num: i + 1,\n                respondent: step4[i],\n                factor1: step1[rotationFactorA - 1],\n                factor1Sig: step3[rotationFactorA - 1],\n                factor2: step1[rotationFactorB - 1],\n                factor2Sig: step3[rotationFactorB - 1],\n            };\n            dataValuesArray.push(tempObj);\n        }\n\n        factorNameArrayFrag = [];\n        respondent2 = "";\n        factor1c = "Factor " + rotationFactorA;\n        factor2c = "Factor " + rotationFactorB;\n\n        factorNameArrayFrag.push(respondent2, factor1c, factor2c);\n        initialTwoFactorTableArray.unshift(factorNameArrayFrag);\n\n        return dataValuesArray;\n    };\n\n\n    // ***************************************************************** view model\n    // *******  draw D3 Chart  ***************************************************\n    // ***************************************************************************\n\n    ROTA.drawD3Chart = function (dataValuesArray) {\n        var rotationFactorA = QAV.getState("rotationFactorA");\n        var rotationFactorB = QAV.getState("rotationFactorB");\n        var rotChartConfig = QAV.getState("rotChartConfig");\n        var significanceColorA, significanceColorB, dotStrokeColor, identifier;\n        var data, defaultDotColor, customFontSize;\n\n        d3.select("#d3_scatterchart svg").remove();\n\n        // remove highlighting from circles\n        if (rotChartConfig.removeCircleHighlight === true) {\n            significanceColorA = "rgba(33, 33, 33, 0.0)";\n            significanceColorB = "rgba(33, 33, 33, 0.0)";\n            defaultDotColor = "rgba(33, 33, 33, 0.0)";\n        } else {\n            significanceColorA = rotChartConfig.significanceColorAPrep;\n            significanceColorB = rotChartConfig.significanceColorBPrep;\n            defaultDotColor = "#d8d8d8";\n        }\n\n        if (rotChartConfig.removeCircles === true) {\n            dotStrokeColor = "rgba(33, 33, 33, 0.0)";\n        } else {\n            dotStrokeColor = "#000000";\n        }\n\n        if (rotChartConfig.identifierNumber === true) {\n            identifier = "number";\n        } else {\n            identifier = "name";\n        }\n\n        if (rotChartConfig.changeFontSize === true) {\n            customFontSize = rotChartConfig.customFontSize + "px";\n        } else {\n            customFontSize = "9px";\n        }\n\n        //console.log(customFontSize);\n\n        // var significanceLevel = ROTA.calculateFactorLoadingSignificanceLevel();\n\n        data = dataValuesArray;\n\n        var chartSize = $(window).width() / 2.25;\n\n        var margin = {\n                top: 20,\n                right: 10,\n                bottom: 40,\n                left: 40\n            },\n\n            width = chartSize - margin.left - margin.right,\n            height = chartSize - margin.top - margin.bottom;\n        // todo - coordinate with canvas size on html so download works\n\n        /*\n         * value accessor - returns the value to encode for a given data object.\n         * scale - maps value to a visual display encoding, such as a pixel position.\n         * map function - maps from data value to display value\n         * axis - sets up axis\n         */\n\n        // setup x\n        var xValue = function (d) {\n                return d.factor2;\n            }, // data -> value\n            xScale = d3.scale.linear().range([0, width]), // value -> display\n            xMap = function (d) {\n                return xScale(xValue(d));\n            }, // data -> display\n            xAxis = d3.svg.axis().scale(xScale).orient("bottom").ticks(2).tickSize(-height, 0, 0).tickPadding(10);\n\n        // setup y\n        var yValue = function (d) {\n                return d.factor1;\n            }, // data -> value\n            yScale = d3.scale.linear().range([height, 0]), // value -> display\n            yMap = function (d) {\n                return yScale(yValue(d));\n            }, // data -> display\n            yAxis = d3.svg.axis().scale(yScale).orient("left").ticks(2).tickSize(-width, 0, 0).tickPadding(10);\n\n        // add the graph canvas to the webpage\n        var svg = d3.select("#d3_scatterchart").append("svg")\n            .attr("width", width + margin.left + margin.right)\n            .attr("height", height + margin.top + margin.bottom)\n            .attr("font-family", "Arial")\n            .attr("id", "scatterChart")\n            .append("g")\n            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        // confirm number format\n        data.forEach(function (d) {\n            d.factor1 = +d.factor1;\n            d.factor2 = +d.factor2;\n            d.factor1Sig = d.factor1Sig + \'\';\n            d.factor2Sig = d.factor2Sig + \'\';\n        });\n\n        // check for case with factor loading greater than 1 and adjust axis\n        var axisMax;\n        var maxXAxis = d3.max(data, xValue);\n        var minXAxis = d3.min(data, xValue);\n        var maxYAxis = d3.max(data, yValue);\n        var minYAxis = d3.min(data, yValue);\n\n        var axisTestArray = [maxXAxis, minXAxis, maxYAxis, minYAxis];\n        var maxArrayValue = _.max(axisTestArray);\n        var minArrayValue = _.min(axisTestArray);\n\n        if (maxArrayValue > 1 || minArrayValue < -1) {\n            if (maxArrayValue > -minArrayValue) {\n                axisMax = maxArrayValue;\n            } else {\n                axisMax = -minArrayValue;\n            }\n        } else {\n            axisMax = 1;\n        }\n\n        xScale.domain([-axisMax, +axisMax]);\n        yScale.domain([-axisMax, +axisMax]);\n\n        // define the div for the tooltip   #d3_scatterchart\n        var div = d3.select("#d3_scatterchart").append("div")\n            .attr("class", "d3Tooltip")\n            .style("opacity", 0);\n\n        // x-axis\n        svg.append("g")\n            .attr("class", "x axis")\n            .attr("transform", "translate(0," + height + ")")\n            .call(xAxis)\n            .append("text")\n            .attr("class", "label")\n            .attr("x", width)\n            .attr("y", -6)\n            .style("font-family", "Arial")\n            .style("text-anchor", "end");\n\n        // create x axis title\n        svg.append("text")\n            .attr("x", width / 2)\n            .attr("y", height + 35)\n            .style("text-anchor", "middle")\n            .style("font-family", "Arial")\n            .style("font-weight", "bold")\n            .text("Factor " + rotationFactorB);\n\n        // y-axis\n        svg.append("g")\n            .attr("class", "y axis")\n            .call(yAxis)\n            .append("text")\n            .attr("class", "label")\n            .attr("transform", "rotate(-90)")\n            .attr("y", 6)\n            .attr("dy", ".71em")\n            .style("font-family", "Arial")\n            .style("text-anchor", "end");\n        // .selectAll(\'path\')\n        // .style(\'stroke\', \'red\')\n        // .style(\'fill\', \'none\')\n        // .style(\'stroke-width\', \'5px\');\n        // .text("Factor " + rotationFactorA);\n\n        svg.selectAll(\'.axis lne, .axis path, .minor\')\n            .style({\n                \'stroke\': \'black\',\n                \'fill\': \'none\',\n                \'stroke-width\': \'1px\',\n                \'shape-rendering\': \'crispEdges\'\n            });\n\n        d3.selectAll(\'g.tick\')\n            .style({\n                \'stroke\': \'black\',\n                \'fill\': \'black\',\n                \'stroke-width\': \'1px\',\n                \'shape-rendering\': \'crispEdges\'\n            });\n\n\n        // create Y axis label\n        svg.append("text")\n            .attr("transform", "rotate(-90)")\n            .attr("y", 0 - margin.left)\n            .attr("x", 0 - (height / 2))\n            .attr("dy", "1em")\n            .style("text-anchor", "middle")\n            .style("font-family", "Arial")\n            .style("font-weight", "bold")\n            .text("Factor " + rotationFactorA);\n\n\n        /*  drawing dots and circles based on http://jsfiddle.net/eamonnmag/Q567s/   */\n\n        /*    telling D3 that all nodes (g elements with class node) will have data attached to them. The \'key\' used (to let D3 know the uniqueness of items) will be the "num" */\n        var index = svg.selectAll("g.node").data(data, function (d) {\n            return d.num;\n        });\n\n        /* \'enter\' the data, making the SVG group (to contain a circle and text) with a class node. This corresponds with what we told the data it should be above. */\n        var indexGroup = index.enter().append("g").attr("class", "node")\n            .attr(\'transform\', function (d) {\n                return "translate(" + xMap(d) + "," + yMap(d) + ")";\n            });\n\n        // add the circles\n        indexGroup.append("circle")\n            .attr("r", 9)\n            .attr("class", "dot")\n            .style("stroke", dotStrokeColor)\n            .style("fill", function (d) {\n                if (d.factor1Sig === "true") {\n                    return (significanceColorA); //"#ffe4b2";\n                } else if (d.factor2Sig === "true") {\n                    return (significanceColorB);\n                } else {\n                    return (defaultDotColor);\n                }\n            })\n            .on("mouseover", function (d) {\n                div.transition()\n                    .duration(100)\n                    .style("opacity", 1);\n                div.html("<strong>" + d.respondent + "</strong><br>" + yValue(d) + ", 　" + xValue(d))\n                    .style("left", (d3.event.pageX + 10) + "px")\n                    .style("top", (d3.event.pageY - 28) + "px");\n            })\n            .on("mouseout", function () {\n                div.transition()\n                    .duration(500)\n                    .style("opacity", 0);\n            });\n\n        // add the text labels\n        indexGroup.append("text")\n            .style("text-anchor", "middle")\n            .attr("class", "dotText")\n            .attr("font-family", "Arial")\n            .attr("font-size", customFontSize)\n            .attr("dy", 3)\n            .text(function (d) {\n                if (identifier === "number") {\n                    return d.num;\n                } else {\n                    return d.respondent;\n                }\n            })\n            .on("mouseover", function (d) {\n                div.transition()\n                    .duration(100)\n                    .style("opacity", 1);\n                div.html("<strong>" + d.respondent + "</strong><br>" + yValue(d) + ", 　" + xValue(d))\n                    .style("left", (d3.event.pageX + 10) + "px")\n                    .style("top", (d3.event.pageY - 28) + "px");\n            })\n            .on("mouseout", function () {\n                div.transition()\n                    .duration(500)\n                    .style("opacity", 0);\n            });\n        //  todo - check to see if I need to exit the dots\n    };\n\n    // todo - store this info on auto flagging somewhere else\n    //These are the two standard criteria for automatic flagging used in Q method analysis:\n    //1. Q-sorts which factor loading is higher than the threshold for p-value < 0.05, and\n    //2. Q-sorts which square loading is higher than the sum of square loadings of the same Q-sort in\n    //    all other factors.\n\n    // C Flag Item I on Factor J if A^2/H^2 > .5 (Fuerntratt-Criterion) preliminary flagging method\n    // C *and* a > 1.96/sqrt(nitems)\n\n    // ******************************************************** data analysis\n    // ********  calc significance Levels  **********************************\n    //***********************************************************************\n\n    ROTA.calculateFactorLoadingSignificanceLevel = function (totalStatements) {\n        // var totalStatements = QAV.getState("qavOriginalSortSize");\n        var significanceLevel = evenRound((1.96 * (1 / Math.sqrt(totalStatements))), 5);\n        return significanceLevel;\n    };\n\n    // ***************************************************************  model\n    // **********  calc h2 communalities  ***********************************\n    //***********************************************************************\n\n    ROTA.calculateCommunalities = function (currentFactorData) {\n        var calculateCommunalityArray = _.cloneDeep(currentFactorData);\n        var temp, temp2, temp3, temp4, i, roundedValue, chartDataLength;\n        var communalitiesArray = [];\n        var fSigCriterion = [];\n\n        // calculateCommunalityArray.shift();\n        function square(m) {\n            return m * m;\n        }\n\n        _.forEach(calculateCommunalityArray, function (n) {\n            temp = (_.map(n, square));\n            temp2 = temp.reduce(function (a, b) {\n                return a + b;\n            }, 0);\n            temp3 = evenRound((temp2), 5);\n            communalitiesArray.push(temp3);\n\n            temp4 = [];\n            for (var k = 0, kLen = temp.length; k < kLen; k++) {\n                roundedValue = evenRound((temp[k]), 5);\n                temp4.push(roundedValue);\n            }\n            fSigCriterion.push(temp4);\n        });\n\n        QAV.setState("fSigCriterion", fSigCriterion);\n        QAV.setState("rowH2", communalitiesArray);\n\n        chartDataLength = calculateCommunalityArray.length;\n        for (i = 0; i < chartDataLength; i++) {\n            calculateCommunalityArray[i].push(communalitiesArray[i]);\n        }\n        return calculateCommunalityArray;\n    };\n\n    // todo - remove conditional formatting for h2 column on rotation history chart\n\n    // *******************************************************************  model\n    // ****  Calculate Fuerntratt Criterion on Communalities ********************\n    // **************************************************************************\n\n\n    // todo - relocate function?\n    ROTA.calculatefSigCriterionValues = function (addFlag) {\n        var fSigCriterionArray = QAV.getState("fSigCriterion");\n        var totalStatements = QAV.getState("qavOriginalSortSize");\n        var sigLevel2 = ROTA.calculateFactorLoadingSignificanceLevel(totalStatements);\n        var sigLevel = sigLevel2 * sigLevel2;\n        var arrayLength = fSigCriterionArray.length;\n        var arrayLength2 = fSigCriterionArray[0].length;\n        var temp1, testValue, others, others2, array, significant;\n        var i, j, tempArray;\n        var fSigCriterionResults = [];\n\n        for (i = 0; i < arrayLength; i++) {\n            temp1 = fSigCriterionArray[i];\n            tempArray = [];\n            for (j = 0; j < arrayLength2; j++) {\n                array = _.clone(temp1);\n                testValue = _.pullAt(array, j);\n                others2 = array.reduce(function (a, b) {\n                    return a + b;\n                }, 0);\n                others = evenRound((others2), 5);\n\n                if (addFlag === "flag") {\n                    if (testValue > others && testValue > sigLevel) {\n                        significant = \'true\';\n                    } else {\n                        significant = "false";\n                    }\n                } else {\n                    significant = \'false\';\n                }\n                tempArray.push(significant);\n            }\n            fSigCriterionResults.push(tempArray);\n        }\n        QAV.setState("fSigCriterionResults", fSigCriterionResults);\n    };\n\n    // *****************************************************************  model\n    // ******  Rotation procedure  ********************************************\n    // ************************************************************************\n\n    ROTA.calcSinDegrees = function (num) {\n        return Math.sin(num * (Math.PI / 180));\n    };\n\n    ROTA.calcCosDegrees = function (num) {\n        return Math.cos(num * (Math.PI / 180));\n    };\n\n    ROTA.newRotateClockwise = function (calculateRotationsArray, rotationDegree) {\n        var transposedArray = _.zip.apply(_, calculateRotationsArray);\n        var sinDegreesValue = (ROTA.calcSinDegrees(rotationDegree));\n        var cosDegreesValue = (ROTA.calcCosDegrees(rotationDegree));\n        var valueA, valueB, tempArray;\n        var len = transposedArray[0].length;\n        var a1Calculations, b1Calculations;\n        var a2Calculations, b2Calculations;\n        var rotatedFactorsArray = [];\n\n        for (var k = 0; k < len; k++) {\n            a1Calculations = transposedArray[1][k] * sinDegreesValue;\n            b1Calculations = transposedArray[0][k] * cosDegreesValue;\n            valueA = (evenRound((a1Calculations + b1Calculations), 5));\n            a2Calculations = transposedArray[0][k] * sinDegreesValue;\n            b2Calculations = transposedArray[1][k] * cosDegreesValue;\n            valueB = (evenRound((-(a2Calculations - b2Calculations)), 5));\n            tempArray = [];\n            tempArray[0] = valueA;\n            tempArray[1] = valueB;\n            rotatedFactorsArray.push(tempArray);\n        }\n        return rotatedFactorsArray;\n    };\n\n    ROTA.newRotateCounterClockwise = function (calculateRotationsArray, rotationDegree) {\n        var transposedArray = _.zip.apply(_, calculateRotationsArray);\n        var sinDegreesValue = (ROTA.calcSinDegrees(rotationDegree));\n        var cosDegreesValue = (ROTA.calcCosDegrees(rotationDegree));\n        var valueA, valueB;\n        var len = transposedArray[0].length;\n        var a1Calculations, b1Calculations;\n        var a2Calculations, b2Calculations;\n        var rotatedFactorsArray = [];\n\n        for (var k = 0; k < len; k++) {\n            a1Calculations = transposedArray[1][k] * sinDegreesValue;\n            b1Calculations = transposedArray[0][k] * cosDegreesValue;\n            valueA = (evenRound((-(a1Calculations - b1Calculations)), 5));\n            a2Calculations = transposedArray[0][k] * sinDegreesValue;\n            b2Calculations = transposedArray[1][k] * cosDegreesValue;\n            valueB = (evenRound(((a2Calculations + b2Calculations)), 5));\n            var tempArray = [];\n            tempArray[0] = valueA;\n            tempArray[1] = valueB;\n            rotatedFactorsArray.push(tempArray);\n        }\n        return rotatedFactorsArray;\n    };\n\n\n    ROTA.calculateRotatedFactors = function (rotationDegree) {\n        var rotationFactorA = QAV.getState("rotationFactorA");\n        var rotationFactorB = QAV.getState("rotationFactorB");\n        var counterClockwiseRotation = false;\n        var calculateRotationsArray = QAV.getState("calculateRotationsArray");\n        var tempRotFacStateArray = QAV.getState("tempRotFacStateArray");\n        var rotatedFactors;\n        var looplen = calculateRotationsArray.length;\n\n        if (rotationDegree < 0) {\n            counterClockwiseRotation = true;\n        }\n\n        rotationDegree = Math.abs(rotationDegree);\n\n        if (counterClockwiseRotation !== true) {\n            rotatedFactors = ROTA.newRotateClockwise(calculateRotationsArray, rotationDegree);\n        } else {\n            rotatedFactors = ROTA.newRotateCounterClockwise(calculateRotationsArray, rotationDegree);\n        }\n\n        //insert rotated factors into temp rotational state array\n        for (var i = 0; i < looplen; i++) {\n            tempRotFacStateArray[i][rotationFactorA - 1] = rotatedFactors[i][0];\n            tempRotFacStateArray[i][rotationFactorB - 1] = rotatedFactors[i][1];\n        }\n\n        // create obj for two factor table display\n        ROTA.setTwoFactorRotationalArray(tempRotFacStateArray);\n\n        // expects bare full array\n        var arrayWithCommunalities = ROTA.calculateCommunalities(tempRotFacStateArray);\n\n        // gets array for fSig testing from LS of calculateCommunalities - sets fSigCriterionResults\n        ROTA.calculatefSigCriterionValues("flag");\n\n        // returns dataValuesArray for D3 chart\n        var d3Prep = ROTA.doD3ChartDataPrep(arrayWithCommunalities);\n\n        ROTA.drawD3Chart(d3Prep);\n        var prepTwoFactorTable = ROTA.prepTwoFactorUpdateHandsontable(tempRotFacStateArray);\n\n        // re-draw two factor rotation table\n        var isNewSelection = false;\n        ROTA.updateDatatable1(prepTwoFactorTable, isNewSelection);\n\n        // console.log(\'%c Factor rotation calcs completed in  \' + (time1 - time0).toFixed(3) + \' milliseconds\', \'background: aquamarine; color: black\');\n\n        QAV.setState("calculateRotationsArray", rotatedFactors);\n        QAV.setState("tempRotFacStateArray", tempRotFacStateArray);\n    };\n\n\n    // ************************************************************* model\n    // ****  prep two factor and create initial rot array ****************\n    // *******************************************************************\n    ROTA.prepTwoFactorUpdateHandsontable = function (chartData) {\n        var twoFactorTableArray = [];\n        var step1, i, step3, tempObj;\n        var rotationFactorA = QAV.getState("rotationFactorA");\n        var rotationFactorB = QAV.getState("rotationFactorB");\n        var fSigCriterionResults = QAV.getState("fSigCriterionResults");\n        var respondentNames = QAV.getState("qavRespondentNames");\n        var ilen = chartData.length;\n\n        for (i = 0; i < ilen; i++) {\n            step1 = chartData[i];\n            step3 = fSigCriterionResults[i];\n            tempObj = {\n                respondent: respondentNames[i],\n                factor1: step1[rotationFactorA - 1],\n                factor1Sig: step3[rotationFactorA - 1],\n                factor2: step1[rotationFactorB - 1],\n                factor2Sig: step3[rotationFactorB - 1],\n            };\n            twoFactorTableArray.push(tempObj);\n        }\n        return twoFactorTableArray;\n    };\n\n\n    // **************************************************************  model\n    // **** initial array for two factor table ****************************\n    // ********************************************************************\n    ROTA.setTwoFactorRotationalArray = function (chartData) {\n        var rotationFactorA = QAV.getState("rotationFactorA");\n        var rotationFactorB = QAV.getState("rotationFactorB");\n        var ilen = chartData.length;\n        var calculateRotationsArray = [];\n        var tempArray;\n        var temp1;\n        var temp2;\n\n        for (var i = 0; i < ilen; i++) {\n            tempArray = [];\n            temp1 = chartData[i][rotationFactorA - 1];\n            temp2 = chartData[i][rotationFactorB - 1];\n            tempArray.push(temp1, temp2);\n            calculateRotationsArray.push(tempArray);\n        }\n        QAV.setState("calculateRotationsArray", calculateRotationsArray);\n        return calculateRotationsArray;\n    };\n\n\n    // *************************************************************** view\n    // ******  draw two factors table  ************************************\n    // ********************************************************************\n    ROTA.updateDatatable1 = function (newData, isNewSelection) {\n\n        // todo - fix error on baselinedata setting after displaying factors once\n        var i, baseLineData, tempArray1, temp1, temp1a, temp2, temp2b, temp2a;\n        var new2FactorDataArray = [];\n        var temp4, temp6a, temp6b, table;\n        var temp7, temp8, testVar;\n\n        // check to see if datatabel already exists - returns boolean\n        testVar = $.fn.dataTable.isDataTable(\'#twoFactorDisplayTable\');\n        var facA = QAV.getState("rotationFactorA");\n        var facB = QAV.getState("rotationFactorB");\n        var facAName = "Fac. " + facA;\n        var facAChange = "Chg. " + facA;\n        var facBName = "Fac. " + facB;\n        var facBChange = "Chg. " + facB;\n        var newHeaderArray = ["Res.", "Name", facAName, facAChange, facBName, facBChange];\n        var rotChartConfig = QAV.getState("rotChartConfig");\n        var significanceColorA = rotChartConfig.significanceColorA;\n        var significanceColorB = rotChartConfig.significanceColorB;\n\n        if (rotChartConfig.removeCircleHighlight === true) {\n            significanceColorA = "rgba(33, 33, 33, 0.0)";\n            significanceColorB = "rgba(33, 33, 33, 0.0)";\n        }\n\n        if (testVar === true) { //\n\n            baseLineData = QAV.getState("baseLineData");\n\n            new2FactorDataArray = [];\n            for (i = 0; i < newData.length; i++) {\n                tempArray1 = [];\n                temp1a = i + 1;\n                // adds resp. number\n                tempArray1.push(temp1a);\n                temp1 = newData[i].respondent;\n                // adds respondent name\n                tempArray1.push(temp1);\n\n                temp2 = newData[i].factor1;\n                // adds factor 1 calced value\n                tempArray1.push(temp2);\n                temp2b = baseLineData[i].factor1;\n                temp2a = evenRound((temp2 - temp2b), 5);\n                // adds diff\n                tempArray1.push(temp2a);\n\n                temp4 = newData[i].factor2;\n                // adds factor 2 calced value\n                tempArray1.push(temp4);\n                temp6b = baseLineData[i].factor2;\n                temp6a = evenRound((temp4 - temp6b), 5);\n                // adds diff\n                tempArray1.push(temp6a);\n\n                temp7 = newData[i].factor1Sig;\n                temp8 = newData[i].factor2Sig;\n                tempArray1.push(temp7, temp8);\n                new2FactorDataArray.push(tempArray1);\n            }\n\n            table = $(\'#twoFactorDisplayTable\').DataTable();\n            table.clear();\n            for (var j = 0; j < newHeaderArray.length; j++) {\n                table.columns(j).header().to$().text(newHeaderArray[j]);\n            }\n            table.rows.add(new2FactorDataArray).draw();\n\n        } else {\n\n            baseLineData = QAV.getState("baseLineData");\n\n            if (baseLineData === null) {\n                baseLineData = [1, "", 0, 0, 0, 0];\n            }\n\n            for (i = 0; i < newData.length; i++) {\n\n                tempArray1 = [];\n                temp1a = i + 1;\n                tempArray1.push(temp1a);\n                temp1 = newData[i].respondent;\n                tempArray1.push(temp1);\n\n                temp2 = newData[i].factor1;\n                tempArray1.push(temp2);\n                temp2b = baseLineData[i].factor1;\n                temp2a = evenRound((temp2 - temp2b), 5);\n                tempArray1.push(temp2a);\n\n                temp4 = newData[i].factor2;\n                tempArray1.push(temp4);\n                temp6b = baseLineData[i].factor2;\n                temp6a = evenRound((temp4 - temp6b), 5);\n                tempArray1.push(temp6a);\n\n                temp7 = newData[i].factor1Sig;\n                temp8 = newData[i].factor2Sig;\n                tempArray1.push(temp7, temp8);\n\n                new2FactorDataArray.push(tempArray1);\n            }\n\n            // var significanceLevel = ROTA.calculateFactorLoadingSignificanceLevel();\n\n            table = $(\'#twoFactorDisplayTable\').DataTable({\n                // "dom": \'<"top"i>rt<"bottom"flp><"clear">\',\n                "retrieve": true,\n                "searching": false,\n                "ordering": true,\n                "info": false,\n                "scrollY": 600,\n                "scrollCollapse": true,\n                "scrollX": true,\n                "paging": false,\n                //"autoWidth": true,\n                "columnDefs": [{\n                    targets: [2, 3, 4, 5],\n                    className: \'dt-body-right\',\n                }, {\n                    targets: [0, 1],\n                    className: \'dt-body-center\'\n                }, {\n                    targets: [0],\n                    orderData: [0, 1]\n                }, {\n                    targets: [2],\n                    orderData: [2]\n                }, {\n                    targets: [3],\n                    orderData: [3]\n                }, {\n                    targets: [4],\n                    orderData: [4]\n                }, {\n                    targets: [5],\n                    orderData: [5]\n                }, {\n                    targets: [6],\n                    "visible": false\n                }, {\n                    targets: [7],\n                    "visible": false\n                }, {\n                    \'targets\': [2],\n                    "createdCell": function (td, cellData, rowData) { // row col\n\n                        if (rowData[6] === "true") {\n                            $(td).css(\'background\', significanceColorA); //\'#ffe4b2\');\n                        }\n                    }\n                }, {\n                    \'targets\': [4],\n                    "createdCell": function (td, cellData, rowData) { // row col\n                        if (rowData[7] === "true") {\n                            $(td).css(\'background\', significanceColorB);\n                        }\n                    }\n                }],\n\n                data: new2FactorDataArray,\n                "columns": [{\n                    title: "Res.",\n                    className: \'dt-head-center dt-body-center\'\n                }, {\n                    title: "Name",\n                    className: \'dt-head-center dt-body-center\'\n                }, {\n                    title: facAName, //"Fac. A",\n                    className: \'dt-head-center dt-body-right\'\n                }, {\n                    title: facAChange, // "Chg A",\n                    className: \'dt-head-center dt-body-right\'\n                }, {\n                    title: facBName, // "Fac. B",\n                    className: \'dt-head-center dt-body-right\'\n                }, {\n                    title: facBChange, // "Chg B",\n                    className: \'dt-head-center dt-body-right\'\n                }, ],\n            });\n\n            table.fixedHeader.adjust();\n            // TODO -  FOR COLUMN HIGHLIGHTING - FIND ERROR AND RESTORE\n            //        var lastIdx = null;\n            //        $(\'#twoFactorDisplayTable tbody\')\n            //            .on(\'mouseover\', \'td\', function () {\n            //                var colIdx = table.cell(this).index().column;\n            //                if (colIdx !== lastIdx) {\n            //                    $(table.cells().nodes()).removeClass(\'highlight\');\n            //                    $(table.column(colIdx).nodes()).addClass(\'highlight\');\n            //                }\n            //            })\n            //            .on(\'mouseleave\', function () {\n            //                $(table.cells().nodes()).removeClass(\'highlight\');\n            //            });\n        }\n    };\n    // **************************************************************************** model\n    // **********  save D3 rotated factors to state matrix array  ***********************\n    // **********************************************************************************\n    ROTA.saveRotation = function () {\n        var rotationDegree = sessionStorage.getItem("rotationDegreeDisplayValue");\n        var rotationFactorA = QAV.getState("rotationFactorA");\n        var rotationFactorB = QAV.getState("rotationFactorB");\n        var listText;\n        var rotFacStateArray;\n        var tempRotFacStateArray;\n\n\n        // archive factor rotation table\n        UTIL.archiveFactorScoreStateMatrixAndDatatable();\n\n        // update project history\n        var language = QAV.getState("language");\n        var appendText = resources[language].translation.Factors;\n        var appendText2 = resources[language].translation.and;\n        var appendText3 = resources[language].translation.rotated;\n        var appendText4 = resources[language].translation["rotated degrees"];\n        var appendText5 = resources[language].translation.Undo;\n\n        listText = appendText + rotationFactorA + appendText2 + rotationFactorB + appendText3 + rotationDegree + appendText4;\n        $("#rotationHistoryList").append(\'<li>\' + listText + \'<button class="deleteButton">\' + appendText5 + \'</button></li>\');\n\n        rotFacStateArray = QAV.getState("rotFacStateArray");\n        tempRotFacStateArray = QAV.getState("tempRotFacStateArray");\n\n        // save temp array as new current state array\n        QAV.setState("rotFacStateArray", tempRotFacStateArray);\n\n        // re-draw factor table\n        var isRotatedFactorsTableUpdate = "destroy";\n        LOAD.drawRotatedFactorsTable2(isRotatedFactorsTableUpdate, "noFlag");\n\n        // clear out the 2 factor rotation chart and plot\n        ROTA.reInitializePlotAndChart();\n\n        // reset degree display, button color and stored value\n        $("#handRotationDisplayContainer div").html("0&deg");\n        sessionStorage.setItem("rotationDegreeDisplayValue", 0);\n        ROTA.saveRotationButtonColor(0);\n\n        // force re-calc of results if more rotations made and then download / display buttons called\n        QAV.setState("outputComplete", "false");\n    };\n\n    //******************************************************************   model\n    //******* for rotated factors table data  handsontable version *************\n    //**************************************************************************\n    // ROTA.calculateEigenvaluesAndVariance = function () {\n    //     var numberSorts = QAV.getState("qavTotalNumberSorts");\n    //     var factorMatrix2 = QAV.getState("rotFacStateArray");\n    //     //var factorMatrix2 = _.cloneDeep(factorMatrix);\n    //     var factorMatrix1 = _.zip.apply(_, factorMatrix2);\n    //     var j, num, eigen, totalVariance;\n    //     var eigenvalues = {};\n    //     var explainedVariance = {};\n    //     var loopLen1 = factorMatrix1.length;\n    //     var results = [];\n    //     var factorNumber, factorSig;\n\n    //     eigenvalues = {\n    //         respondent: "Eigenvalues"\n    //     };\n    //     explainedVariance = {\n    //         respondent: "% Expln Var"\n    //     };\n\n    //     for (j = 0; j < loopLen1; j++) {\n    //         num = factorMatrix1[j];\n    //         for (var k = 0; k < num.length; k++) {\n    //             num[k] = evenRound((num[k] * num[k]), 8);\n    //         }\n    //         eigen = evenRound((_.reduce(num, function (sum, num2) {\n    //             return sum + num2;\n    //         })), 5);\n\n    //         factorNumber = "factor" + (j + 1);\n\n    //         factorSig = "factorSig" + (j + 1);\n    //         totalVariance = evenRound((100 * (eigen / numberSorts)), 0);\n\n    //         eigenvalues[factorNumber] = eigen;\n    //         explainedVariance[factorNumber] = totalVariance;\n\n    //         eigenvalues[factorSig] = "";\n    //         explainedVariance[factorSig] = "";\n\n    //     }\n    //     eigenvalues.communality = "";\n    //     explainedVariance.communality = "";\n    //     results.push(eigenvalues);\n    //     QAV.setState("expVar", explainedVariance);\n    //     jlog("results", results);\n    //     return results;\n    // };\n\n    //***************************************************************   model\n    //**** for rotated factors table data - datatables version **************\n    //***********************************************************************\n    ROTA.calculateEigenvaluesAndVariance2 = function () {\n        var numberSorts = QAV.getState("qavTotalNumberSorts");\n        var factorMatrix2 = QAV.getState("rotFacStateArray");\n        // var factorMatrix2 = _.cloneDeep(factorMatrix);\n        var factorMatrix1 = _.zip.apply(_, factorMatrix2);\n        var j, num, eigen, totalVariance;\n        var eigenvalues = {};\n        var explainedVariance = {};\n        var loopLen1 = factorMatrix1.length;\n        var results = [];\n        var factorNumber, factorSig;\n\n        eigenvalues = ["Eigenvalues"];\n        explainedVariance = ["% Expln Var"];\n\n        for (j = 0; j < loopLen1; j++) {\n            num = factorMatrix1[j];\n            for (var k = 0; k < num.length; k++) {\n                num[k] = evenRound((num[k] * num[k]), 8);\n            }\n            eigen = evenRound((_.reduce(num, function (sum, num2) {\n                return sum + num2;\n            })), 5);\n\n            factorNumber = "factor" + (j + 1);\n\n            factorSig = "factorSig" + (j + 1);\n            totalVariance = evenRound((100 * (eigen / numberSorts)), 0);\n\n            eigenvalues.push(eigen);\n            explainedVariance.push(totalVariance);\n\n            eigenvalues.push("");\n            explainedVariance.push("");\n        }\n        eigenvalues.push("");\n        explainedVariance.push("");\n\n        results.push(eigenvalues);\n        explainedVariance.splice(1, 0, "", "");\n        QAV.setState("expVar", explainedVariance);\n        return results;\n    };\n\n}(window.ROTA = window.ROTA || {}, QAV));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUk9UQS5qcz8xNTAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vS2VuLVEgQW5hbHlzaXNcbi8vQ29weXJpZ2h0IChDKSAyMDE2IFNoYXduIEJhbmFzaWNrXG4vL1xuLy8gICAgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuLy8gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuXG4vLyBKU2xpbnQgZGVjbGFyYXRpb25zXG4vKiBnbG9iYWwgd2luZG93LCBkMywgcGVyZm9ybWFuY2UsIHNlc3Npb25TdG9yYWdlLCBRQVYsICQsIHJlc291cmNlcywgTE9BRCwgZG9jdW1lbnQsIGV2ZW5Sb3VuZCwgVVRJTCwgXyAqL1xuXG4oZnVuY3Rpb24gKFJPVEEsIFFBViwgdW5kZWZpbmVkKSB7XG5cblxuICAgIC8vIHJlc2V0ICdoYXMgc3BsaXQgZmFjdG9yJyBtYXJrZXIgb24gcGFnZSBsb2FkXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc1NwbGl0RmFjdG9yID0gMDtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwiaGFzU3BsaXRGYWN0b3JcIiwgaGFzU3BsaXRGYWN0b3IpO1xuICAgIH0pKCk7XG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogIFZJRVcgQ09OVFJPTEVSXG4gICAgLy8gKioqKioqKioqKiAgcmUtaW5pdGlhbGl6ZSBjaGFydCBhZnRlciBzYXZlIHJvdGF0aW9uIG9yIHZhcmltYXggKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIFJPVEEucmVJbml0aWFsaXplUGxvdEFuZENoYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBkYXRhIHRvIGluaXRpYWxpemUgRDMgY2hhcnRcblxuICAgICAgICB2YXIgdGVzdFZhciA9ICQuZm4uZGF0YVRhYmxlLmlzRGF0YVRhYmxlKCcjdHdvRmFjdG9yRGlzcGxheVRhYmxlJyk7XG5cbiAgICAgICAgaWYgKHRlc3RWYXIpIHtcbiAgICAgICAgICAgIHZhciBlbXB0eUFycmF5ID0gW3tcbiAgICAgICAgICAgICAgICBcInJlc3BvbmRlbnRcIjogXCJcIixcbiAgICAgICAgICAgICAgICBcImZhY3RvcjFcIjogMCxcbiAgICAgICAgICAgICAgICBcImZhY3RvcjJcIjogMFxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB2YXIgZW1wdHlBcnJheTIgPSBbXTtcbiAgICAgICAgICAgIFJPVEEuZHJhd0QzQ2hhcnQoZW1wdHlBcnJheSk7XG4gICAgICAgICAgICB2YXIgaXNOZXdTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIFJPVEEudXBkYXRlRGF0YXRhYmxlMShlbXB0eUFycmF5MiwgaXNOZXdTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBtb2RlbCBzdGF0ZVxuICAgIC8vICoqKioqKioqKiAgc2F2ZSByb3RhdGlvbiBjb3VudGVyICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAvLyBhbHdheXMgcmVzZXQgdG8gemVybyBvbiBjZW50cm9pZCBleHRyYWN0aW9uIChpbiBjZW50cm9pZC5qcyBmaWxlKVxuICAgIFJPVEEuc2F2ZVJvdGF0aW9uQXJjaGl2ZUNvdW50ZXIgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHZhciBzYXZlUm90YXRpb25Db3VudGVyID0gUUFWLmdldFN0YXRlKFwic2F2ZVJvdGF0aW9uQ291bnRlclwiKTtcbiAgICAgICAgaWYgKG9wdGlvbiA9PT0gXCJpbmNyZWFzZVwiKSB7XG4gICAgICAgICAgICBzYXZlUm90YXRpb25Db3VudGVyID0gc2F2ZVJvdGF0aW9uQ291bnRlciArIDE7XG4gICAgICAgICAgICBRQVYuc2V0U3RhdGUoXCJzYXZlUm90YXRpb25Db3VudGVyXCIsIHNhdmVSb3RhdGlvbkNvdW50ZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbiA9PT0gXCJkZWNyZWFzZVwiKSB7XG4gICAgICAgICAgICBzYXZlUm90YXRpb25Db3VudGVyID0gc2F2ZVJvdGF0aW9uQ291bnRlciAtIDE7XG4gICAgICAgICAgICBRQVYuc2V0U3RhdGUoXCJzYXZlUm90YXRpb25Db3VudGVyXCIsIHNhdmVSb3RhdGlvbkNvdW50ZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbiA9PT0gXCJnZXRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHNhdmVSb3RhdGlvbkNvdW50ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9uID09PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgIFFBVi5zZXRTdGF0ZShcInNhdmVSb3RhdGlvbkNvdW50ZXJcIiwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgdmlld1xuICAgIC8vICoqKiogIFJvdGF0aW9uIGJ1dHRvbiBzdGF0ZSAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBST1RBLnNhdmVSb3RhdGlvbkJ1dHRvbkNvbG9yID0gZnVuY3Rpb24gKHJvdGF0aW9uRGVncmVlRGlzcGxheVZhbHVlKSB7XG4gICAgICAgIHZhciBzYXZlUm90QnV0dG9uID0gJChcIiNzYXZlUm90YXRpb25CdXR0b25cIik7XG4gICAgICAgIGlmIChyb3RhdGlvbkRlZ3JlZURpc3BsYXlWYWx1ZSAhPT0gMCkge1xuICAgICAgICAgICAgc2F2ZVJvdEJ1dHRvbi5yZW1vdmVDbGFzcyhcInNhdmVSb3RhdGlvbkJ1dHRvbkdyYXlcIik7XG4gICAgICAgICAgICBzYXZlUm90QnV0dG9uLmFkZENsYXNzKFwic2F2ZVJvdGF0aW9uQnV0dG9uWWVsbG93XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2F2ZVJvdEJ1dHRvbi5yZW1vdmVDbGFzcyhcInNhdmVSb3RhdGlvbkJ1dHRvblllbGxvd1wiKTtcbiAgICAgICAgICAgIHNhdmVSb3RCdXR0b24uYWRkQ2xhc3MoXCJzYXZlUm90YXRpb25CdXR0b25HcmF5XCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKiAgICBEMyBDb2RlIFNhdmUgYXMgSW1hZ2UgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vXG4gICAgLy8gZXhhbXBsZSAtIGh0dHA6Ly9wbG5rci5jby9lZGl0L01rWmNYSlBTN2hyY1doM00wTVoxP3A9cHJldmlld1xuICAgIC8vIGh0dHA6Ly93d3cuaW5rZm9vZC5jb20vc3ZnLXRvLWNhbnZhcy9cbiAgICAvLyBodHRwczogLy9naXRodWIuY29tL3NhbXB1bW9uL1NWRy50b0RhdGFVUkxcbiAgICAvLyBjaGFuZ2UgZGF0YSBmb3JtYXQgdG8gSlNPTlxuXG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogIHZpZXcgY29udHJvbGxlclxuICAgIC8vICoqKioqKioqKioqKiogICAgU0FWRSBTRUxFQ1RFRCBmYWN0b3JzIGZvciByb3RhdGlvbiAgICoqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBST1RBLnNldFJvdGF0aW9uRmFjdG9yc0Zyb21DaGVja2JveCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGZhY3RvcnMgdG8gc2VuZCB0byAyIGZhY3RvciBjaGFydFxuICAgICAgICB2YXIgcHVsbEZhY3RvcnMgPSBbXTtcbiAgICAgICAgdmFyIGNoZWNrYm94ZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSgncmFkaW9DaGVjaycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoZWNrYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaGVja2JveGVzW2ldLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBwdWxsRmFjdG9ycy5wdXNoKGNoZWNrYm94ZXNbaV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWNjb3VudCBmb3Igc2VuZGluZyBudWxsIHNldCBvbiBwYWdlIGxvYWQgdG8gZGlzcGxheSBlbXB0eSBjaGFydFxuICAgICAgICBpZiAocHVsbEZhY3RvcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByb3RhdGlvbkZhY3RvckEgPSBwdWxsRmFjdG9yc1swXTtcbiAgICAgICAgICAgIHZhciByb3RhdGlvbkZhY3RvckIgPSBwdWxsRmFjdG9yc1sxXTtcbiAgICAgICAgICAgIFFBVi5zZXRTdGF0ZShcInJvdGF0aW9uRmFjdG9yQVwiLCByb3RhdGlvbkZhY3RvckEpO1xuICAgICAgICAgICAgUUFWLnNldFN0YXRlKFwicm90YXRpb25GYWN0b3JCXCIsIHJvdGF0aW9uRmFjdG9yQik7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVsbEZhY3RvcnM7XG4gICAgfTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogIGRhdGEgbW9kZWxcbiAgICAvLyAqKioqKioqKioqKioqICAgRGF0YSBmb3JtYXQgYXJyYXkgdG8gb2JqZWN0ICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLy8gQ0FMTEVEIEJZIFwiRElTUExBWSBGQUNUT1JTIEZPUiBST1RBVElPTiBCVVRUT05cIlxuICAgIFJPVEEuZG9EM0NoYXJ0RGF0YVByZXAgPSBmdW5jdGlvbiAocm90RmFjU3RhdGVBcnJheSkge1xuICAgICAgICB2YXIgcm90YXRpb25GYWN0b3JBID0gUUFWLmdldFN0YXRlKFwicm90YXRpb25GYWN0b3JBXCIpO1xuICAgICAgICB2YXIgcm90YXRpb25GYWN0b3JCID0gUUFWLmdldFN0YXRlKFwicm90YXRpb25GYWN0b3JCXCIpO1xuICAgICAgICB2YXIgc3RlcDQgPSBRQVYuZ2V0U3RhdGUoXCJxYXZSZXNwb25kZW50TmFtZXNcIik7XG4gICAgICAgIHZhciBmU2lnQ3JpdGVyaW9uUmVzdWx0cyA9IFFBVi5nZXRTdGF0ZShcImZTaWdDcml0ZXJpb25SZXN1bHRzXCIpO1xuXG4gICAgICAgIHZhciBjaGFydERhdGEgPSBfLmNsb25lRGVlcChyb3RGYWNTdGF0ZUFycmF5KTtcbiAgICAgICAgdmFyIGRhdGFWYWx1ZXNBcnJheSA9IFtdO1xuICAgICAgICB2YXIgaW5pdGlhbFR3b0ZhY3RvclRhYmxlQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIHN0ZXAxLCBzdGVwMywgaWxlbiwgZmFjdG9yTmFtZUFycmF5RnJhZywgcmVzcG9uZGVudDIsIGZhY3RvcjFjLCBmYWN0b3IyYztcbiAgICAgICAgdmFyIHRlbXBPYmo7XG5cbiAgICAgICAgaWxlbiA9IGNoYXJ0RGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzdGVwMSA9IGNoYXJ0RGF0YVtpXTtcbiAgICAgICAgICAgIHN0ZXAzID0gZlNpZ0NyaXRlcmlvblJlc3VsdHNbaV07XG5cbiAgICAgICAgICAgIC8vIENPTlZFUlQgQVJSQVkgVE8gT0JKRUNUIGZvciBEM2pzIGNoYXJ0XG4gICAgICAgICAgICB0ZW1wT2JqID0ge1xuICAgICAgICAgICAgICAgIG51bTogaSArIDEsXG4gICAgICAgICAgICAgICAgcmVzcG9uZGVudDogc3RlcDRbaV0sXG4gICAgICAgICAgICAgICAgZmFjdG9yMTogc3RlcDFbcm90YXRpb25GYWN0b3JBIC0gMV0sXG4gICAgICAgICAgICAgICAgZmFjdG9yMVNpZzogc3RlcDNbcm90YXRpb25GYWN0b3JBIC0gMV0sXG4gICAgICAgICAgICAgICAgZmFjdG9yMjogc3RlcDFbcm90YXRpb25GYWN0b3JCIC0gMV0sXG4gICAgICAgICAgICAgICAgZmFjdG9yMlNpZzogc3RlcDNbcm90YXRpb25GYWN0b3JCIC0gMV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGF0YVZhbHVlc0FycmF5LnB1c2godGVtcE9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBmYWN0b3JOYW1lQXJyYXlGcmFnID0gW107XG4gICAgICAgIHJlc3BvbmRlbnQyID0gXCJcIjtcbiAgICAgICAgZmFjdG9yMWMgPSBcIkZhY3RvciBcIiArIHJvdGF0aW9uRmFjdG9yQTtcbiAgICAgICAgZmFjdG9yMmMgPSBcIkZhY3RvciBcIiArIHJvdGF0aW9uRmFjdG9yQjtcblxuICAgICAgICBmYWN0b3JOYW1lQXJyYXlGcmFnLnB1c2gocmVzcG9uZGVudDIsIGZhY3RvcjFjLCBmYWN0b3IyYyk7XG4gICAgICAgIGluaXRpYWxUd29GYWN0b3JUYWJsZUFycmF5LnVuc2hpZnQoZmFjdG9yTmFtZUFycmF5RnJhZyk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGFWYWx1ZXNBcnJheTtcbiAgICB9O1xuXG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiB2aWV3IG1vZGVsXG4gICAgLy8gKioqKioqKiAgZHJhdyBEMyBDaGFydCAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBST1RBLmRyYXdEM0NoYXJ0ID0gZnVuY3Rpb24gKGRhdGFWYWx1ZXNBcnJheSkge1xuICAgICAgICB2YXIgcm90YXRpb25GYWN0b3JBID0gUUFWLmdldFN0YXRlKFwicm90YXRpb25GYWN0b3JBXCIpO1xuICAgICAgICB2YXIgcm90YXRpb25GYWN0b3JCID0gUUFWLmdldFN0YXRlKFwicm90YXRpb25GYWN0b3JCXCIpO1xuICAgICAgICB2YXIgcm90Q2hhcnRDb25maWcgPSBRQVYuZ2V0U3RhdGUoXCJyb3RDaGFydENvbmZpZ1wiKTtcbiAgICAgICAgdmFyIHNpZ25pZmljYW5jZUNvbG9yQSwgc2lnbmlmaWNhbmNlQ29sb3JCLCBkb3RTdHJva2VDb2xvciwgaWRlbnRpZmllcjtcbiAgICAgICAgdmFyIGRhdGEsIGRlZmF1bHREb3RDb2xvciwgY3VzdG9tRm9udFNpemU7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI2QzX3NjYXR0ZXJjaGFydCBzdmdcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGhpZ2hsaWdodGluZyBmcm9tIGNpcmNsZXNcbiAgICAgICAgaWYgKHJvdENoYXJ0Q29uZmlnLnJlbW92ZUNpcmNsZUhpZ2hsaWdodCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmNlQ29sb3JBID0gXCJyZ2JhKDMzLCAzMywgMzMsIDAuMClcIjtcbiAgICAgICAgICAgIHNpZ25pZmljYW5jZUNvbG9yQiA9IFwicmdiYSgzMywgMzMsIDMzLCAwLjApXCI7XG4gICAgICAgICAgICBkZWZhdWx0RG90Q29sb3IgPSBcInJnYmEoMzMsIDMzLCAzMywgMC4wKVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmNlQ29sb3JBID0gcm90Q2hhcnRDb25maWcuc2lnbmlmaWNhbmNlQ29sb3JBUHJlcDtcbiAgICAgICAgICAgIHNpZ25pZmljYW5jZUNvbG9yQiA9IHJvdENoYXJ0Q29uZmlnLnNpZ25pZmljYW5jZUNvbG9yQlByZXA7XG4gICAgICAgICAgICBkZWZhdWx0RG90Q29sb3IgPSBcIiNkOGQ4ZDhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3RDaGFydENvbmZpZy5yZW1vdmVDaXJjbGVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkb3RTdHJva2VDb2xvciA9IFwicmdiYSgzMywgMzMsIDMzLCAwLjApXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3RTdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdENoYXJ0Q29uZmlnLmlkZW50aWZpZXJOdW1iZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXIgPSBcIm51bWJlclwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWRlbnRpZmllciA9IFwibmFtZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdENoYXJ0Q29uZmlnLmNoYW5nZUZvbnRTaXplID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjdXN0b21Gb250U2l6ZSA9IHJvdENoYXJ0Q29uZmlnLmN1c3RvbUZvbnRTaXplICsgXCJweFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VzdG9tRm9udFNpemUgPSBcIjlweFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhjdXN0b21Gb250U2l6ZSk7XG5cbiAgICAgICAgLy8gdmFyIHNpZ25pZmljYW5jZUxldmVsID0gUk9UQS5jYWxjdWxhdGVGYWN0b3JMb2FkaW5nU2lnbmlmaWNhbmNlTGV2ZWwoKTtcblxuICAgICAgICBkYXRhID0gZGF0YVZhbHVlc0FycmF5O1xuXG4gICAgICAgIHZhciBjaGFydFNpemUgPSAkKHdpbmRvdykud2lkdGgoKSAvIDIuMjU7XG5cbiAgICAgICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgICAgICAgICB0b3A6IDIwLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAxMCxcbiAgICAgICAgICAgICAgICBib3R0b206IDQwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDQwXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB3aWR0aCA9IGNoYXJ0U2l6ZSAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgaGVpZ2h0ID0gY2hhcnRTaXplIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgICAgIC8vIHRvZG8gLSBjb29yZGluYXRlIHdpdGggY2FudmFzIHNpemUgb24gaHRtbCBzbyBkb3dubG9hZCB3b3Jrc1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHZhbHVlIGFjY2Vzc29yIC0gcmV0dXJucyB0aGUgdmFsdWUgdG8gZW5jb2RlIGZvciBhIGdpdmVuIGRhdGEgb2JqZWN0LlxuICAgICAgICAgKiBzY2FsZSAtIG1hcHMgdmFsdWUgdG8gYSB2aXN1YWwgZGlzcGxheSBlbmNvZGluZywgc3VjaCBhcyBhIHBpeGVsIHBvc2l0aW9uLlxuICAgICAgICAgKiBtYXAgZnVuY3Rpb24gLSBtYXBzIGZyb20gZGF0YSB2YWx1ZSB0byBkaXNwbGF5IHZhbHVlXG4gICAgICAgICAqIGF4aXMgLSBzZXRzIHVwIGF4aXNcbiAgICAgICAgICovXG5cbiAgICAgICAgLy8gc2V0dXAgeFxuICAgICAgICB2YXIgeFZhbHVlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5mYWN0b3IyO1xuICAgICAgICAgICAgfSwgLy8gZGF0YSAtPiB2YWx1ZVxuICAgICAgICAgICAgeFNjYWxlID0gZDMuc2NhbGUubGluZWFyKCkucmFuZ2UoWzAsIHdpZHRoXSksIC8vIHZhbHVlIC0+IGRpc3BsYXlcbiAgICAgICAgICAgIHhNYXAgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4U2NhbGUoeFZhbHVlKGQpKTtcbiAgICAgICAgICAgIH0sIC8vIGRhdGEgLT4gZGlzcGxheVxuICAgICAgICAgICAgeEF4aXMgPSBkMy5zdmcuYXhpcygpLnNjYWxlKHhTY2FsZSkub3JpZW50KFwiYm90dG9tXCIpLnRpY2tzKDIpLnRpY2tTaXplKC1oZWlnaHQsIDAsIDApLnRpY2tQYWRkaW5nKDEwKTtcblxuICAgICAgICAvLyBzZXR1cCB5XG4gICAgICAgIHZhciB5VmFsdWUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmZhY3RvcjE7XG4gICAgICAgICAgICB9LCAvLyBkYXRhIC0+IHZhbHVlXG4gICAgICAgICAgICB5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKS5yYW5nZShbaGVpZ2h0LCAwXSksIC8vIHZhbHVlIC0+IGRpc3BsYXlcbiAgICAgICAgICAgIHlNYXAgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5U2NhbGUoeVZhbHVlKGQpKTtcbiAgICAgICAgICAgIH0sIC8vIGRhdGEgLT4gZGlzcGxheVxuICAgICAgICAgICAgeUF4aXMgPSBkMy5zdmcuYXhpcygpLnNjYWxlKHlTY2FsZSkub3JpZW50KFwibGVmdFwiKS50aWNrcygyKS50aWNrU2l6ZSgtd2lkdGgsIDAsIDApLnRpY2tQYWRkaW5nKDEwKTtcblxuICAgICAgICAvLyBhZGQgdGhlIGdyYXBoIGNhbnZhcyB0byB0aGUgd2VicGFnZVxuICAgICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KFwiI2QzX3NjYXR0ZXJjaGFydFwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgICAgICAgICAgLmF0dHIoXCJmb250LWZhbWlseVwiLCBcIkFyaWFsXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwic2NhdHRlckNoYXJ0XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICAvLyBjb25maXJtIG51bWJlciBmb3JtYXRcbiAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBkLmZhY3RvcjEgPSArZC5mYWN0b3IxO1xuICAgICAgICAgICAgZC5mYWN0b3IyID0gK2QuZmFjdG9yMjtcbiAgICAgICAgICAgIGQuZmFjdG9yMVNpZyA9IGQuZmFjdG9yMVNpZyArICcnO1xuICAgICAgICAgICAgZC5mYWN0b3IyU2lnID0gZC5mYWN0b3IyU2lnICsgJyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBjYXNlIHdpdGggZmFjdG9yIGxvYWRpbmcgZ3JlYXRlciB0aGFuIDEgYW5kIGFkanVzdCBheGlzXG4gICAgICAgIHZhciBheGlzTWF4O1xuICAgICAgICB2YXIgbWF4WEF4aXMgPSBkMy5tYXgoZGF0YSwgeFZhbHVlKTtcbiAgICAgICAgdmFyIG1pblhBeGlzID0gZDMubWluKGRhdGEsIHhWYWx1ZSk7XG4gICAgICAgIHZhciBtYXhZQXhpcyA9IGQzLm1heChkYXRhLCB5VmFsdWUpO1xuICAgICAgICB2YXIgbWluWUF4aXMgPSBkMy5taW4oZGF0YSwgeVZhbHVlKTtcblxuICAgICAgICB2YXIgYXhpc1Rlc3RBcnJheSA9IFttYXhYQXhpcywgbWluWEF4aXMsIG1heFlBeGlzLCBtaW5ZQXhpc107XG4gICAgICAgIHZhciBtYXhBcnJheVZhbHVlID0gXy5tYXgoYXhpc1Rlc3RBcnJheSk7XG4gICAgICAgIHZhciBtaW5BcnJheVZhbHVlID0gXy5taW4oYXhpc1Rlc3RBcnJheSk7XG5cbiAgICAgICAgaWYgKG1heEFycmF5VmFsdWUgPiAxIHx8IG1pbkFycmF5VmFsdWUgPCAtMSkge1xuICAgICAgICAgICAgaWYgKG1heEFycmF5VmFsdWUgPiAtbWluQXJyYXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGF4aXNNYXggPSBtYXhBcnJheVZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBheGlzTWF4ID0gLW1pbkFycmF5VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBheGlzTWF4ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhTY2FsZS5kb21haW4oWy1heGlzTWF4LCArYXhpc01heF0pO1xuICAgICAgICB5U2NhbGUuZG9tYWluKFstYXhpc01heCwgK2F4aXNNYXhdKTtcblxuICAgICAgICAvLyBkZWZpbmUgdGhlIGRpdiBmb3IgdGhlIHRvb2x0aXAgICAjZDNfc2NhdHRlcmNoYXJ0XG4gICAgICAgIHZhciBkaXYgPSBkMy5zZWxlY3QoXCIjZDNfc2NhdHRlcmNoYXJ0XCIpLmFwcGVuZChcImRpdlwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImQzVG9vbHRpcFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcblxuICAgICAgICAvLyB4LWF4aXNcbiAgICAgICAgc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHdpZHRoKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIC02KVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJBcmlhbFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIik7XG5cbiAgICAgICAgLy8gY3JlYXRlIHggYXhpcyB0aXRsZVxuICAgICAgICBzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHdpZHRoIC8gMilcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyAzNSlcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIkFyaWFsXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLCBcImJvbGRcIilcbiAgICAgICAgICAgIC50ZXh0KFwiRmFjdG9yIFwiICsgcm90YXRpb25GYWN0b3JCKTtcblxuICAgICAgICAvLyB5LWF4aXNcbiAgICAgICAgc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5IGF4aXNcIilcbiAgICAgICAgICAgIC5jYWxsKHlBeGlzKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTkwKVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDYpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLjcxZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiQXJpYWxcIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpO1xuICAgICAgICAvLyAuc2VsZWN0QWxsKCdwYXRoJylcbiAgICAgICAgLy8gLnN0eWxlKCdzdHJva2UnLCAncmVkJylcbiAgICAgICAgLy8gLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAvLyAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsICc1cHgnKTtcbiAgICAgICAgLy8gLnRleHQoXCJGYWN0b3IgXCIgKyByb3RhdGlvbkZhY3RvckEpO1xuXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5heGlzIGxuZSwgLmF4aXMgcGF0aCwgLm1pbm9yJylcbiAgICAgICAgICAgIC5zdHlsZSh7XG4gICAgICAgICAgICAgICAgJ3N0cm9rZSc6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgJ2ZpbGwnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICcxcHgnLFxuICAgICAgICAgICAgICAgICdzaGFwZS1yZW5kZXJpbmcnOiAnY3Jpc3BFZGdlcydcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGQzLnNlbGVjdEFsbCgnZy50aWNrJylcbiAgICAgICAgICAgIC5zdHlsZSh7XG4gICAgICAgICAgICAgICAgJ3N0cm9rZSc6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgJ2ZpbGwnOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAnMXB4JyxcbiAgICAgICAgICAgICAgICAnc2hhcGUtcmVuZGVyaW5nJzogJ2NyaXNwRWRnZXMnXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIGNyZWF0ZSBZIGF4aXMgbGFiZWxcbiAgICAgICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MClcIilcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwIC0gbWFyZ2luLmxlZnQpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMCAtIChoZWlnaHQgLyAyKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIxZW1cIilcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIkFyaWFsXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLCBcImJvbGRcIilcbiAgICAgICAgICAgIC50ZXh0KFwiRmFjdG9yIFwiICsgcm90YXRpb25GYWN0b3JBKTtcblxuXG4gICAgICAgIC8qICBkcmF3aW5nIGRvdHMgYW5kIGNpcmNsZXMgYmFzZWQgb24gaHR0cDovL2pzZmlkZGxlLm5ldC9lYW1vbm5tYWcvUTU2N3MvICAgKi9cblxuICAgICAgICAvKiAgICB0ZWxsaW5nIEQzIHRoYXQgYWxsIG5vZGVzIChnIGVsZW1lbnRzIHdpdGggY2xhc3Mgbm9kZSkgd2lsbCBoYXZlIGRhdGEgYXR0YWNoZWQgdG8gdGhlbS4gVGhlICdrZXknIHVzZWQgKHRvIGxldCBEMyBrbm93IHRoZSB1bmlxdWVuZXNzIG9mIGl0ZW1zKSB3aWxsIGJlIHRoZSBcIm51bVwiICovXG4gICAgICAgIHZhciBpbmRleCA9IHN2Zy5zZWxlY3RBbGwoXCJnLm5vZGVcIikuZGF0YShkYXRhLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQubnVtO1xuICAgICAgICB9KTtcblxuICAgICAgICAvKiAnZW50ZXInIHRoZSBkYXRhLCBtYWtpbmcgdGhlIFNWRyBncm91cCAodG8gY29udGFpbiBhIGNpcmNsZSBhbmQgdGV4dCkgd2l0aCBhIGNsYXNzIG5vZGUuIFRoaXMgY29ycmVzcG9uZHMgd2l0aCB3aGF0IHdlIHRvbGQgdGhlIGRhdGEgaXQgc2hvdWxkIGJlIGFib3ZlLiAqL1xuICAgICAgICB2YXIgaW5kZXhHcm91cCA9IGluZGV4LmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlXCIpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4TWFwKGQpICsgXCIsXCIgKyB5TWFwKGQpICsgXCIpXCI7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgdGhlIGNpcmNsZXNcbiAgICAgICAgaW5kZXhHcm91cC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwiclwiLCA5KVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRvdFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGRvdFN0cm9rZUNvbG9yKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmZhY3RvcjFTaWcgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoc2lnbmlmaWNhbmNlQ29sb3JBKTsgLy9cIiNmZmU0YjJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGQuZmFjdG9yMlNpZyA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzaWduaWZpY2FuY2VDb2xvckIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZGVmYXVsdERvdENvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgZGl2LnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgICAgIGRpdi5odG1sKFwiPHN0cm9uZz5cIiArIGQucmVzcG9uZGVudCArIFwiPC9zdHJvbmc+PGJyPlwiICsgeVZhbHVlKGQpICsgXCIsIOOAgFwiICsgeFZhbHVlKGQpKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIChkMy5ldmVudC5wYWdlWCArIDEwKSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwidG9wXCIsIChkMy5ldmVudC5wYWdlWSAtIDI4KSArIFwicHhcIik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRpdi50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgdGV4dCBsYWJlbHNcbiAgICAgICAgaW5kZXhHcm91cC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRvdFRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZm9udC1mYW1pbHlcIiwgXCJBcmlhbFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJmb250LXNpemVcIiwgY3VzdG9tRm9udFNpemUpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIDMpXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIGlmIChpZGVudGlmaWVyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLm51bTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5yZXNwb25kZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICBkaXYudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICAgICAgZGl2Lmh0bWwoXCI8c3Ryb25nPlwiICsgZC5yZXNwb25kZW50ICsgXCI8L3N0cm9uZz48YnI+XCIgKyB5VmFsdWUoZCkgKyBcIiwg44CAXCIgKyB4VmFsdWUoZCkpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgKGQzLmV2ZW50LnBhZ2VYICsgMTApICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJ0b3BcIiwgKGQzLmV2ZW50LnBhZ2VZIC0gMjgpICsgXCJweFwiKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGl2LnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vICB0b2RvIC0gY2hlY2sgdG8gc2VlIGlmIEkgbmVlZCB0byBleGl0IHRoZSBkb3RzXG4gICAgfTtcblxuICAgIC8vIHRvZG8gLSBzdG9yZSB0aGlzIGluZm8gb24gYXV0byBmbGFnZ2luZyBzb21ld2hlcmUgZWxzZVxuICAgIC8vVGhlc2UgYXJlIHRoZSB0d28gc3RhbmRhcmQgY3JpdGVyaWEgZm9yIGF1dG9tYXRpYyBmbGFnZ2luZyB1c2VkIGluIFEgbWV0aG9kIGFuYWx5c2lzOlxuICAgIC8vMS4gUS1zb3J0cyB3aGljaCBmYWN0b3IgbG9hZGluZyBpcyBoaWdoZXIgdGhhbiB0aGUgdGhyZXNob2xkIGZvciBwLXZhbHVlIDwgMC4wNSwgYW5kXG4gICAgLy8yLiBRLXNvcnRzIHdoaWNoIHNxdWFyZSBsb2FkaW5nIGlzIGhpZ2hlciB0aGFuIHRoZSBzdW0gb2Ygc3F1YXJlIGxvYWRpbmdzIG9mIHRoZSBzYW1lIFEtc29ydCBpblxuICAgIC8vICAgIGFsbCBvdGhlciBmYWN0b3JzLlxuXG4gICAgLy8gQyBGbGFnIEl0ZW0gSSBvbiBGYWN0b3IgSiBpZiBBXjIvSF4yID4gLjUgKEZ1ZXJudHJhdHQtQ3JpdGVyaW9uKSBwcmVsaW1pbmFyeSBmbGFnZ2luZyBtZXRob2RcbiAgICAvLyBDICphbmQqIGEgPiAxLjk2L3NxcnQobml0ZW1zKVxuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogZGF0YSBhbmFseXNpc1xuICAgIC8vICoqKioqKioqICBjYWxjIHNpZ25pZmljYW5jZSBMZXZlbHMgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBST1RBLmNhbGN1bGF0ZUZhY3RvckxvYWRpbmdTaWduaWZpY2FuY2VMZXZlbCA9IGZ1bmN0aW9uICh0b3RhbFN0YXRlbWVudHMpIHtcbiAgICAgICAgLy8gdmFyIHRvdGFsU3RhdGVtZW50cyA9IFFBVi5nZXRTdGF0ZShcInFhdk9yaWdpbmFsU29ydFNpemVcIik7XG4gICAgICAgIHZhciBzaWduaWZpY2FuY2VMZXZlbCA9IGV2ZW5Sb3VuZCgoMS45NiAqICgxIC8gTWF0aC5zcXJ0KHRvdGFsU3RhdGVtZW50cykpKSwgNSk7XG4gICAgICAgIHJldHVybiBzaWduaWZpY2FuY2VMZXZlbDtcbiAgICB9O1xuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICBtb2RlbFxuICAgIC8vICoqKioqKioqKiogIGNhbGMgaDIgY29tbXVuYWxpdGllcyAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBST1RBLmNhbGN1bGF0ZUNvbW11bmFsaXRpZXMgPSBmdW5jdGlvbiAoY3VycmVudEZhY3RvckRhdGEpIHtcbiAgICAgICAgdmFyIGNhbGN1bGF0ZUNvbW11bmFsaXR5QXJyYXkgPSBfLmNsb25lRGVlcChjdXJyZW50RmFjdG9yRGF0YSk7XG4gICAgICAgIHZhciB0ZW1wLCB0ZW1wMiwgdGVtcDMsIHRlbXA0LCBpLCByb3VuZGVkVmFsdWUsIGNoYXJ0RGF0YUxlbmd0aDtcbiAgICAgICAgdmFyIGNvbW11bmFsaXRpZXNBcnJheSA9IFtdO1xuICAgICAgICB2YXIgZlNpZ0NyaXRlcmlvbiA9IFtdO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZUNvbW11bmFsaXR5QXJyYXkuc2hpZnQoKTtcbiAgICAgICAgZnVuY3Rpb24gc3F1YXJlKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBtICogbTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uZm9yRWFjaChjYWxjdWxhdGVDb21tdW5hbGl0eUFycmF5LCBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgdGVtcCA9IChfLm1hcChuLCBzcXVhcmUpKTtcbiAgICAgICAgICAgIHRlbXAyID0gdGVtcC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHRlbXAzID0gZXZlblJvdW5kKCh0ZW1wMiksIDUpO1xuICAgICAgICAgICAgY29tbXVuYWxpdGllc0FycmF5LnB1c2godGVtcDMpO1xuXG4gICAgICAgICAgICB0ZW1wNCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGtMZW4gPSB0ZW1wLmxlbmd0aDsgayA8IGtMZW47IGsrKykge1xuICAgICAgICAgICAgICAgIHJvdW5kZWRWYWx1ZSA9IGV2ZW5Sb3VuZCgodGVtcFtrXSksIDUpO1xuICAgICAgICAgICAgICAgIHRlbXA0LnB1c2gocm91bmRlZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZTaWdDcml0ZXJpb24ucHVzaCh0ZW1wNCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFFBVi5zZXRTdGF0ZShcImZTaWdDcml0ZXJpb25cIiwgZlNpZ0NyaXRlcmlvbik7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInJvd0gyXCIsIGNvbW11bmFsaXRpZXNBcnJheSk7XG5cbiAgICAgICAgY2hhcnREYXRhTGVuZ3RoID0gY2FsY3VsYXRlQ29tbXVuYWxpdHlBcnJheS5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGFydERhdGFMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2FsY3VsYXRlQ29tbXVuYWxpdHlBcnJheVtpXS5wdXNoKGNvbW11bmFsaXRpZXNBcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUNvbW11bmFsaXR5QXJyYXk7XG4gICAgfTtcblxuICAgIC8vIHRvZG8gLSByZW1vdmUgY29uZGl0aW9uYWwgZm9ybWF0dGluZyBmb3IgaDIgY29sdW1uIG9uIHJvdGF0aW9uIGhpc3RvcnkgY2hhcnRcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogIG1vZGVsXG4gICAgLy8gKioqKiAgQ2FsY3VsYXRlIEZ1ZXJudHJhdHQgQ3JpdGVyaW9uIG9uIENvbW11bmFsaXRpZXMgKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cbiAgICAvLyB0b2RvIC0gcmVsb2NhdGUgZnVuY3Rpb24/XG4gICAgUk9UQS5jYWxjdWxhdGVmU2lnQ3JpdGVyaW9uVmFsdWVzID0gZnVuY3Rpb24gKGFkZEZsYWcpIHtcbiAgICAgICAgdmFyIGZTaWdDcml0ZXJpb25BcnJheSA9IFFBVi5nZXRTdGF0ZShcImZTaWdDcml0ZXJpb25cIik7XG4gICAgICAgIHZhciB0b3RhbFN0YXRlbWVudHMgPSBRQVYuZ2V0U3RhdGUoXCJxYXZPcmlnaW5hbFNvcnRTaXplXCIpO1xuICAgICAgICB2YXIgc2lnTGV2ZWwyID0gUk9UQS5jYWxjdWxhdGVGYWN0b3JMb2FkaW5nU2lnbmlmaWNhbmNlTGV2ZWwodG90YWxTdGF0ZW1lbnRzKTtcbiAgICAgICAgdmFyIHNpZ0xldmVsID0gc2lnTGV2ZWwyICogc2lnTGV2ZWwyO1xuICAgICAgICB2YXIgYXJyYXlMZW5ndGggPSBmU2lnQ3JpdGVyaW9uQXJyYXkubGVuZ3RoO1xuICAgICAgICB2YXIgYXJyYXlMZW5ndGgyID0gZlNpZ0NyaXRlcmlvbkFycmF5WzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIHRlbXAxLCB0ZXN0VmFsdWUsIG90aGVycywgb3RoZXJzMiwgYXJyYXksIHNpZ25pZmljYW50O1xuICAgICAgICB2YXIgaSwgaiwgdGVtcEFycmF5O1xuICAgICAgICB2YXIgZlNpZ0NyaXRlcmlvblJlc3VsdHMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyYXlMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcDEgPSBmU2lnQ3JpdGVyaW9uQXJyYXlbaV07XG4gICAgICAgICAgICB0ZW1wQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnJheUxlbmd0aDI7IGorKykge1xuICAgICAgICAgICAgICAgIGFycmF5ID0gXy5jbG9uZSh0ZW1wMSk7XG4gICAgICAgICAgICAgICAgdGVzdFZhbHVlID0gXy5wdWxsQXQoYXJyYXksIGopO1xuICAgICAgICAgICAgICAgIG90aGVyczIgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIG90aGVycyA9IGV2ZW5Sb3VuZCgob3RoZXJzMiksIDUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFkZEZsYWcgPT09IFwiZmxhZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0VmFsdWUgPiBvdGhlcnMgJiYgdGVzdFZhbHVlID4gc2lnTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50ID0gJ3RydWUnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnQgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FudCA9ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXBBcnJheS5wdXNoKHNpZ25pZmljYW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZTaWdDcml0ZXJpb25SZXN1bHRzLnB1c2godGVtcEFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBRQVYuc2V0U3RhdGUoXCJmU2lnQ3JpdGVyaW9uUmVzdWx0c1wiLCBmU2lnQ3JpdGVyaW9uUmVzdWx0cyk7XG4gICAgfTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICBtb2RlbFxuICAgIC8vICoqKioqKiAgUm90YXRpb24gcHJvY2VkdXJlICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgUk9UQS5jYWxjU2luRGVncmVlcyA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKG51bSAqIChNYXRoLlBJIC8gMTgwKSk7XG4gICAgfTtcblxuICAgIFJPVEEuY2FsY0Nvc0RlZ3JlZXMgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNvcyhudW0gKiAoTWF0aC5QSSAvIDE4MCkpO1xuICAgIH07XG5cbiAgICBST1RBLm5ld1JvdGF0ZUNsb2Nrd2lzZSA9IGZ1bmN0aW9uIChjYWxjdWxhdGVSb3RhdGlvbnNBcnJheSwgcm90YXRpb25EZWdyZWUpIHtcbiAgICAgICAgdmFyIHRyYW5zcG9zZWRBcnJheSA9IF8uemlwLmFwcGx5KF8sIGNhbGN1bGF0ZVJvdGF0aW9uc0FycmF5KTtcbiAgICAgICAgdmFyIHNpbkRlZ3JlZXNWYWx1ZSA9IChST1RBLmNhbGNTaW5EZWdyZWVzKHJvdGF0aW9uRGVncmVlKSk7XG4gICAgICAgIHZhciBjb3NEZWdyZWVzVmFsdWUgPSAoUk9UQS5jYWxjQ29zRGVncmVlcyhyb3RhdGlvbkRlZ3JlZSkpO1xuICAgICAgICB2YXIgdmFsdWVBLCB2YWx1ZUIsIHRlbXBBcnJheTtcbiAgICAgICAgdmFyIGxlbiA9IHRyYW5zcG9zZWRBcnJheVswXS5sZW5ndGg7XG4gICAgICAgIHZhciBhMUNhbGN1bGF0aW9ucywgYjFDYWxjdWxhdGlvbnM7XG4gICAgICAgIHZhciBhMkNhbGN1bGF0aW9ucywgYjJDYWxjdWxhdGlvbnM7XG4gICAgICAgIHZhciByb3RhdGVkRmFjdG9yc0FycmF5ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgYTFDYWxjdWxhdGlvbnMgPSB0cmFuc3Bvc2VkQXJyYXlbMV1ba10gKiBzaW5EZWdyZWVzVmFsdWU7XG4gICAgICAgICAgICBiMUNhbGN1bGF0aW9ucyA9IHRyYW5zcG9zZWRBcnJheVswXVtrXSAqIGNvc0RlZ3JlZXNWYWx1ZTtcbiAgICAgICAgICAgIHZhbHVlQSA9IChldmVuUm91bmQoKGExQ2FsY3VsYXRpb25zICsgYjFDYWxjdWxhdGlvbnMpLCA1KSk7XG4gICAgICAgICAgICBhMkNhbGN1bGF0aW9ucyA9IHRyYW5zcG9zZWRBcnJheVswXVtrXSAqIHNpbkRlZ3JlZXNWYWx1ZTtcbiAgICAgICAgICAgIGIyQ2FsY3VsYXRpb25zID0gdHJhbnNwb3NlZEFycmF5WzFdW2tdICogY29zRGVncmVlc1ZhbHVlO1xuICAgICAgICAgICAgdmFsdWVCID0gKGV2ZW5Sb3VuZCgoLShhMkNhbGN1bGF0aW9ucyAtIGIyQ2FsY3VsYXRpb25zKSksIDUpKTtcbiAgICAgICAgICAgIHRlbXBBcnJheSA9IFtdO1xuICAgICAgICAgICAgdGVtcEFycmF5WzBdID0gdmFsdWVBO1xuICAgICAgICAgICAgdGVtcEFycmF5WzFdID0gdmFsdWVCO1xuICAgICAgICAgICAgcm90YXRlZEZhY3RvcnNBcnJheS5wdXNoKHRlbXBBcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdGF0ZWRGYWN0b3JzQXJyYXk7XG4gICAgfTtcblxuICAgIFJPVEEubmV3Um90YXRlQ291bnRlckNsb2Nrd2lzZSA9IGZ1bmN0aW9uIChjYWxjdWxhdGVSb3RhdGlvbnNBcnJheSwgcm90YXRpb25EZWdyZWUpIHtcbiAgICAgICAgdmFyIHRyYW5zcG9zZWRBcnJheSA9IF8uemlwLmFwcGx5KF8sIGNhbGN1bGF0ZVJvdGF0aW9uc0FycmF5KTtcbiAgICAgICAgdmFyIHNpbkRlZ3JlZXNWYWx1ZSA9IChST1RBLmNhbGNTaW5EZWdyZWVzKHJvdGF0aW9uRGVncmVlKSk7XG4gICAgICAgIHZhciBjb3NEZWdyZWVzVmFsdWUgPSAoUk9UQS5jYWxjQ29zRGVncmVlcyhyb3RhdGlvbkRlZ3JlZSkpO1xuICAgICAgICB2YXIgdmFsdWVBLCB2YWx1ZUI7XG4gICAgICAgIHZhciBsZW4gPSB0cmFuc3Bvc2VkQXJyYXlbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgYTFDYWxjdWxhdGlvbnMsIGIxQ2FsY3VsYXRpb25zO1xuICAgICAgICB2YXIgYTJDYWxjdWxhdGlvbnMsIGIyQ2FsY3VsYXRpb25zO1xuICAgICAgICB2YXIgcm90YXRlZEZhY3RvcnNBcnJheSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIGExQ2FsY3VsYXRpb25zID0gdHJhbnNwb3NlZEFycmF5WzFdW2tdICogc2luRGVncmVlc1ZhbHVlO1xuICAgICAgICAgICAgYjFDYWxjdWxhdGlvbnMgPSB0cmFuc3Bvc2VkQXJyYXlbMF1ba10gKiBjb3NEZWdyZWVzVmFsdWU7XG4gICAgICAgICAgICB2YWx1ZUEgPSAoZXZlblJvdW5kKCgtKGExQ2FsY3VsYXRpb25zIC0gYjFDYWxjdWxhdGlvbnMpKSwgNSkpO1xuICAgICAgICAgICAgYTJDYWxjdWxhdGlvbnMgPSB0cmFuc3Bvc2VkQXJyYXlbMF1ba10gKiBzaW5EZWdyZWVzVmFsdWU7XG4gICAgICAgICAgICBiMkNhbGN1bGF0aW9ucyA9IHRyYW5zcG9zZWRBcnJheVsxXVtrXSAqIGNvc0RlZ3JlZXNWYWx1ZTtcbiAgICAgICAgICAgIHZhbHVlQiA9IChldmVuUm91bmQoKChhMkNhbGN1bGF0aW9ucyArIGIyQ2FsY3VsYXRpb25zKSksIDUpKTtcbiAgICAgICAgICAgIHZhciB0ZW1wQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHRlbXBBcnJheVswXSA9IHZhbHVlQTtcbiAgICAgICAgICAgIHRlbXBBcnJheVsxXSA9IHZhbHVlQjtcbiAgICAgICAgICAgIHJvdGF0ZWRGYWN0b3JzQXJyYXkucHVzaCh0ZW1wQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3RhdGVkRmFjdG9yc0FycmF5O1xuICAgIH07XG5cblxuICAgIFJPVEEuY2FsY3VsYXRlUm90YXRlZEZhY3RvcnMgPSBmdW5jdGlvbiAocm90YXRpb25EZWdyZWUpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uRmFjdG9yQSA9IFFBVi5nZXRTdGF0ZShcInJvdGF0aW9uRmFjdG9yQVwiKTtcbiAgICAgICAgdmFyIHJvdGF0aW9uRmFjdG9yQiA9IFFBVi5nZXRTdGF0ZShcInJvdGF0aW9uRmFjdG9yQlwiKTtcbiAgICAgICAgdmFyIGNvdW50ZXJDbG9ja3dpc2VSb3RhdGlvbiA9IGZhbHNlO1xuICAgICAgICB2YXIgY2FsY3VsYXRlUm90YXRpb25zQXJyYXkgPSBRQVYuZ2V0U3RhdGUoXCJjYWxjdWxhdGVSb3RhdGlvbnNBcnJheVwiKTtcbiAgICAgICAgdmFyIHRlbXBSb3RGYWNTdGF0ZUFycmF5ID0gUUFWLmdldFN0YXRlKFwidGVtcFJvdEZhY1N0YXRlQXJyYXlcIik7XG4gICAgICAgIHZhciByb3RhdGVkRmFjdG9ycztcbiAgICAgICAgdmFyIGxvb3BsZW4gPSBjYWxjdWxhdGVSb3RhdGlvbnNBcnJheS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHJvdGF0aW9uRGVncmVlIDwgMCkge1xuICAgICAgICAgICAgY291bnRlckNsb2Nrd2lzZVJvdGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvdGF0aW9uRGVncmVlID0gTWF0aC5hYnMocm90YXRpb25EZWdyZWUpO1xuXG4gICAgICAgIGlmIChjb3VudGVyQ2xvY2t3aXNlUm90YXRpb24gIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJvdGF0ZWRGYWN0b3JzID0gUk9UQS5uZXdSb3RhdGVDbG9ja3dpc2UoY2FsY3VsYXRlUm90YXRpb25zQXJyYXksIHJvdGF0aW9uRGVncmVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdGF0ZWRGYWN0b3JzID0gUk9UQS5uZXdSb3RhdGVDb3VudGVyQ2xvY2t3aXNlKGNhbGN1bGF0ZVJvdGF0aW9uc0FycmF5LCByb3RhdGlvbkRlZ3JlZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2luc2VydCByb3RhdGVkIGZhY3RvcnMgaW50byB0ZW1wIHJvdGF0aW9uYWwgc3RhdGUgYXJyYXlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb29wbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBSb3RGYWNTdGF0ZUFycmF5W2ldW3JvdGF0aW9uRmFjdG9yQSAtIDFdID0gcm90YXRlZEZhY3RvcnNbaV1bMF07XG4gICAgICAgICAgICB0ZW1wUm90RmFjU3RhdGVBcnJheVtpXVtyb3RhdGlvbkZhY3RvckIgLSAxXSA9IHJvdGF0ZWRGYWN0b3JzW2ldWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIG9iaiBmb3IgdHdvIGZhY3RvciB0YWJsZSBkaXNwbGF5XG4gICAgICAgIFJPVEEuc2V0VHdvRmFjdG9yUm90YXRpb25hbEFycmF5KHRlbXBSb3RGYWNTdGF0ZUFycmF5KTtcblxuICAgICAgICAvLyBleHBlY3RzIGJhcmUgZnVsbCBhcnJheVxuICAgICAgICB2YXIgYXJyYXlXaXRoQ29tbXVuYWxpdGllcyA9IFJPVEEuY2FsY3VsYXRlQ29tbXVuYWxpdGllcyh0ZW1wUm90RmFjU3RhdGVBcnJheSk7XG5cbiAgICAgICAgLy8gZ2V0cyBhcnJheSBmb3IgZlNpZyB0ZXN0aW5nIGZyb20gTFMgb2YgY2FsY3VsYXRlQ29tbXVuYWxpdGllcyAtIHNldHMgZlNpZ0NyaXRlcmlvblJlc3VsdHNcbiAgICAgICAgUk9UQS5jYWxjdWxhdGVmU2lnQ3JpdGVyaW9uVmFsdWVzKFwiZmxhZ1wiKTtcblxuICAgICAgICAvLyByZXR1cm5zIGRhdGFWYWx1ZXNBcnJheSBmb3IgRDMgY2hhcnRcbiAgICAgICAgdmFyIGQzUHJlcCA9IFJPVEEuZG9EM0NoYXJ0RGF0YVByZXAoYXJyYXlXaXRoQ29tbXVuYWxpdGllcyk7XG5cbiAgICAgICAgUk9UQS5kcmF3RDNDaGFydChkM1ByZXApO1xuICAgICAgICB2YXIgcHJlcFR3b0ZhY3RvclRhYmxlID0gUk9UQS5wcmVwVHdvRmFjdG9yVXBkYXRlSGFuZHNvbnRhYmxlKHRlbXBSb3RGYWNTdGF0ZUFycmF5KTtcblxuICAgICAgICAvLyByZS1kcmF3IHR3byBmYWN0b3Igcm90YXRpb24gdGFibGVcbiAgICAgICAgdmFyIGlzTmV3U2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIFJPVEEudXBkYXRlRGF0YXRhYmxlMShwcmVwVHdvRmFjdG9yVGFibGUsIGlzTmV3U2VsZWN0aW9uKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnJWMgRmFjdG9yIHJvdGF0aW9uIGNhbGNzIGNvbXBsZXRlZCBpbiAgJyArICh0aW1lMSAtIHRpbWUwKS50b0ZpeGVkKDMpICsgJyBtaWxsaXNlY29uZHMnLCAnYmFja2dyb3VuZDogYXF1YW1hcmluZTsgY29sb3I6IGJsYWNrJyk7XG5cbiAgICAgICAgUUFWLnNldFN0YXRlKFwiY2FsY3VsYXRlUm90YXRpb25zQXJyYXlcIiwgcm90YXRlZEZhY3RvcnMpO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJ0ZW1wUm90RmFjU3RhdGVBcnJheVwiLCB0ZW1wUm90RmFjU3RhdGVBcnJheSk7XG4gICAgfTtcblxuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBtb2RlbFxuICAgIC8vICoqKiogIHByZXAgdHdvIGZhY3RvciBhbmQgY3JlYXRlIGluaXRpYWwgcm90IGFycmF5ICoqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgUk9UQS5wcmVwVHdvRmFjdG9yVXBkYXRlSGFuZHNvbnRhYmxlID0gZnVuY3Rpb24gKGNoYXJ0RGF0YSkge1xuICAgICAgICB2YXIgdHdvRmFjdG9yVGFibGVBcnJheSA9IFtdO1xuICAgICAgICB2YXIgc3RlcDEsIGksIHN0ZXAzLCB0ZW1wT2JqO1xuICAgICAgICB2YXIgcm90YXRpb25GYWN0b3JBID0gUUFWLmdldFN0YXRlKFwicm90YXRpb25GYWN0b3JBXCIpO1xuICAgICAgICB2YXIgcm90YXRpb25GYWN0b3JCID0gUUFWLmdldFN0YXRlKFwicm90YXRpb25GYWN0b3JCXCIpO1xuICAgICAgICB2YXIgZlNpZ0NyaXRlcmlvblJlc3VsdHMgPSBRQVYuZ2V0U3RhdGUoXCJmU2lnQ3JpdGVyaW9uUmVzdWx0c1wiKTtcbiAgICAgICAgdmFyIHJlc3BvbmRlbnROYW1lcyA9IFFBVi5nZXRTdGF0ZShcInFhdlJlc3BvbmRlbnROYW1lc1wiKTtcbiAgICAgICAgdmFyIGlsZW4gPSBjaGFydERhdGEubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHN0ZXAxID0gY2hhcnREYXRhW2ldO1xuICAgICAgICAgICAgc3RlcDMgPSBmU2lnQ3JpdGVyaW9uUmVzdWx0c1tpXTtcbiAgICAgICAgICAgIHRlbXBPYmogPSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uZGVudDogcmVzcG9uZGVudE5hbWVzW2ldLFxuICAgICAgICAgICAgICAgIGZhY3RvcjE6IHN0ZXAxW3JvdGF0aW9uRmFjdG9yQSAtIDFdLFxuICAgICAgICAgICAgICAgIGZhY3RvcjFTaWc6IHN0ZXAzW3JvdGF0aW9uRmFjdG9yQSAtIDFdLFxuICAgICAgICAgICAgICAgIGZhY3RvcjI6IHN0ZXAxW3JvdGF0aW9uRmFjdG9yQiAtIDFdLFxuICAgICAgICAgICAgICAgIGZhY3RvcjJTaWc6IHN0ZXAzW3JvdGF0aW9uRmFjdG9yQiAtIDFdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHR3b0ZhY3RvclRhYmxlQXJyYXkucHVzaCh0ZW1wT2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHdvRmFjdG9yVGFibGVBcnJheTtcbiAgICB9O1xuXG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgbW9kZWxcbiAgICAvLyAqKioqIGluaXRpYWwgYXJyYXkgZm9yIHR3byBmYWN0b3IgdGFibGUgKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgUk9UQS5zZXRUd29GYWN0b3JSb3RhdGlvbmFsQXJyYXkgPSBmdW5jdGlvbiAoY2hhcnREYXRhKSB7XG4gICAgICAgIHZhciByb3RhdGlvbkZhY3RvckEgPSBRQVYuZ2V0U3RhdGUoXCJyb3RhdGlvbkZhY3RvckFcIik7XG4gICAgICAgIHZhciByb3RhdGlvbkZhY3RvckIgPSBRQVYuZ2V0U3RhdGUoXCJyb3RhdGlvbkZhY3RvckJcIik7XG4gICAgICAgIHZhciBpbGVuID0gY2hhcnREYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGNhbGN1bGF0ZVJvdGF0aW9uc0FycmF5ID0gW107XG4gICAgICAgIHZhciB0ZW1wQXJyYXk7XG4gICAgICAgIHZhciB0ZW1wMTtcbiAgICAgICAgdmFyIHRlbXAyO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHRlbXAxID0gY2hhcnREYXRhW2ldW3JvdGF0aW9uRmFjdG9yQSAtIDFdO1xuICAgICAgICAgICAgdGVtcDIgPSBjaGFydERhdGFbaV1bcm90YXRpb25GYWN0b3JCIC0gMV07XG4gICAgICAgICAgICB0ZW1wQXJyYXkucHVzaCh0ZW1wMSwgdGVtcDIpO1xuICAgICAgICAgICAgY2FsY3VsYXRlUm90YXRpb25zQXJyYXkucHVzaCh0ZW1wQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcImNhbGN1bGF0ZVJvdGF0aW9uc0FycmF5XCIsIGNhbGN1bGF0ZVJvdGF0aW9uc0FycmF5KTtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZVJvdGF0aW9uc0FycmF5O1xuICAgIH07XG5cblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiB2aWV3XG4gICAgLy8gKioqKioqICBkcmF3IHR3byBmYWN0b3JzIHRhYmxlICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIFJPVEEudXBkYXRlRGF0YXRhYmxlMSA9IGZ1bmN0aW9uIChuZXdEYXRhLCBpc05ld1NlbGVjdGlvbikge1xuXG4gICAgICAgIC8vIHRvZG8gLSBmaXggZXJyb3Igb24gYmFzZWxpbmVkYXRhIHNldHRpbmcgYWZ0ZXIgZGlzcGxheWluZyBmYWN0b3JzIG9uY2VcbiAgICAgICAgdmFyIGksIGJhc2VMaW5lRGF0YSwgdGVtcEFycmF5MSwgdGVtcDEsIHRlbXAxYSwgdGVtcDIsIHRlbXAyYiwgdGVtcDJhO1xuICAgICAgICB2YXIgbmV3MkZhY3RvckRhdGFBcnJheSA9IFtdO1xuICAgICAgICB2YXIgdGVtcDQsIHRlbXA2YSwgdGVtcDZiLCB0YWJsZTtcbiAgICAgICAgdmFyIHRlbXA3LCB0ZW1wOCwgdGVzdFZhcjtcblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgZGF0YXRhYmVsIGFscmVhZHkgZXhpc3RzIC0gcmV0dXJucyBib29sZWFuXG4gICAgICAgIHRlc3RWYXIgPSAkLmZuLmRhdGFUYWJsZS5pc0RhdGFUYWJsZSgnI3R3b0ZhY3RvckRpc3BsYXlUYWJsZScpO1xuICAgICAgICB2YXIgZmFjQSA9IFFBVi5nZXRTdGF0ZShcInJvdGF0aW9uRmFjdG9yQVwiKTtcbiAgICAgICAgdmFyIGZhY0IgPSBRQVYuZ2V0U3RhdGUoXCJyb3RhdGlvbkZhY3RvckJcIik7XG4gICAgICAgIHZhciBmYWNBTmFtZSA9IFwiRmFjLiBcIiArIGZhY0E7XG4gICAgICAgIHZhciBmYWNBQ2hhbmdlID0gXCJDaGcuIFwiICsgZmFjQTtcbiAgICAgICAgdmFyIGZhY0JOYW1lID0gXCJGYWMuIFwiICsgZmFjQjtcbiAgICAgICAgdmFyIGZhY0JDaGFuZ2UgPSBcIkNoZy4gXCIgKyBmYWNCO1xuICAgICAgICB2YXIgbmV3SGVhZGVyQXJyYXkgPSBbXCJSZXMuXCIsIFwiTmFtZVwiLCBmYWNBTmFtZSwgZmFjQUNoYW5nZSwgZmFjQk5hbWUsIGZhY0JDaGFuZ2VdO1xuICAgICAgICB2YXIgcm90Q2hhcnRDb25maWcgPSBRQVYuZ2V0U3RhdGUoXCJyb3RDaGFydENvbmZpZ1wiKTtcbiAgICAgICAgdmFyIHNpZ25pZmljYW5jZUNvbG9yQSA9IHJvdENoYXJ0Q29uZmlnLnNpZ25pZmljYW5jZUNvbG9yQTtcbiAgICAgICAgdmFyIHNpZ25pZmljYW5jZUNvbG9yQiA9IHJvdENoYXJ0Q29uZmlnLnNpZ25pZmljYW5jZUNvbG9yQjtcblxuICAgICAgICBpZiAocm90Q2hhcnRDb25maWcucmVtb3ZlQ2lyY2xlSGlnaGxpZ2h0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuY2VDb2xvckEgPSBcInJnYmEoMzMsIDMzLCAzMywgMC4wKVwiO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmNlQ29sb3JCID0gXCJyZ2JhKDMzLCAzMywgMzMsIDAuMClcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXN0VmFyID09PSB0cnVlKSB7IC8vXG5cbiAgICAgICAgICAgIGJhc2VMaW5lRGF0YSA9IFFBVi5nZXRTdGF0ZShcImJhc2VMaW5lRGF0YVwiKTtcblxuICAgICAgICAgICAgbmV3MkZhY3RvckRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxID0gW107XG4gICAgICAgICAgICAgICAgdGVtcDFhID0gaSArIDE7XG4gICAgICAgICAgICAgICAgLy8gYWRkcyByZXNwLiBudW1iZXJcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxLnB1c2godGVtcDFhKTtcbiAgICAgICAgICAgICAgICB0ZW1wMSA9IG5ld0RhdGFbaV0ucmVzcG9uZGVudDtcbiAgICAgICAgICAgICAgICAvLyBhZGRzIHJlc3BvbmRlbnQgbmFtZVxuICAgICAgICAgICAgICAgIHRlbXBBcnJheTEucHVzaCh0ZW1wMSk7XG5cbiAgICAgICAgICAgICAgICB0ZW1wMiA9IG5ld0RhdGFbaV0uZmFjdG9yMTtcbiAgICAgICAgICAgICAgICAvLyBhZGRzIGZhY3RvciAxIGNhbGNlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIHRlbXBBcnJheTEucHVzaCh0ZW1wMik7XG4gICAgICAgICAgICAgICAgdGVtcDJiID0gYmFzZUxpbmVEYXRhW2ldLmZhY3RvcjE7XG4gICAgICAgICAgICAgICAgdGVtcDJhID0gZXZlblJvdW5kKCh0ZW1wMiAtIHRlbXAyYiksIDUpO1xuICAgICAgICAgICAgICAgIC8vIGFkZHMgZGlmZlxuICAgICAgICAgICAgICAgIHRlbXBBcnJheTEucHVzaCh0ZW1wMmEpO1xuXG4gICAgICAgICAgICAgICAgdGVtcDQgPSBuZXdEYXRhW2ldLmZhY3RvcjI7XG4gICAgICAgICAgICAgICAgLy8gYWRkcyBmYWN0b3IgMiBjYWxjZWQgdmFsdWVcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxLnB1c2godGVtcDQpO1xuICAgICAgICAgICAgICAgIHRlbXA2YiA9IGJhc2VMaW5lRGF0YVtpXS5mYWN0b3IyO1xuICAgICAgICAgICAgICAgIHRlbXA2YSA9IGV2ZW5Sb3VuZCgodGVtcDQgLSB0ZW1wNmIpLCA1KTtcbiAgICAgICAgICAgICAgICAvLyBhZGRzIGRpZmZcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxLnB1c2godGVtcDZhKTtcblxuICAgICAgICAgICAgICAgIHRlbXA3ID0gbmV3RGF0YVtpXS5mYWN0b3IxU2lnO1xuICAgICAgICAgICAgICAgIHRlbXA4ID0gbmV3RGF0YVtpXS5mYWN0b3IyU2lnO1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheTEucHVzaCh0ZW1wNywgdGVtcDgpO1xuICAgICAgICAgICAgICAgIG5ldzJGYWN0b3JEYXRhQXJyYXkucHVzaCh0ZW1wQXJyYXkxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFibGUgPSAkKCcjdHdvRmFjdG9yRGlzcGxheVRhYmxlJykuRGF0YVRhYmxlKCk7XG4gICAgICAgICAgICB0YWJsZS5jbGVhcigpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdIZWFkZXJBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRhYmxlLmNvbHVtbnMoaikuaGVhZGVyKCkudG8kKCkudGV4dChuZXdIZWFkZXJBcnJheVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5yb3dzLmFkZChuZXcyRmFjdG9yRGF0YUFycmF5KS5kcmF3KCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgYmFzZUxpbmVEYXRhID0gUUFWLmdldFN0YXRlKFwiYmFzZUxpbmVEYXRhXCIpO1xuXG4gICAgICAgICAgICBpZiAoYmFzZUxpbmVEYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYmFzZUxpbmVEYXRhID0gWzEsIFwiXCIsIDAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3RGF0YS5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdGVtcEFycmF5MSA9IFtdO1xuICAgICAgICAgICAgICAgIHRlbXAxYSA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheTEucHVzaCh0ZW1wMWEpO1xuICAgICAgICAgICAgICAgIHRlbXAxID0gbmV3RGF0YVtpXS5yZXNwb25kZW50O1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheTEucHVzaCh0ZW1wMSk7XG5cbiAgICAgICAgICAgICAgICB0ZW1wMiA9IG5ld0RhdGFbaV0uZmFjdG9yMTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxLnB1c2godGVtcDIpO1xuICAgICAgICAgICAgICAgIHRlbXAyYiA9IGJhc2VMaW5lRGF0YVtpXS5mYWN0b3IxO1xuICAgICAgICAgICAgICAgIHRlbXAyYSA9IGV2ZW5Sb3VuZCgodGVtcDIgLSB0ZW1wMmIpLCA1KTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxLnB1c2godGVtcDJhKTtcblxuICAgICAgICAgICAgICAgIHRlbXA0ID0gbmV3RGF0YVtpXS5mYWN0b3IyO1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheTEucHVzaCh0ZW1wNCk7XG4gICAgICAgICAgICAgICAgdGVtcDZiID0gYmFzZUxpbmVEYXRhW2ldLmZhY3RvcjI7XG4gICAgICAgICAgICAgICAgdGVtcDZhID0gZXZlblJvdW5kKCh0ZW1wNCAtIHRlbXA2YiksIDUpO1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheTEucHVzaCh0ZW1wNmEpO1xuXG4gICAgICAgICAgICAgICAgdGVtcDcgPSBuZXdEYXRhW2ldLmZhY3RvcjFTaWc7XG4gICAgICAgICAgICAgICAgdGVtcDggPSBuZXdEYXRhW2ldLmZhY3RvcjJTaWc7XG4gICAgICAgICAgICAgICAgdGVtcEFycmF5MS5wdXNoKHRlbXA3LCB0ZW1wOCk7XG5cbiAgICAgICAgICAgICAgICBuZXcyRmFjdG9yRGF0YUFycmF5LnB1c2godGVtcEFycmF5MSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhciBzaWduaWZpY2FuY2VMZXZlbCA9IFJPVEEuY2FsY3VsYXRlRmFjdG9yTG9hZGluZ1NpZ25pZmljYW5jZUxldmVsKCk7XG5cbiAgICAgICAgICAgIHRhYmxlID0gJCgnI3R3b0ZhY3RvckRpc3BsYXlUYWJsZScpLkRhdGFUYWJsZSh7XG4gICAgICAgICAgICAgICAgLy8gXCJkb21cIjogJzxcInRvcFwiaT5ydDxcImJvdHRvbVwiZmxwPjxcImNsZWFyXCI+JyxcbiAgICAgICAgICAgICAgICBcInJldHJpZXZlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJzZWFyY2hpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJvcmRlcmluZ1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiaW5mb1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcInNjcm9sbFlcIjogNjAwLFxuICAgICAgICAgICAgICAgIFwic2Nyb2xsQ29sbGFwc2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInNjcm9sbFhcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInBhZ2luZ1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAvL1wiYXV0b1dpZHRoXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFt7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHM6IFsyLCAzLCA0LCA1XSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZHQtYm9keS1yaWdodCcsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzOiBbMCwgMV0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2R0LWJvZHktY2VudGVyJ1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogWzBdLFxuICAgICAgICAgICAgICAgICAgICBvcmRlckRhdGE6IFswLCAxXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogWzJdLFxuICAgICAgICAgICAgICAgICAgICBvcmRlckRhdGE6IFsyXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogWzNdLFxuICAgICAgICAgICAgICAgICAgICBvcmRlckRhdGE6IFszXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogWzRdLFxuICAgICAgICAgICAgICAgICAgICBvcmRlckRhdGE6IFs0XVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogWzVdLFxuICAgICAgICAgICAgICAgICAgICBvcmRlckRhdGE6IFs1XVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogWzZdLFxuICAgICAgICAgICAgICAgICAgICBcInZpc2libGVcIjogZmFsc2VcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHM6IFs3XSxcbiAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmxlXCI6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAndGFyZ2V0cyc6IFsyXSxcbiAgICAgICAgICAgICAgICAgICAgXCJjcmVhdGVkQ2VsbFwiOiBmdW5jdGlvbiAodGQsIGNlbGxEYXRhLCByb3dEYXRhKSB7IC8vIHJvdyBjb2xcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0RhdGFbNl0gPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0ZCkuY3NzKCdiYWNrZ3JvdW5kJywgc2lnbmlmaWNhbmNlQ29sb3JBKTsgLy8nI2ZmZTRiMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAndGFyZ2V0cyc6IFs0XSxcbiAgICAgICAgICAgICAgICAgICAgXCJjcmVhdGVkQ2VsbFwiOiBmdW5jdGlvbiAodGQsIGNlbGxEYXRhLCByb3dEYXRhKSB7IC8vIHJvdyBjb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dEYXRhWzddID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGQpLmNzcygnYmFja2dyb3VuZCcsIHNpZ25pZmljYW5jZUNvbG9yQik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XSxcblxuICAgICAgICAgICAgICAgIGRhdGE6IG5ldzJGYWN0b3JEYXRhQXJyYXksXG4gICAgICAgICAgICAgICAgXCJjb2x1bW5zXCI6IFt7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlJlcy5cIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1jZW50ZXInXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJOYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2R0LWhlYWQtY2VudGVyIGR0LWJvZHktY2VudGVyJ1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGZhY0FOYW1lLCAvL1wiRmFjLiBBXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2R0LWhlYWQtY2VudGVyIGR0LWJvZHktcmlnaHQnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogZmFjQUNoYW5nZSwgLy8gXCJDaGcgQVwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdkdC1oZWFkLWNlbnRlciBkdC1ib2R5LXJpZ2h0J1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGZhY0JOYW1lLCAvLyBcIkZhYy4gQlwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdkdC1oZWFkLWNlbnRlciBkdC1ib2R5LXJpZ2h0J1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGZhY0JDaGFuZ2UsIC8vIFwiQ2hnIEJcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1yaWdodCdcbiAgICAgICAgICAgICAgICB9LCBdLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRhYmxlLmZpeGVkSGVhZGVyLmFkanVzdCgpO1xuICAgICAgICAgICAgLy8gVE9ETyAtICBGT1IgQ09MVU1OIEhJR0hMSUdIVElORyAtIEZJTkQgRVJST1IgQU5EIFJFU1RPUkVcbiAgICAgICAgICAgIC8vICAgICAgICB2YXIgbGFzdElkeCA9IG51bGw7XG4gICAgICAgICAgICAvLyAgICAgICAgJCgnI3R3b0ZhY3RvckRpc3BsYXlUYWJsZSB0Ym9keScpXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgJ3RkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgdmFyIGNvbElkeCA9IHRhYmxlLmNlbGwodGhpcykuaW5kZXgoKS5jb2x1bW47XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBpZiAoY29sSWR4ICE9PSBsYXN0SWR4KSB7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgJCh0YWJsZS5jZWxscygpLm5vZGVzKCkpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAkKHRhYmxlLmNvbHVtbihjb2xJZHgpLm5vZGVzKCkpLmFkZENsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgJCh0YWJsZS5jZWxscygpLm5vZGVzKCkpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogbW9kZWxcbiAgICAvLyAqKioqKioqKioqICBzYXZlIEQzIHJvdGF0ZWQgZmFjdG9ycyB0byBzdGF0ZSBtYXRyaXggYXJyYXkgICoqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIFJPVEEuc2F2ZVJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm90YXRpb25EZWdyZWUgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwicm90YXRpb25EZWdyZWVEaXNwbGF5VmFsdWVcIik7XG4gICAgICAgIHZhciByb3RhdGlvbkZhY3RvckEgPSBRQVYuZ2V0U3RhdGUoXCJyb3RhdGlvbkZhY3RvckFcIik7XG4gICAgICAgIHZhciByb3RhdGlvbkZhY3RvckIgPSBRQVYuZ2V0U3RhdGUoXCJyb3RhdGlvbkZhY3RvckJcIik7XG4gICAgICAgIHZhciBsaXN0VGV4dDtcbiAgICAgICAgdmFyIHJvdEZhY1N0YXRlQXJyYXk7XG4gICAgICAgIHZhciB0ZW1wUm90RmFjU3RhdGVBcnJheTtcblxuXG4gICAgICAgIC8vIGFyY2hpdmUgZmFjdG9yIHJvdGF0aW9uIHRhYmxlXG4gICAgICAgIFVUSUwuYXJjaGl2ZUZhY3RvclNjb3JlU3RhdGVNYXRyaXhBbmREYXRhdGFibGUoKTtcblxuICAgICAgICAvLyB1cGRhdGUgcHJvamVjdCBoaXN0b3J5XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uRmFjdG9ycztcbiAgICAgICAgdmFyIGFwcGVuZFRleHQyID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5hbmQ7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MyA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24ucm90YXRlZDtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQ0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcInJvdGF0ZWQgZGVncmVlc1wiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQ1ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5VbmRvO1xuXG4gICAgICAgIGxpc3RUZXh0ID0gYXBwZW5kVGV4dCArIHJvdGF0aW9uRmFjdG9yQSArIGFwcGVuZFRleHQyICsgcm90YXRpb25GYWN0b3JCICsgYXBwZW5kVGV4dDMgKyByb3RhdGlvbkRlZ3JlZSArIGFwcGVuZFRleHQ0O1xuICAgICAgICAkKFwiI3JvdGF0aW9uSGlzdG9yeUxpc3RcIikuYXBwZW5kKCc8bGk+JyArIGxpc3RUZXh0ICsgJzxidXR0b24gY2xhc3M9XCJkZWxldGVCdXR0b25cIj4nICsgYXBwZW5kVGV4dDUgKyAnPC9idXR0b24+PC9saT4nKTtcblxuICAgICAgICByb3RGYWNTdGF0ZUFycmF5ID0gUUFWLmdldFN0YXRlKFwicm90RmFjU3RhdGVBcnJheVwiKTtcbiAgICAgICAgdGVtcFJvdEZhY1N0YXRlQXJyYXkgPSBRQVYuZ2V0U3RhdGUoXCJ0ZW1wUm90RmFjU3RhdGVBcnJheVwiKTtcblxuICAgICAgICAvLyBzYXZlIHRlbXAgYXJyYXkgYXMgbmV3IGN1cnJlbnQgc3RhdGUgYXJyYXlcbiAgICAgICAgUUFWLnNldFN0YXRlKFwicm90RmFjU3RhdGVBcnJheVwiLCB0ZW1wUm90RmFjU3RhdGVBcnJheSk7XG5cbiAgICAgICAgLy8gcmUtZHJhdyBmYWN0b3IgdGFibGVcbiAgICAgICAgdmFyIGlzUm90YXRlZEZhY3RvcnNUYWJsZVVwZGF0ZSA9IFwiZGVzdHJveVwiO1xuICAgICAgICBMT0FELmRyYXdSb3RhdGVkRmFjdG9yc1RhYmxlMihpc1JvdGF0ZWRGYWN0b3JzVGFibGVVcGRhdGUsIFwibm9GbGFnXCIpO1xuXG4gICAgICAgIC8vIGNsZWFyIG91dCB0aGUgMiBmYWN0b3Igcm90YXRpb24gY2hhcnQgYW5kIHBsb3RcbiAgICAgICAgUk9UQS5yZUluaXRpYWxpemVQbG90QW5kQ2hhcnQoKTtcblxuICAgICAgICAvLyByZXNldCBkZWdyZWUgZGlzcGxheSwgYnV0dG9uIGNvbG9yIGFuZCBzdG9yZWQgdmFsdWVcbiAgICAgICAgJChcIiNoYW5kUm90YXRpb25EaXNwbGF5Q29udGFpbmVyIGRpdlwiKS5odG1sKFwiMCZkZWdcIik7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJyb3RhdGlvbkRlZ3JlZURpc3BsYXlWYWx1ZVwiLCAwKTtcbiAgICAgICAgUk9UQS5zYXZlUm90YXRpb25CdXR0b25Db2xvcigwKTtcblxuICAgICAgICAvLyBmb3JjZSByZS1jYWxjIG9mIHJlc3VsdHMgaWYgbW9yZSByb3RhdGlvbnMgbWFkZSBhbmQgdGhlbiBkb3dubG9hZCAvIGRpc3BsYXkgYnV0dG9ucyBjYWxsZWRcbiAgICAgICAgUUFWLnNldFN0YXRlKFwib3V0cHV0Q29tcGxldGVcIiwgXCJmYWxzZVwiKTtcbiAgICB9O1xuXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogICBtb2RlbFxuICAgIC8vKioqKioqKiBmb3Igcm90YXRlZCBmYWN0b3JzIHRhYmxlIGRhdGEgIGhhbmRzb250YWJsZSB2ZXJzaW9uICoqKioqKioqKioqKipcbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gUk9UQS5jYWxjdWxhdGVFaWdlbnZhbHVlc0FuZFZhcmlhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vICAgICB2YXIgbnVtYmVyU29ydHMgPSBRQVYuZ2V0U3RhdGUoXCJxYXZUb3RhbE51bWJlclNvcnRzXCIpO1xuICAgIC8vICAgICB2YXIgZmFjdG9yTWF0cml4MiA9IFFBVi5nZXRTdGF0ZShcInJvdEZhY1N0YXRlQXJyYXlcIik7XG4gICAgLy8gICAgIC8vdmFyIGZhY3Rvck1hdHJpeDIgPSBfLmNsb25lRGVlcChmYWN0b3JNYXRyaXgpO1xuICAgIC8vICAgICB2YXIgZmFjdG9yTWF0cml4MSA9IF8uemlwLmFwcGx5KF8sIGZhY3Rvck1hdHJpeDIpO1xuICAgIC8vICAgICB2YXIgaiwgbnVtLCBlaWdlbiwgdG90YWxWYXJpYW5jZTtcbiAgICAvLyAgICAgdmFyIGVpZ2VudmFsdWVzID0ge307XG4gICAgLy8gICAgIHZhciBleHBsYWluZWRWYXJpYW5jZSA9IHt9O1xuICAgIC8vICAgICB2YXIgbG9vcExlbjEgPSBmYWN0b3JNYXRyaXgxLmxlbmd0aDtcbiAgICAvLyAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAvLyAgICAgdmFyIGZhY3Rvck51bWJlciwgZmFjdG9yU2lnO1xuXG4gICAgLy8gICAgIGVpZ2VudmFsdWVzID0ge1xuICAgIC8vICAgICAgICAgcmVzcG9uZGVudDogXCJFaWdlbnZhbHVlc1wiXG4gICAgLy8gICAgIH07XG4gICAgLy8gICAgIGV4cGxhaW5lZFZhcmlhbmNlID0ge1xuICAgIC8vICAgICAgICAgcmVzcG9uZGVudDogXCIlIEV4cGxuIFZhclwiXG4gICAgLy8gICAgIH07XG5cbiAgICAvLyAgICAgZm9yIChqID0gMDsgaiA8IGxvb3BMZW4xOyBqKyspIHtcbiAgICAvLyAgICAgICAgIG51bSA9IGZhY3Rvck1hdHJpeDFbal07XG4gICAgLy8gICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG51bS5sZW5ndGg7IGsrKykge1xuICAgIC8vICAgICAgICAgICAgIG51bVtrXSA9IGV2ZW5Sb3VuZCgobnVtW2tdICogbnVtW2tdKSwgOCk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgICAgICBlaWdlbiA9IGV2ZW5Sb3VuZCgoXy5yZWR1Y2UobnVtLCBmdW5jdGlvbiAoc3VtLCBudW0yKSB7XG4gICAgLy8gICAgICAgICAgICAgcmV0dXJuIHN1bSArIG51bTI7XG4gICAgLy8gICAgICAgICB9KSksIDUpO1xuXG4gICAgLy8gICAgICAgICBmYWN0b3JOdW1iZXIgPSBcImZhY3RvclwiICsgKGogKyAxKTtcblxuICAgIC8vICAgICAgICAgZmFjdG9yU2lnID0gXCJmYWN0b3JTaWdcIiArIChqICsgMSk7XG4gICAgLy8gICAgICAgICB0b3RhbFZhcmlhbmNlID0gZXZlblJvdW5kKCgxMDAgKiAoZWlnZW4gLyBudW1iZXJTb3J0cykpLCAwKTtcblxuICAgIC8vICAgICAgICAgZWlnZW52YWx1ZXNbZmFjdG9yTnVtYmVyXSA9IGVpZ2VuO1xuICAgIC8vICAgICAgICAgZXhwbGFpbmVkVmFyaWFuY2VbZmFjdG9yTnVtYmVyXSA9IHRvdGFsVmFyaWFuY2U7XG5cbiAgICAvLyAgICAgICAgIGVpZ2VudmFsdWVzW2ZhY3RvclNpZ10gPSBcIlwiO1xuICAgIC8vICAgICAgICAgZXhwbGFpbmVkVmFyaWFuY2VbZmFjdG9yU2lnXSA9IFwiXCI7XG5cbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBlaWdlbnZhbHVlcy5jb21tdW5hbGl0eSA9IFwiXCI7XG4gICAgLy8gICAgIGV4cGxhaW5lZFZhcmlhbmNlLmNvbW11bmFsaXR5ID0gXCJcIjtcbiAgICAvLyAgICAgcmVzdWx0cy5wdXNoKGVpZ2VudmFsdWVzKTtcbiAgICAvLyAgICAgUUFWLnNldFN0YXRlKFwiZXhwVmFyXCIsIGV4cGxhaW5lZFZhcmlhbmNlKTtcbiAgICAvLyAgICAgamxvZyhcInJlc3VsdHNcIiwgcmVzdWx0cyk7XG4gICAgLy8gICAgIHJldHVybiByZXN1bHRzO1xuICAgIC8vIH07XG5cbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgIG1vZGVsXG4gICAgLy8qKioqIGZvciByb3RhdGVkIGZhY3RvcnMgdGFibGUgZGF0YSAtIGRhdGF0YWJsZXMgdmVyc2lvbiAqKioqKioqKioqKioqKlxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBST1RBLmNhbGN1bGF0ZUVpZ2VudmFsdWVzQW5kVmFyaWFuY2UyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbnVtYmVyU29ydHMgPSBRQVYuZ2V0U3RhdGUoXCJxYXZUb3RhbE51bWJlclNvcnRzXCIpO1xuICAgICAgICB2YXIgZmFjdG9yTWF0cml4MiA9IFFBVi5nZXRTdGF0ZShcInJvdEZhY1N0YXRlQXJyYXlcIik7XG4gICAgICAgIC8vIHZhciBmYWN0b3JNYXRyaXgyID0gXy5jbG9uZURlZXAoZmFjdG9yTWF0cml4KTtcbiAgICAgICAgdmFyIGZhY3Rvck1hdHJpeDEgPSBfLnppcC5hcHBseShfLCBmYWN0b3JNYXRyaXgyKTtcbiAgICAgICAgdmFyIGosIG51bSwgZWlnZW4sIHRvdGFsVmFyaWFuY2U7XG4gICAgICAgIHZhciBlaWdlbnZhbHVlcyA9IHt9O1xuICAgICAgICB2YXIgZXhwbGFpbmVkVmFyaWFuY2UgPSB7fTtcbiAgICAgICAgdmFyIGxvb3BMZW4xID0gZmFjdG9yTWF0cml4MS5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHZhciBmYWN0b3JOdW1iZXIsIGZhY3RvclNpZztcblxuICAgICAgICBlaWdlbnZhbHVlcyA9IFtcIkVpZ2VudmFsdWVzXCJdO1xuICAgICAgICBleHBsYWluZWRWYXJpYW5jZSA9IFtcIiUgRXhwbG4gVmFyXCJdO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsb29wTGVuMTsgaisrKSB7XG4gICAgICAgICAgICBudW0gPSBmYWN0b3JNYXRyaXgxW2pdO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBudW0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBudW1ba10gPSBldmVuUm91bmQoKG51bVtrXSAqIG51bVtrXSksIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWlnZW4gPSBldmVuUm91bmQoKF8ucmVkdWNlKG51bSwgZnVuY3Rpb24gKHN1bSwgbnVtMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdW0gKyBudW0yO1xuICAgICAgICAgICAgfSkpLCA1KTtcblxuICAgICAgICAgICAgZmFjdG9yTnVtYmVyID0gXCJmYWN0b3JcIiArIChqICsgMSk7XG5cbiAgICAgICAgICAgIGZhY3RvclNpZyA9IFwiZmFjdG9yU2lnXCIgKyAoaiArIDEpO1xuICAgICAgICAgICAgdG90YWxWYXJpYW5jZSA9IGV2ZW5Sb3VuZCgoMTAwICogKGVpZ2VuIC8gbnVtYmVyU29ydHMpKSwgMCk7XG5cbiAgICAgICAgICAgIGVpZ2VudmFsdWVzLnB1c2goZWlnZW4pO1xuICAgICAgICAgICAgZXhwbGFpbmVkVmFyaWFuY2UucHVzaCh0b3RhbFZhcmlhbmNlKTtcblxuICAgICAgICAgICAgZWlnZW52YWx1ZXMucHVzaChcIlwiKTtcbiAgICAgICAgICAgIGV4cGxhaW5lZFZhcmlhbmNlLnB1c2goXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWlnZW52YWx1ZXMucHVzaChcIlwiKTtcbiAgICAgICAgZXhwbGFpbmVkVmFyaWFuY2UucHVzaChcIlwiKTtcblxuICAgICAgICByZXN1bHRzLnB1c2goZWlnZW52YWx1ZXMpO1xuICAgICAgICBleHBsYWluZWRWYXJpYW5jZS5zcGxpY2UoMSwgMCwgXCJcIiwgXCJcIik7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcImV4cFZhclwiLCBleHBsYWluZWRWYXJpYW5jZSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbn0od2luZG93LlJPVEEgPSB3aW5kb3cuUk9UQSB8fCB7fSwgUUFWKSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvUk9UQS5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSA1Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9')}});