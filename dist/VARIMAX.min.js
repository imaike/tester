!function(I){function g(C){if(A[C])return A[C].exports;var n=A[C]={i:C,l:!1,exports:{}};return I[C].call(n.exports,n,n.exports,g),n.l=!0,n.exports}var A={};g.m=I,g.c=A,g.i=function(I){return I},g.d=function(I,A,C){g.o(I,A)||Object.defineProperty(I,A,{configurable:!1,enumerable:!0,get:C})},g.n=function(I){var A=I&&I.__esModule?function(){return I.default}:function(){return I};return g.d(A,"a",A),A},g.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},g.p="",g(g.s=15)}({15:function(module,exports){eval('//Ken-Q Analysis\n//Copyright (C) 2016 Shawn Banasick\n//\n//    This program is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, either version 3 of the License, or\n//    (at your option) any later version.\n\n// JSlint declarations\n/* global numeric, VARIMAX, window, performance, ROTA, QAV, $, resources, document, JQuery, evenRound, UTIL, localStorage, _ */\n\n(function (VARIMAX, QAV, undefined) {\n    \'use strict\';\n\n    VARIMAX.fireVarimaxRotation = function () {\n\n        var getFactorsForRotation = QAV.getState("centroidFactors");\n\n        // archive factor rotation table\n        UTIL.archiveFactorScoreStateMatrixAndDatatable();\n\n        // run rotation\n        var varimaxResults = VARIMAX.doVarimax(getFactorsForRotation);\n\n        // copy the new rotations\n        // var rotFacStateArrayPrep1 = _.cloneDeep(varimaxResults);\n\n        // send to rotFactorStateArray\n        QAV.setState("rotFacStateArray", varimaxResults);\n\n        // prep for chart\n        ROTA.calculateCommunalities(varimaxResults);\n\n        // gets array for fSig testing from LS of calculateCommunalities - sets fSigCriterionResults\n        ROTA.calculatefSigCriterionValues("noFlag");\n\n        // re-draw rotation table\n        var isRotatedFactorsTableUpdate = "destroy";\n        LOAD.drawRotatedFactorsTable2(isRotatedFactorsTableUpdate, "noFlag");\n    };\n\n\n    VARIMAX.doVarimax = function (factorMatrix) {\n        var t0 = performance.now();\n\n        var sumSquares = VARIMAX.calcSumSquares(factorMatrix);\n        var standarizedFactorMatrix = VARIMAX.calcStandardizedFactorMatrix(sumSquares, factorMatrix);\n        var rotatedResults = calculateVarianceForFactorMatrix(standarizedFactorMatrix, sumSquares);\n\n        var language = QAV.getState("language");\n        var appendText = resources[language].translation["Varimax rotation applied"];\n        var appendText2 = resources[language].translation.Undo;\n        // the "varimax called" class is for toggling color of varimax button\n        $("#rotationHistoryList").append(\'<li>\' + appendText + \'<button class="deleteButton  varimaxCalled">\' + appendText2 + \'</button></li>\');\n\n        var t1 = performance.now();\n\n        console.log(\'%c Varimax rotations completed in \' + (t1 - t0).toFixed(0) + \' milliseconds\', \'background: #0c7fd7; color: white\');\n        return rotatedResults;\n    };\n\n    VARIMAX.calcStandardizedFactorMatrix = function (sumSquares, factorMatrix) {\n        // (3722-3727)\n        var standarizedFactorMatrix = [];\n        var arrayFrag1;\n        var temp5;\n        var len2;\n        var temp4;\n        var sqrtSumSquares;\n        var m, k;\n        var loopLen1 = factorMatrix.length;\n\n        for (m = 0; m < loopLen1; m++) {\n            arrayFrag1 = factorMatrix[m];\n            temp5 = [];\n            len2 = factorMatrix[m].length;\n\n            for (k = 0; k < len2; k++) {\n                sqrtSumSquares = evenRound(Math.sqrt(sumSquares[k]), 8);\n                if (sqrtSumSquares !== 0) {\n                    temp4 = evenRound((arrayFrag1[k] / sqrtSumSquares), 8);\n                } else {\n                    temp4 = 0.0;\n                }\n                temp5.push(temp4);\n            }\n            standarizedFactorMatrix.push(temp5);\n        }\n        return standarizedFactorMatrix;\n    };\n\n    VARIMAX.calcSumSquares = function (factorMatrix) {\n        // (3709 - 3714)\n        var temp1, temp3, temp;\n        var sumSquares = [];\n        var loopLen = factorMatrix.length;\n        for (var i = 0, iLen = factorMatrix[0].length; i < iLen; i++) {\n            temp1 = 0;\n            temp3 = 0;\n            for (var j = 0; j < loopLen; j++) {\n                temp = evenRound((factorMatrix[j][i] * factorMatrix[j][i]), 8);\n                temp1 = temp1 + temp;\n            }\n            temp3 = evenRound((temp1), 8);\n            sumSquares.push(temp3);\n        }\n        return sumSquares;\n    };\n\n    // ********************************************************  controller\n    // ***** varimax iteration loop controller ****************************\n    // ***** calclate variance for factor matrix **************************\n    // ********************************************************************\n\n    function calculateVarianceForFactorMatrix(factorMatrix, sumSquares) {\n        // also calls and loops factor adjustment function varimaxIteration\n        var NV; // = 1;  outer big loop counter\n        // var TVNV      // total variance of current loop\n        var TVLT; //  total variance of previous loop used for kickout test\n        var NC;\n        var TV = 0; // total variance\n        var aaArray, bbArray, tvArray;\n        var FN = factorMatrix[0].length;\n        var FFN = FN * FN;\n        var testCondition;\n        var AA, BB, FNBB, AASQ;\n\n        do {\n            if (NV) {\n                factorMatrix = intermediateRotation;\n            }\n\n            tvArray = [];\n            var temp1, temp3, arrayFrag, temp;\n            var i, j;\n            var iLoopLen = factorMatrix.length;\n\n            TVLT = TV;\n\n            // gets sumSquares of new varimaxIteration matrix to check convergence\n            for (i = 0; i < iLoopLen; i++) { // for each factor\n                AA = 0;\n                BB = 0;\n                temp1 = 0;\n                temp3 = 0;\n                arrayFrag = factorMatrix[i];\n                var jLoopLen = arrayFrag.length;\n\n                aaArray = [];\n                bbArray = [];\n                for (j = 0; j < jLoopLen; j++) { // for each sort\n                    temp = evenRound((arrayFrag[j] * arrayFrag[j]), 8); // CC\n                    aaArray.push(evenRound((temp), 8)); // AA\n                    var tempBB = evenRound((temp * temp), 8);\n                    bbArray.push(evenRound((tempBB), 8));\n                }\n                AA = evenRound((VARIMAX.sumArray(aaArray)), 8);\n                BB = evenRound((VARIMAX.sumArray(bbArray)), 8);\n                // FN is number factors, AA is total of sumSquares, BB is square of total of sumSquares, FFN is number factors squared\n                // (3745) \n                FNBB = evenRound((FN * BB), 8);\n                AASQ = evenRound((AA * AA), 8);\n                //TV = evenRound(((FN * BB - AA * AA) / FFN), 8);\n                TV = evenRound(((FNBB - AASQ) / FFN), 8);\n                tvArray.push(TV);\n            }\n\n            TV = evenRound((VARIMAX.sumArray(tvArray)), 8);\n\n            if (!NV) {\n                NV = 1;\n                NC = 0;\n                TVLT = 0;\n            } else {\n                NV = NV + 1;\n            }\n\n            // testing for convergence\n            if ((Math.abs(TV - TVLT)) < 0.00000001) {\n                NC = NC + 1;\n            } else {\n                NC = 0;\n            }\n\n            var intermediateRotation = varimaxIteration(factorMatrix);\n\n            // run no more than 225 iterations\n            testCondition = false;\n            if (NC > 3) {\n                testCondition = true;\n            }\n            if (NV >= 225) {\n                testCondition = true;\n            }\n\n        } while (testCondition === false);\n\n        var results = VARIMAX.unStandardize(factorMatrix, sumSquares);\n\n        return results;\n    }\n\n\n    // ********************************************************  controller\n    // ***** iteration dispatcher  ****************************************\n    // ********************************************************************\n\n    function varimaxIteration(standardizedFactorMatrix) {\n        // each item in 2D matrix\n        var rotatedFactors;\n        var i, j;\n        var loopLen = standardizedFactorMatrix.length;\n\n        for (i = 0; i < loopLen; i++) {\n            for (j = i + 1; j < loopLen; j++) {\n                // sends out for rotation\n                rotatedFactors = varimaxCalculations(standardizedFactorMatrix[i], standardizedFactorMatrix[j]);\n                // subs results into matrix\n                standardizedFactorMatrix[i] = rotatedFactors[0];\n                standardizedFactorMatrix[j] = rotatedFactors[1];\n            }\n        }\n        return standardizedFactorMatrix;\n    }\n\n    // **********************************************************  model\n    // ***** varimax calculator  ***************************************\n    // *****************************************************************\n\n    function varimaxCalculations(factorA, factorB) {\n        var AA = 0.0;\n        var BB = 0.0;\n        var CC = 0.0;\n        var DD = 0.0;\n        var uArray = [];\n        var tArray = [];\n        var ccArray = [];\n        var ddArray = [];\n        var COSP, SINP, testValue, TAN4T;\n        var rotatedFactors, COS4T, SIN4T, line350;\n        var factorALength = factorA.length;\n        var U, tPrep, tPrep2, ccPrep, ddPrep;\n\n\n        for (var i = 0, iLen = factorALength; i < iLen; i++) {\n            // (3776)\n            U = (factorA[i] + factorB[i]) * (factorA[i] - factorB[i]);\n            uArray.push(U);\n            // (3777)\n            tPrep = factorA[i] * factorB[i];\n            // (3778)\n            tPrep2 = tPrep + tPrep;\n            tArray.push(tPrep2);\n            // (3779)\n            ccPrep = (U + tPrep2) * (U - tPrep2);\n            ccArray.push(ccPrep);\n            // (3780)\n            ddPrep = (2 * U * tPrep2);\n            ddArray.push(ddPrep);\n        }\n\n        // (3779)\n        CC = evenRound(VARIMAX.sumArray(ccArray), 17);\n        // (3780)\n        DD = evenRound(VARIMAX.sumArray(ddArray), 17);\n        // (3781)\n        AA = evenRound(VARIMAX.sumArray(uArray), 17);\n        // (3782)\n        BB = evenRound(VARIMAX.sumArray(tArray), 17);\n\n        // (3784-3785)\n        var T = evenRound((DD - evenRound((2 * AA * evenRound((BB / factorALength), 17)), 17)), 17);\n        var B = evenRound((CC - evenRound(((AA * AA - BB * BB) / factorALength), 8)), 8);\n\n        var CospAndSinp = getComparisonOfNumAndDen(T, B);\n        rotatedFactors = doFactorRotations(CospAndSinp, factorA, factorB);\n        return rotatedFactors;\n    }\n\n    function getComparisonOfNumAndDen(T, B) {\n        var TAN4T, SINP, COSP, COS4T, SIN4T, CTN4T;\n        var COS2T, SIN2T, COST, SINT;\n        var shouldSkipRotation = false;\n\n        if (T < B) {\n            TAN4T = evenRound((Math.abs(T) / Math.abs(B)), 5);\n            if (TAN4T < 0.00116) {\n                if (B >= 0) {\n                    shouldSkipRotation = true;\n                    return [SINP, COSP, shouldSkipRotation];\n                } else {\n                    SINP = 0.7071066;\n                    COSP = 0.7071066;\n                    return [SINP, COSP, shouldSkipRotation];\n                }\n            } else {\n                // variables cascade to below\n                COS4T = evenRound((1.0 / evenRound(Math.sqrt(1.0 + TAN4T * TAN4T), 8)), 8);\n                SIN4T = evenRound((TAN4T * COS4T), 8);\n            }\n        } else if (T === B) {\n            if ((T + B) < 0.00116) {\n                shouldSkipRotation = true;\n                return [SINP, COSP, shouldSkipRotation];\n            } else {\n                // variables cascade to below\n                COS4T = 0.7071066;\n                SIN4T = 0.7071066;\n            }\n        } else { // case (T > B)\n            CTN4T = evenRound((Math.abs(T / B)), 5);\n            if (CTN4T < 0.00116) {\n                // variables cascade to below\n                COS4T = 0.0;\n                SIN4T = 1.0;\n            } else {\n                // variables cascade to below\n                SIN4T = evenRound((1.0 / evenRound(Math.sqrt(1.0 + CTN4T * CTN4T), 8)), 8);\n                COS4T = evenRound((CTN4T * SIN4T), 8);\n            }\n        }\n\n        // continue with casecade values to determine COS theta and SIN theta\n        COS2T = evenRound(Math.sqrt(((1.0 + COS4T) / 2.0)), 8);\n        SIN2T = evenRound(SIN4T / (2.0 * COS2T), 8);\n        COST = evenRound(Math.sqrt(((1.0 + COS2T) / 2.0)), 8);\n        SINT = evenRound(SIN2T / (2.0 * COST), 8);\n\n        // determine COS phi and SIN phi\n        if (B <= 0) {\n            COSP = evenRound((0.7071066 * COST + 0.7071066 * SINT), 8);\n            SINP = evenRound(Math.abs((0.7071066 * COST - 0.7071066 * SINT)), 8);\n        } else {\n            COSP = COST;\n            SINP = SINT;\n        }\n        // check T value\n        if (T <= 0) {\n            SINP = -SINP;\n        }\n        return [SINP, COSP, shouldSkipRotation];\n    }\n\n\n    //*********************************************************\n    //******* Factor Rotation function ************************\n    //*********************************************************\n\n    function doFactorRotations(CospAndSinp, factorA, factorB) {\n        var shouldSkipRotation = CospAndSinp[2];\n        if (shouldSkipRotation) {\n            var originalFactors = [factorA, factorB];\n            return originalFactors;\n        } else {\n            var resultsArrayFactorA = [];\n            var resultsArrayFactorB = [];\n            var i, AA, BB, rotatedFactors;\n            var iLoopLen = factorA.length;\n            var SINP = CospAndSinp[0];\n            var COSP = CospAndSinp[1];\n\n            for (i = 0; i < iLoopLen; i++) {\n                AA = evenRound((factorA[i] * COSP + factorB[i] * SINP), 8);\n                resultsArrayFactorA.push(AA);\n\n                BB = evenRound((-factorA[i] * SINP + factorB[i] * COSP), 8);\n                resultsArrayFactorB.push(BB);\n            }\n            rotatedFactors = [resultsArrayFactorA, resultsArrayFactorB];\n            return rotatedFactors;\n        }\n    }\n\n    //**********************************************************   model\n    //******* de-normalize rotation results ****************************\n    //******************************************************************\n\n    VARIMAX.unStandardize = function (standardizedResults, sumSquares) {\n        var results = [];\n        var nLoopLen = standardizedResults.length;\n        var n, p;\n        var arrayFrag, pLoopLen, newArrayFrag, arrayItem, resultsTransposed;\n        var crit;\n\n        for (n = 0; n < nLoopLen; n++) {\n\n            arrayFrag = standardizedResults[n];\n            newArrayFrag = [];\n            pLoopLen = arrayFrag.length;\n\n            crit = 0;\n            for (p = 0; p < pLoopLen; p++) {\n                arrayItem = 0;\n                arrayItem = (evenRound(arrayFrag[p], 5) * evenRound(Math.sqrt(sumSquares[p]), 5));\n                newArrayFrag.push(evenRound((arrayItem), 5));\n                crit = crit + arrayItem * Math.abs(arrayItem);\n            }\n\n            // invert (reflect) mostly negative factors\n            if (crit < 0) {\n                var q;\n                var qLoopLen = newArrayFrag.length;\n                for (q = 0; q < qLoopLen; q++) {\n                    newArrayFrag[q] = -newArrayFrag[q];\n                }\n            }\n            results.push(newArrayFrag);\n        }\n\n        resultsTransposed = _.zip.apply(_, results);\n\n        return resultsTransposed;\n    };\n\n    //***********************************************************\n    //************** helper functions ***************************\n    //***********************************************************\n\n    VARIMAX.sumArray = function (array) {\n        return (_.reduce(array, function (sum, num) {\n            return sum + num;\n        }));\n    };\n\n}(window.VARIMAX = window.VARIMAX || {}, QAV));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVkFSSU1BWC5qcz85Zjc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vS2VuLVEgQW5hbHlzaXNcbi8vQ29weXJpZ2h0IChDKSAyMDE2IFNoYXduIEJhbmFzaWNrXG4vL1xuLy8gICAgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuLy8gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gSlNsaW50IGRlY2xhcmF0aW9uc1xuLyogZ2xvYmFsIG51bWVyaWMsIFZBUklNQVgsIHdpbmRvdywgcGVyZm9ybWFuY2UsIFJPVEEsIFFBViwgJCwgcmVzb3VyY2VzLCBkb2N1bWVudCwgSlF1ZXJ5LCBldmVuUm91bmQsIFVUSUwsIGxvY2FsU3RvcmFnZSwgXyAqL1xuXG4oZnVuY3Rpb24gKFZBUklNQVgsIFFBViwgdW5kZWZpbmVkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgVkFSSU1BWC5maXJlVmFyaW1heFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBnZXRGYWN0b3JzRm9yUm90YXRpb24gPSBRQVYuZ2V0U3RhdGUoXCJjZW50cm9pZEZhY3RvcnNcIik7XG5cbiAgICAgICAgLy8gYXJjaGl2ZSBmYWN0b3Igcm90YXRpb24gdGFibGVcbiAgICAgICAgVVRJTC5hcmNoaXZlRmFjdG9yU2NvcmVTdGF0ZU1hdHJpeEFuZERhdGF0YWJsZSgpO1xuXG4gICAgICAgIC8vIHJ1biByb3RhdGlvblxuICAgICAgICB2YXIgdmFyaW1heFJlc3VsdHMgPSBWQVJJTUFYLmRvVmFyaW1heChnZXRGYWN0b3JzRm9yUm90YXRpb24pO1xuXG4gICAgICAgIC8vIGNvcHkgdGhlIG5ldyByb3RhdGlvbnNcbiAgICAgICAgLy8gdmFyIHJvdEZhY1N0YXRlQXJyYXlQcmVwMSA9IF8uY2xvbmVEZWVwKHZhcmltYXhSZXN1bHRzKTtcblxuICAgICAgICAvLyBzZW5kIHRvIHJvdEZhY3RvclN0YXRlQXJyYXlcbiAgICAgICAgUUFWLnNldFN0YXRlKFwicm90RmFjU3RhdGVBcnJheVwiLCB2YXJpbWF4UmVzdWx0cyk7XG5cbiAgICAgICAgLy8gcHJlcCBmb3IgY2hhcnRcbiAgICAgICAgUk9UQS5jYWxjdWxhdGVDb21tdW5hbGl0aWVzKHZhcmltYXhSZXN1bHRzKTtcblxuICAgICAgICAvLyBnZXRzIGFycmF5IGZvciBmU2lnIHRlc3RpbmcgZnJvbSBMUyBvZiBjYWxjdWxhdGVDb21tdW5hbGl0aWVzIC0gc2V0cyBmU2lnQ3JpdGVyaW9uUmVzdWx0c1xuICAgICAgICBST1RBLmNhbGN1bGF0ZWZTaWdDcml0ZXJpb25WYWx1ZXMoXCJub0ZsYWdcIik7XG5cbiAgICAgICAgLy8gcmUtZHJhdyByb3RhdGlvbiB0YWJsZVxuICAgICAgICB2YXIgaXNSb3RhdGVkRmFjdG9yc1RhYmxlVXBkYXRlID0gXCJkZXN0cm95XCI7XG4gICAgICAgIExPQUQuZHJhd1JvdGF0ZWRGYWN0b3JzVGFibGUyKGlzUm90YXRlZEZhY3RvcnNUYWJsZVVwZGF0ZSwgXCJub0ZsYWdcIik7XG4gICAgfTtcblxuXG4gICAgVkFSSU1BWC5kb1ZhcmltYXggPSBmdW5jdGlvbiAoZmFjdG9yTWF0cml4KSB7XG4gICAgICAgIHZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIHZhciBzdW1TcXVhcmVzID0gVkFSSU1BWC5jYWxjU3VtU3F1YXJlcyhmYWN0b3JNYXRyaXgpO1xuICAgICAgICB2YXIgc3RhbmRhcml6ZWRGYWN0b3JNYXRyaXggPSBWQVJJTUFYLmNhbGNTdGFuZGFyZGl6ZWRGYWN0b3JNYXRyaXgoc3VtU3F1YXJlcywgZmFjdG9yTWF0cml4KTtcbiAgICAgICAgdmFyIHJvdGF0ZWRSZXN1bHRzID0gY2FsY3VsYXRlVmFyaWFuY2VGb3JGYWN0b3JNYXRyaXgoc3RhbmRhcml6ZWRGYWN0b3JNYXRyaXgsIHN1bVNxdWFyZXMpO1xuXG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJWYXJpbWF4IHJvdGF0aW9uIGFwcGxpZWRcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uVW5kbztcbiAgICAgICAgLy8gdGhlIFwidmFyaW1heCBjYWxsZWRcIiBjbGFzcyBpcyBmb3IgdG9nZ2xpbmcgY29sb3Igb2YgdmFyaW1heCBidXR0b25cbiAgICAgICAgJChcIiNyb3RhdGlvbkhpc3RvcnlMaXN0XCIpLmFwcGVuZCgnPGxpPicgKyBhcHBlbmRUZXh0ICsgJzxidXR0b24gY2xhc3M9XCJkZWxldGVCdXR0b24gIHZhcmltYXhDYWxsZWRcIj4nICsgYXBwZW5kVGV4dDIgKyAnPC9idXR0b24+PC9saT4nKTtcblxuICAgICAgICB2YXIgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnJWMgVmFyaW1heCByb3RhdGlvbnMgY29tcGxldGVkIGluICcgKyAodDEgLSB0MCkudG9GaXhlZCgwKSArICcgbWlsbGlzZWNvbmRzJywgJ2JhY2tncm91bmQ6ICMwYzdmZDc7IGNvbG9yOiB3aGl0ZScpO1xuICAgICAgICByZXR1cm4gcm90YXRlZFJlc3VsdHM7XG4gICAgfTtcblxuICAgIFZBUklNQVguY2FsY1N0YW5kYXJkaXplZEZhY3Rvck1hdHJpeCA9IGZ1bmN0aW9uIChzdW1TcXVhcmVzLCBmYWN0b3JNYXRyaXgpIHtcbiAgICAgICAgLy8gKDM3MjItMzcyNylcbiAgICAgICAgdmFyIHN0YW5kYXJpemVkRmFjdG9yTWF0cml4ID0gW107XG4gICAgICAgIHZhciBhcnJheUZyYWcxO1xuICAgICAgICB2YXIgdGVtcDU7XG4gICAgICAgIHZhciBsZW4yO1xuICAgICAgICB2YXIgdGVtcDQ7XG4gICAgICAgIHZhciBzcXJ0U3VtU3F1YXJlcztcbiAgICAgICAgdmFyIG0sIGs7XG4gICAgICAgIHZhciBsb29wTGVuMSA9IGZhY3Rvck1hdHJpeC5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChtID0gMDsgbSA8IGxvb3BMZW4xOyBtKyspIHtcbiAgICAgICAgICAgIGFycmF5RnJhZzEgPSBmYWN0b3JNYXRyaXhbbV07XG4gICAgICAgICAgICB0ZW1wNSA9IFtdO1xuICAgICAgICAgICAgbGVuMiA9IGZhY3Rvck1hdHJpeFttXS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBsZW4yOyBrKyspIHtcbiAgICAgICAgICAgICAgICBzcXJ0U3VtU3F1YXJlcyA9IGV2ZW5Sb3VuZChNYXRoLnNxcnQoc3VtU3F1YXJlc1trXSksIDgpO1xuICAgICAgICAgICAgICAgIGlmIChzcXJ0U3VtU3F1YXJlcyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wNCA9IGV2ZW5Sb3VuZCgoYXJyYXlGcmFnMVtrXSAvIHNxcnRTdW1TcXVhcmVzKSwgOCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcDQgPSAwLjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXA1LnB1c2godGVtcDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhbmRhcml6ZWRGYWN0b3JNYXRyaXgucHVzaCh0ZW1wNSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YW5kYXJpemVkRmFjdG9yTWF0cml4O1xuICAgIH07XG5cbiAgICBWQVJJTUFYLmNhbGNTdW1TcXVhcmVzID0gZnVuY3Rpb24gKGZhY3Rvck1hdHJpeCkge1xuICAgICAgICAvLyAoMzcwOSAtIDM3MTQpXG4gICAgICAgIHZhciB0ZW1wMSwgdGVtcDMsIHRlbXA7XG4gICAgICAgIHZhciBzdW1TcXVhcmVzID0gW107XG4gICAgICAgIHZhciBsb29wTGVuID0gZmFjdG9yTWF0cml4Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBmYWN0b3JNYXRyaXhbMF0ubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wMSA9IDA7XG4gICAgICAgICAgICB0ZW1wMyA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxvb3BMZW47IGorKykge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBldmVuUm91bmQoKGZhY3Rvck1hdHJpeFtqXVtpXSAqIGZhY3Rvck1hdHJpeFtqXVtpXSksIDgpO1xuICAgICAgICAgICAgICAgIHRlbXAxID0gdGVtcDEgKyB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcDMgPSBldmVuUm91bmQoKHRlbXAxKSwgOCk7XG4gICAgICAgICAgICBzdW1TcXVhcmVzLnB1c2godGVtcDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW1TcXVhcmVzO1xuICAgIH07XG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgY29udHJvbGxlclxuICAgIC8vICoqKioqIHZhcmltYXggaXRlcmF0aW9uIGxvb3AgY29udHJvbGxlciAqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKiogY2FsY2xhdGUgdmFyaWFuY2UgZm9yIGZhY3RvciBtYXRyaXggKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlVmFyaWFuY2VGb3JGYWN0b3JNYXRyaXgoZmFjdG9yTWF0cml4LCBzdW1TcXVhcmVzKSB7XG4gICAgICAgIC8vIGFsc28gY2FsbHMgYW5kIGxvb3BzIGZhY3RvciBhZGp1c3RtZW50IGZ1bmN0aW9uIHZhcmltYXhJdGVyYXRpb25cbiAgICAgICAgdmFyIE5WOyAvLyA9IDE7ICBvdXRlciBiaWcgbG9vcCBjb3VudGVyXG4gICAgICAgIC8vIHZhciBUVk5WICAgICAgLy8gdG90YWwgdmFyaWFuY2Ugb2YgY3VycmVudCBsb29wXG4gICAgICAgIHZhciBUVkxUOyAvLyAgdG90YWwgdmFyaWFuY2Ugb2YgcHJldmlvdXMgbG9vcCB1c2VkIGZvciBraWNrb3V0IHRlc3RcbiAgICAgICAgdmFyIE5DO1xuICAgICAgICB2YXIgVFYgPSAwOyAvLyB0b3RhbCB2YXJpYW5jZVxuICAgICAgICB2YXIgYWFBcnJheSwgYmJBcnJheSwgdHZBcnJheTtcbiAgICAgICAgdmFyIEZOID0gZmFjdG9yTWF0cml4WzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIEZGTiA9IEZOICogRk47XG4gICAgICAgIHZhciB0ZXN0Q29uZGl0aW9uO1xuICAgICAgICB2YXIgQUEsIEJCLCBGTkJCLCBBQVNRO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChOVikge1xuICAgICAgICAgICAgICAgIGZhY3Rvck1hdHJpeCA9IGludGVybWVkaWF0ZVJvdGF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0dkFycmF5ID0gW107XG4gICAgICAgICAgICB2YXIgdGVtcDEsIHRlbXAzLCBhcnJheUZyYWcsIHRlbXA7XG4gICAgICAgICAgICB2YXIgaSwgajtcbiAgICAgICAgICAgIHZhciBpTG9vcExlbiA9IGZhY3Rvck1hdHJpeC5sZW5ndGg7XG5cbiAgICAgICAgICAgIFRWTFQgPSBUVjtcblxuICAgICAgICAgICAgLy8gZ2V0cyBzdW1TcXVhcmVzIG9mIG5ldyB2YXJpbWF4SXRlcmF0aW9uIG1hdHJpeCB0byBjaGVjayBjb252ZXJnZW5jZVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGlMb29wTGVuOyBpKyspIHsgLy8gZm9yIGVhY2ggZmFjdG9yXG4gICAgICAgICAgICAgICAgQUEgPSAwO1xuICAgICAgICAgICAgICAgIEJCID0gMDtcbiAgICAgICAgICAgICAgICB0ZW1wMSA9IDA7XG4gICAgICAgICAgICAgICAgdGVtcDMgPSAwO1xuICAgICAgICAgICAgICAgIGFycmF5RnJhZyA9IGZhY3Rvck1hdHJpeFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgakxvb3BMZW4gPSBhcnJheUZyYWcubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgYWFBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIGJiQXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxvb3BMZW47IGorKykgeyAvLyBmb3IgZWFjaCBzb3J0XG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSBldmVuUm91bmQoKGFycmF5RnJhZ1tqXSAqIGFycmF5RnJhZ1tqXSksIDgpOyAvLyBDQ1xuICAgICAgICAgICAgICAgICAgICBhYUFycmF5LnB1c2goZXZlblJvdW5kKCh0ZW1wKSwgOCkpOyAvLyBBQVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcEJCID0gZXZlblJvdW5kKCh0ZW1wICogdGVtcCksIDgpO1xuICAgICAgICAgICAgICAgICAgICBiYkFycmF5LnB1c2goZXZlblJvdW5kKCh0ZW1wQkIpLCA4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEFBID0gZXZlblJvdW5kKChWQVJJTUFYLnN1bUFycmF5KGFhQXJyYXkpKSwgOCk7XG4gICAgICAgICAgICAgICAgQkIgPSBldmVuUm91bmQoKFZBUklNQVguc3VtQXJyYXkoYmJBcnJheSkpLCA4KTtcbiAgICAgICAgICAgICAgICAvLyBGTiBpcyBudW1iZXIgZmFjdG9ycywgQUEgaXMgdG90YWwgb2Ygc3VtU3F1YXJlcywgQkIgaXMgc3F1YXJlIG9mIHRvdGFsIG9mIHN1bVNxdWFyZXMsIEZGTiBpcyBudW1iZXIgZmFjdG9ycyBzcXVhcmVkXG4gICAgICAgICAgICAgICAgLy8gKDM3NDUpIFxuICAgICAgICAgICAgICAgIEZOQkIgPSBldmVuUm91bmQoKEZOICogQkIpLCA4KTtcbiAgICAgICAgICAgICAgICBBQVNRID0gZXZlblJvdW5kKChBQSAqIEFBKSwgOCk7XG4gICAgICAgICAgICAgICAgLy9UViA9IGV2ZW5Sb3VuZCgoKEZOICogQkIgLSBBQSAqIEFBKSAvIEZGTiksIDgpO1xuICAgICAgICAgICAgICAgIFRWID0gZXZlblJvdW5kKCgoRk5CQiAtIEFBU1EpIC8gRkZOKSwgOCk7XG4gICAgICAgICAgICAgICAgdHZBcnJheS5wdXNoKFRWKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVFYgPSBldmVuUm91bmQoKFZBUklNQVguc3VtQXJyYXkodHZBcnJheSkpLCA4KTtcblxuICAgICAgICAgICAgaWYgKCFOVikge1xuICAgICAgICAgICAgICAgIE5WID0gMTtcbiAgICAgICAgICAgICAgICBOQyA9IDA7XG4gICAgICAgICAgICAgICAgVFZMVCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE5WID0gTlYgKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0ZXN0aW5nIGZvciBjb252ZXJnZW5jZVxuICAgICAgICAgICAgaWYgKChNYXRoLmFicyhUViAtIFRWTFQpKSA8IDAuMDAwMDAwMDEpIHtcbiAgICAgICAgICAgICAgICBOQyA9IE5DICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTkMgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW50ZXJtZWRpYXRlUm90YXRpb24gPSB2YXJpbWF4SXRlcmF0aW9uKGZhY3Rvck1hdHJpeCk7XG5cbiAgICAgICAgICAgIC8vIHJ1biBubyBtb3JlIHRoYW4gMjI1IGl0ZXJhdGlvbnNcbiAgICAgICAgICAgIHRlc3RDb25kaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChOQyA+IDMpIHtcbiAgICAgICAgICAgICAgICB0ZXN0Q29uZGl0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOViA+PSAyMjUpIHtcbiAgICAgICAgICAgICAgICB0ZXN0Q29uZGl0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IHdoaWxlICh0ZXN0Q29uZGl0aW9uID09PSBmYWxzZSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBWQVJJTUFYLnVuU3RhbmRhcmRpemUoZmFjdG9yTWF0cml4LCBzdW1TcXVhcmVzKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICBjb250cm9sbGVyXG4gICAgLy8gKioqKiogaXRlcmF0aW9uIGRpc3BhdGNoZXIgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgZnVuY3Rpb24gdmFyaW1heEl0ZXJhdGlvbihzdGFuZGFyZGl6ZWRGYWN0b3JNYXRyaXgpIHtcbiAgICAgICAgLy8gZWFjaCBpdGVtIGluIDJEIG1hdHJpeFxuICAgICAgICB2YXIgcm90YXRlZEZhY3RvcnM7XG4gICAgICAgIHZhciBpLCBqO1xuICAgICAgICB2YXIgbG9vcExlbiA9IHN0YW5kYXJkaXplZEZhY3Rvck1hdHJpeC5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxvb3BMZW47IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBsb29wTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAvLyBzZW5kcyBvdXQgZm9yIHJvdGF0aW9uXG4gICAgICAgICAgICAgICAgcm90YXRlZEZhY3RvcnMgPSB2YXJpbWF4Q2FsY3VsYXRpb25zKHN0YW5kYXJkaXplZEZhY3Rvck1hdHJpeFtpXSwgc3RhbmRhcmRpemVkRmFjdG9yTWF0cml4W2pdKTtcbiAgICAgICAgICAgICAgICAvLyBzdWJzIHJlc3VsdHMgaW50byBtYXRyaXhcbiAgICAgICAgICAgICAgICBzdGFuZGFyZGl6ZWRGYWN0b3JNYXRyaXhbaV0gPSByb3RhdGVkRmFjdG9yc1swXTtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZGl6ZWRGYWN0b3JNYXRyaXhbal0gPSByb3RhdGVkRmFjdG9yc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhbmRhcmRpemVkRmFjdG9yTWF0cml4O1xuICAgIH1cblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogIG1vZGVsXG4gICAgLy8gKioqKiogdmFyaW1heCBjYWxjdWxhdG9yICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgZnVuY3Rpb24gdmFyaW1heENhbGN1bGF0aW9ucyhmYWN0b3JBLCBmYWN0b3JCKSB7XG4gICAgICAgIHZhciBBQSA9IDAuMDtcbiAgICAgICAgdmFyIEJCID0gMC4wO1xuICAgICAgICB2YXIgQ0MgPSAwLjA7XG4gICAgICAgIHZhciBERCA9IDAuMDtcbiAgICAgICAgdmFyIHVBcnJheSA9IFtdO1xuICAgICAgICB2YXIgdEFycmF5ID0gW107XG4gICAgICAgIHZhciBjY0FycmF5ID0gW107XG4gICAgICAgIHZhciBkZEFycmF5ID0gW107XG4gICAgICAgIHZhciBDT1NQLCBTSU5QLCB0ZXN0VmFsdWUsIFRBTjRUO1xuICAgICAgICB2YXIgcm90YXRlZEZhY3RvcnMsIENPUzRULCBTSU40VCwgbGluZTM1MDtcbiAgICAgICAgdmFyIGZhY3RvckFMZW5ndGggPSBmYWN0b3JBLmxlbmd0aDtcbiAgICAgICAgdmFyIFUsIHRQcmVwLCB0UHJlcDIsIGNjUHJlcCwgZGRQcmVwO1xuXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBmYWN0b3JBTGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyAoMzc3NilcbiAgICAgICAgICAgIFUgPSAoZmFjdG9yQVtpXSArIGZhY3RvckJbaV0pICogKGZhY3RvckFbaV0gLSBmYWN0b3JCW2ldKTtcbiAgICAgICAgICAgIHVBcnJheS5wdXNoKFUpO1xuICAgICAgICAgICAgLy8gKDM3NzcpXG4gICAgICAgICAgICB0UHJlcCA9IGZhY3RvckFbaV0gKiBmYWN0b3JCW2ldO1xuICAgICAgICAgICAgLy8gKDM3NzgpXG4gICAgICAgICAgICB0UHJlcDIgPSB0UHJlcCArIHRQcmVwO1xuICAgICAgICAgICAgdEFycmF5LnB1c2godFByZXAyKTtcbiAgICAgICAgICAgIC8vICgzNzc5KVxuICAgICAgICAgICAgY2NQcmVwID0gKFUgKyB0UHJlcDIpICogKFUgLSB0UHJlcDIpO1xuICAgICAgICAgICAgY2NBcnJheS5wdXNoKGNjUHJlcCk7XG4gICAgICAgICAgICAvLyAoMzc4MClcbiAgICAgICAgICAgIGRkUHJlcCA9ICgyICogVSAqIHRQcmVwMik7XG4gICAgICAgICAgICBkZEFycmF5LnB1c2goZGRQcmVwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICgzNzc5KVxuICAgICAgICBDQyA9IGV2ZW5Sb3VuZChWQVJJTUFYLnN1bUFycmF5KGNjQXJyYXkpLCAxNyk7XG4gICAgICAgIC8vICgzNzgwKVxuICAgICAgICBERCA9IGV2ZW5Sb3VuZChWQVJJTUFYLnN1bUFycmF5KGRkQXJyYXkpLCAxNyk7XG4gICAgICAgIC8vICgzNzgxKVxuICAgICAgICBBQSA9IGV2ZW5Sb3VuZChWQVJJTUFYLnN1bUFycmF5KHVBcnJheSksIDE3KTtcbiAgICAgICAgLy8gKDM3ODIpXG4gICAgICAgIEJCID0gZXZlblJvdW5kKFZBUklNQVguc3VtQXJyYXkodEFycmF5KSwgMTcpO1xuXG4gICAgICAgIC8vICgzNzg0LTM3ODUpXG4gICAgICAgIHZhciBUID0gZXZlblJvdW5kKChERCAtIGV2ZW5Sb3VuZCgoMiAqIEFBICogZXZlblJvdW5kKChCQiAvIGZhY3RvckFMZW5ndGgpLCAxNykpLCAxNykpLCAxNyk7XG4gICAgICAgIHZhciBCID0gZXZlblJvdW5kKChDQyAtIGV2ZW5Sb3VuZCgoKEFBICogQUEgLSBCQiAqIEJCKSAvIGZhY3RvckFMZW5ndGgpLCA4KSksIDgpO1xuXG4gICAgICAgIHZhciBDb3NwQW5kU2lucCA9IGdldENvbXBhcmlzb25PZk51bUFuZERlbihULCBCKTtcbiAgICAgICAgcm90YXRlZEZhY3RvcnMgPSBkb0ZhY3RvclJvdGF0aW9ucyhDb3NwQW5kU2lucCwgZmFjdG9yQSwgZmFjdG9yQik7XG4gICAgICAgIHJldHVybiByb3RhdGVkRmFjdG9ycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb21wYXJpc29uT2ZOdW1BbmREZW4oVCwgQikge1xuICAgICAgICB2YXIgVEFONFQsIFNJTlAsIENPU1AsIENPUzRULCBTSU40VCwgQ1RONFQ7XG4gICAgICAgIHZhciBDT1MyVCwgU0lOMlQsIENPU1QsIFNJTlQ7XG4gICAgICAgIHZhciBzaG91bGRTa2lwUm90YXRpb24gPSBmYWxzZTtcblxuICAgICAgICBpZiAoVCA8IEIpIHtcbiAgICAgICAgICAgIFRBTjRUID0gZXZlblJvdW5kKChNYXRoLmFicyhUKSAvIE1hdGguYWJzKEIpKSwgNSk7XG4gICAgICAgICAgICBpZiAoVEFONFQgPCAwLjAwMTE2KSB7XG4gICAgICAgICAgICAgICAgaWYgKEIgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRTa2lwUm90YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1NJTlAsIENPU1AsIHNob3VsZFNraXBSb3RhdGlvbl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgU0lOUCA9IDAuNzA3MTA2NjtcbiAgICAgICAgICAgICAgICAgICAgQ09TUCA9IDAuNzA3MTA2NjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtTSU5QLCBDT1NQLCBzaG91bGRTa2lwUm90YXRpb25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdmFyaWFibGVzIGNhc2NhZGUgdG8gYmVsb3dcbiAgICAgICAgICAgICAgICBDT1M0VCA9IGV2ZW5Sb3VuZCgoMS4wIC8gZXZlblJvdW5kKE1hdGguc3FydCgxLjAgKyBUQU40VCAqIFRBTjRUKSwgOCkpLCA4KTtcbiAgICAgICAgICAgICAgICBTSU40VCA9IGV2ZW5Sb3VuZCgoVEFONFQgKiBDT1M0VCksIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFQgPT09IEIpIHtcbiAgICAgICAgICAgIGlmICgoVCArIEIpIDwgMC4wMDExNikge1xuICAgICAgICAgICAgICAgIHNob3VsZFNraXBSb3RhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtTSU5QLCBDT1NQLCBzaG91bGRTa2lwUm90YXRpb25dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZXMgY2FzY2FkZSB0byBiZWxvd1xuICAgICAgICAgICAgICAgIENPUzRUID0gMC43MDcxMDY2O1xuICAgICAgICAgICAgICAgIFNJTjRUID0gMC43MDcxMDY2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBjYXNlIChUID4gQilcbiAgICAgICAgICAgIENUTjRUID0gZXZlblJvdW5kKChNYXRoLmFicyhUIC8gQikpLCA1KTtcbiAgICAgICAgICAgIGlmIChDVE40VCA8IDAuMDAxMTYpIHtcbiAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZXMgY2FzY2FkZSB0byBiZWxvd1xuICAgICAgICAgICAgICAgIENPUzRUID0gMC4wO1xuICAgICAgICAgICAgICAgIFNJTjRUID0gMS4wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZXMgY2FzY2FkZSB0byBiZWxvd1xuICAgICAgICAgICAgICAgIFNJTjRUID0gZXZlblJvdW5kKCgxLjAgLyBldmVuUm91bmQoTWF0aC5zcXJ0KDEuMCArIENUTjRUICogQ1RONFQpLCA4KSksIDgpO1xuICAgICAgICAgICAgICAgIENPUzRUID0gZXZlblJvdW5kKChDVE40VCAqIFNJTjRUKSwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb250aW51ZSB3aXRoIGNhc2VjYWRlIHZhbHVlcyB0byBkZXRlcm1pbmUgQ09TIHRoZXRhIGFuZCBTSU4gdGhldGFcbiAgICAgICAgQ09TMlQgPSBldmVuUm91bmQoTWF0aC5zcXJ0KCgoMS4wICsgQ09TNFQpIC8gMi4wKSksIDgpO1xuICAgICAgICBTSU4yVCA9IGV2ZW5Sb3VuZChTSU40VCAvICgyLjAgKiBDT1MyVCksIDgpO1xuICAgICAgICBDT1NUID0gZXZlblJvdW5kKE1hdGguc3FydCgoKDEuMCArIENPUzJUKSAvIDIuMCkpLCA4KTtcbiAgICAgICAgU0lOVCA9IGV2ZW5Sb3VuZChTSU4yVCAvICgyLjAgKiBDT1NUKSwgOCk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIENPUyBwaGkgYW5kIFNJTiBwaGlcbiAgICAgICAgaWYgKEIgPD0gMCkge1xuICAgICAgICAgICAgQ09TUCA9IGV2ZW5Sb3VuZCgoMC43MDcxMDY2ICogQ09TVCArIDAuNzA3MTA2NiAqIFNJTlQpLCA4KTtcbiAgICAgICAgICAgIFNJTlAgPSBldmVuUm91bmQoTWF0aC5hYnMoKDAuNzA3MTA2NiAqIENPU1QgLSAwLjcwNzEwNjYgKiBTSU5UKSksIDgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQ09TUCA9IENPU1Q7XG4gICAgICAgICAgICBTSU5QID0gU0lOVDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBUIHZhbHVlXG4gICAgICAgIGlmIChUIDw9IDApIHtcbiAgICAgICAgICAgIFNJTlAgPSAtU0lOUDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1NJTlAsIENPU1AsIHNob3VsZFNraXBSb3RhdGlvbl07XG4gICAgfVxuXG5cbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vKioqKioqKiBGYWN0b3IgUm90YXRpb24gZnVuY3Rpb24gKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIGZ1bmN0aW9uIGRvRmFjdG9yUm90YXRpb25zKENvc3BBbmRTaW5wLCBmYWN0b3JBLCBmYWN0b3JCKSB7XG4gICAgICAgIHZhciBzaG91bGRTa2lwUm90YXRpb24gPSBDb3NwQW5kU2lucFsyXTtcbiAgICAgICAgaWYgKHNob3VsZFNraXBSb3RhdGlvbikge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRmFjdG9ycyA9IFtmYWN0b3JBLCBmYWN0b3JCXTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEZhY3RvcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0c0FycmF5RmFjdG9yQSA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdHNBcnJheUZhY3RvckIgPSBbXTtcbiAgICAgICAgICAgIHZhciBpLCBBQSwgQkIsIHJvdGF0ZWRGYWN0b3JzO1xuICAgICAgICAgICAgdmFyIGlMb29wTGVuID0gZmFjdG9yQS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgU0lOUCA9IENvc3BBbmRTaW5wWzBdO1xuICAgICAgICAgICAgdmFyIENPU1AgPSBDb3NwQW5kU2lucFsxXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGlMb29wTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBBQSA9IGV2ZW5Sb3VuZCgoZmFjdG9yQVtpXSAqIENPU1AgKyBmYWN0b3JCW2ldICogU0lOUCksIDgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNBcnJheUZhY3RvckEucHVzaChBQSk7XG5cbiAgICAgICAgICAgICAgICBCQiA9IGV2ZW5Sb3VuZCgoLWZhY3RvckFbaV0gKiBTSU5QICsgZmFjdG9yQltpXSAqIENPU1ApLCA4KTtcbiAgICAgICAgICAgICAgICByZXN1bHRzQXJyYXlGYWN0b3JCLnB1c2goQkIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm90YXRlZEZhY3RvcnMgPSBbcmVzdWx0c0FycmF5RmFjdG9yQSwgcmVzdWx0c0FycmF5RmFjdG9yQl07XG4gICAgICAgICAgICByZXR1cm4gcm90YXRlZEZhY3RvcnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogICBtb2RlbFxuICAgIC8vKioqKioqKiBkZS1ub3JtYWxpemUgcm90YXRpb24gcmVzdWx0cyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIFZBUklNQVgudW5TdGFuZGFyZGl6ZSA9IGZ1bmN0aW9uIChzdGFuZGFyZGl6ZWRSZXN1bHRzLCBzdW1TcXVhcmVzKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHZhciBuTG9vcExlbiA9IHN0YW5kYXJkaXplZFJlc3VsdHMubGVuZ3RoO1xuICAgICAgICB2YXIgbiwgcDtcbiAgICAgICAgdmFyIGFycmF5RnJhZywgcExvb3BMZW4sIG5ld0FycmF5RnJhZywgYXJyYXlJdGVtLCByZXN1bHRzVHJhbnNwb3NlZDtcbiAgICAgICAgdmFyIGNyaXQ7XG5cbiAgICAgICAgZm9yIChuID0gMDsgbiA8IG5Mb29wTGVuOyBuKyspIHtcblxuICAgICAgICAgICAgYXJyYXlGcmFnID0gc3RhbmRhcmRpemVkUmVzdWx0c1tuXTtcbiAgICAgICAgICAgIG5ld0FycmF5RnJhZyA9IFtdO1xuICAgICAgICAgICAgcExvb3BMZW4gPSBhcnJheUZyYWcubGVuZ3RoO1xuXG4gICAgICAgICAgICBjcml0ID0gMDtcbiAgICAgICAgICAgIGZvciAocCA9IDA7IHAgPCBwTG9vcExlbjsgcCsrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlJdGVtID0gMDtcbiAgICAgICAgICAgICAgICBhcnJheUl0ZW0gPSAoZXZlblJvdW5kKGFycmF5RnJhZ1twXSwgNSkgKiBldmVuUm91bmQoTWF0aC5zcXJ0KHN1bVNxdWFyZXNbcF0pLCA1KSk7XG4gICAgICAgICAgICAgICAgbmV3QXJyYXlGcmFnLnB1c2goZXZlblJvdW5kKChhcnJheUl0ZW0pLCA1KSk7XG4gICAgICAgICAgICAgICAgY3JpdCA9IGNyaXQgKyBhcnJheUl0ZW0gKiBNYXRoLmFicyhhcnJheUl0ZW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnZlcnQgKHJlZmxlY3QpIG1vc3RseSBuZWdhdGl2ZSBmYWN0b3JzXG4gICAgICAgICAgICBpZiAoY3JpdCA8IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcTtcbiAgICAgICAgICAgICAgICB2YXIgcUxvb3BMZW4gPSBuZXdBcnJheUZyYWcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAocSA9IDA7IHEgPCBxTG9vcExlbjsgcSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FycmF5RnJhZ1txXSA9IC1uZXdBcnJheUZyYWdbcV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5ld0FycmF5RnJhZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRzVHJhbnNwb3NlZCA9IF8uemlwLmFwcGx5KF8sIHJlc3VsdHMpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzVHJhbnNwb3NlZDtcbiAgICB9O1xuXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vKioqKioqKioqKioqKiogaGVscGVyIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBWQVJJTUFYLnN1bUFycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiAoXy5yZWR1Y2UoYXJyYXksIGZ1bmN0aW9uIChzdW0sIG51bSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgICAgfSkpO1xuICAgIH07XG5cbn0od2luZG93LlZBUklNQVggPSB3aW5kb3cuVkFSSU1BWCB8fCB7fSwgUUFWKSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvVkFSSU1BWC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9')}});