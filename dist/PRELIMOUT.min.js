!function(g){function I(A){if(C[A])return C[A].exports;var n=C[A]={i:A,l:!1,exports:{}};return g[A].call(n.exports,n,n.exports,I),n.l=!0,n.exports}var C={};I.m=g,I.c=C,I.i=function(g){return g},I.d=function(g,C,A){I.o(g,C)||Object.defineProperty(g,C,{configurable:!1,enumerable:!0,get:A})},I.n=function(g){var C=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(C,"a",C),C},I.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},I.p="",I(I.s=11)}({11:function(module,exports){eval('/* @preserve\nKen-Q Analysis\nCopyright (C) 2016 Shawn Banasick\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n*/\n/*  JSlint declarations\n global resources, d3, VIEW, d3_save_svg, CORR, alasql, window, QAV, $, document, evenRound, UTIL, _  \n */\n\n(function (PRELIMOUT, QAV, undefined) {\n    \'use strict\';\n    // ************************************************************************  view\n    // ******  Preliminary Results 1 - draw factor synthetic Q-sorts visuals ********\n    //  ******************************************************************************\n    PRELIMOUT.showPreliminaryOutput1 = function () {\n        // add synthetic factors visualizations\n        // $("#synFactorVizTitle").append("<h4>" + synFactorVizTitleText + "</h4>"); \n\n        var distStatementDataVizArray = QAV.getState("distStatementDataVizArray");\n        var outputForDataViz = QAV.getState("outputForDataViz");\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n        // var language = QAV.getState("language");\n        var vizConfig = QAV.getState("vizConfig") || {};\n\n        // console.log(JSON.stringify(outputForDataViz));\n\n\n        // loop through userSelectedFactors to get each synFactorViz\n        for (var i = 0; i < outputForDataViz.length; i++) {\n            // var synFactorVizName = "synFactorViz" + (i + 1);\n\n            // loop through each distinguishing statement in distStatementDataVizArray[i]\n            for (var j = 0; j < distStatementDataVizArray[i].length; j++) {\n                // get statement number\n                var statementId = distStatementDataVizArray[i][j]["No."];\n                // avoid empty objects\n                var sigSymbol;\n                var testValue = parseInt(statementId, 10);\n                if (!isNaN(testValue)) {\n\n                    // get values for calc of direction symbol\n                    var sigFactorZscoreKey = "Z-SCR-" + userSelectedFactors[i];\n                    var sigFactorZscoreValue = distStatementDataVizArray[i][j][sigFactorZscoreKey];\n                    var allFactorZscores = [];\n\n                    // loop through all of the factor z-scores and push to array\n                    for (var k = 0; k < userSelectedFactors.length; k++) {\n                        var temp1 = "Z-SCR-" + userSelectedFactors[k];\n                        var temp2 = distStatementDataVizArray[i][j][temp1];\n                        allFactorZscores.push(temp2);\n                    }\n                    // calc directionSymbol by checking against Zscore in all other factors\n                    var otherFactorZscores = _.pull(allFactorZscores, sigFactorZscoreValue);\n                    // var factorZscoreAverage = d3.mean(otherFactorZscores);\n                    var arrowPointerArrayLeft = [],\n                        arrowPointerArrayRight = [];\n                    for (var kk = 0; kk < otherFactorZscores.length; kk++) {\n                        if (sigFactorZscoreValue - otherFactorZscores[kk] > 0) {\n                            arrowPointerArrayRight.push("1");\n                        } else {\n                            arrowPointerArrayLeft.push("1");\n                        }\n                    }\n\n                    var directionSymbol;\n                    if (otherFactorZscores.length === arrowPointerArrayRight.length && userSelectedFactors.length > 1) {\n                        directionSymbol = vizConfig.shouldUseUnicode !== false ?\n                            "\\u25BA" :\n                            ">>"; // " >>>"; "&#9658;";  right-pointing pointer\n                    } else if (otherFactorZscores.length === arrowPointerArrayLeft.length) {\n                        directionSymbol = vizConfig.shouldUseUnicode !== false ?\n                            "\\u25C4" :\n                            "<<"; //" <<<";  "&#9668;";  left-pointing pointer\n                    } else {\n                        directionSymbol = "";\n                    }\n                    // put it all together and insert into object\n                    var sigFactorName = "SIG" + userSelectedFactors[i];\n                    var sigAt01Level = distStatementDataVizArray[i][j][sigFactorName];\n                    var location = statementId - 1;\n                    if (sigAt01Level === "*") {\n                        sigSymbol = vizConfig.shouldUseUnicode !== false ?\n                            "\\u25C9" :\n                            "** "; //"**";  "&#9673;";  sig at .01\n                    } else if (sigAt01Level === "") {\n                        sigSymbol = vizConfig.shouldUseUnicode !== false ?\n                            "\\u25CE" :\n                            "* "; // "*";  "&#9678;";  sig at .05\n                    }\n                    if (vizConfig.shouldShowZscoreArrows !== false) {\n                        outputForDataViz[i][location].sigVisualization = (sigSymbol + directionSymbol);\n                    } else if (vizConfig.shouldShowZscoreArrows === false) {\n                        outputForDataViz[i][location].sigVisualization = sigSymbol;\n                    }\n                }\n            }\n        }\n        // QAV.setState("outputForDataViz", outputForDataViz);\n\n        PRELIMOUT.drawSynSortTrianglesForOutput(outputForDataViz, userSelectedFactors);\n    };\n\n\n    PRELIMOUT.drawSynSortTrianglesForOutput = function (outputForDataViz, userSelectedFactors) {\n        var sortTriangleShape = QAV.getState("qavSortTriangleShape");\n        var uniques = _.uniq(sortTriangleShape);\n        var currentStatements = QAV.getState("qavCurrentStatements");\n        var language = QAV.getState("language");\n        var synFactorVizTitleText = resources[language].translation["Synthetic Sort for"];\n        var disting05LegendText = resources[language].translation["Distinguishing statement at P < 0.05"];\n        var disting01LegendText = resources[language].translation["Distinguishing statement at P < 0.01"];\n        var legendTitleText = resources[language].translation.Legend;\n        var zscoreHigherLegendText = resources[language].translation["z-Score for the statement is higher than in all of the other factors"];\n        var zscoreLowerLegendText = resources[language].translation["z-Score for the statement is lower than in all of the other factors"];\n        var consensusLegendText = resources[language].translation["Consensus statement (non-significant at P > 0.1)"];\n        var matchingCountLegendText = resources[language].translation["Low number of raw Q-sort matching values (cutoff"];\n        var overlapLegendText = resources[language].translation["Consensus statement with low number of matching values"];\n\n\n        var svgHeight;\n        var elementHeight,\n            symbolSize,\n            vSeparation,\n            svgHeightCalc;\n        var vizConfig = QAV.getState("vizConfig") || {};\n        var cardFontSize = "12px"; // default setting\n        var containerWidth = ($(".container")\n            .width() - 40);\n        var elementWidth,\n            config;\n        var consensusColor = vizConfig.consensusCustomColor;\n        var matchCountColor = vizConfig.matchCountCustomColor;\n        var overlapColor = vizConfig.overlapCustomColor;\n        var consensusIndicator = vizConfig.shouldUseToIndicateConsensus; //"color / stripe"\n        var matchCautionIndicator = vizConfig.shouldUseToIndicateMatchCaution; // color stripe\n        var overlapIndicator = vizConfig.shouldUseToIndicateOverlap; // color crosshatch\n\n        // user adjust indicator types\n        if (consensusIndicator === "stripe") {\n            consensusIndicator = \'url(#hash4_4)\';\n        } else if (consensusIndicator === "color") {\n            consensusIndicator = consensusColor;\n        }\n\n        if (matchCautionIndicator === "color") {\n            matchCautionIndicator = matchCountColor;\n        } else if (matchCautionIndicator === "stripe") {\n            matchCautionIndicator = \'url(#hash4_4b)\';\n        }\n\n        if (overlapIndicator === "color") {\n            overlapIndicator = overlapColor;\n        } else if (overlapIndicator === "crosshatch") {\n            overlapIndicator = \'url(#crosshatch)\';\n        }\n\n        // user adjust card width\n        if (vizConfig.shouldSetCardWidth === true) {\n            elementWidth = vizConfig.cardWidth;\n            containerWidth = (elementWidth * uniques.length) + 10;\n        } else {\n            elementWidth = containerWidth / uniques.length;\n        }\n\n        // user adjust font size for cards\n        if (vizConfig.shouldSetFontSize === true) {\n            cardFontSize = vizConfig.fontSize + "px";\n        }\n\n        // user adjust card height\n        if (vizConfig.shouldSetCardHeight === true) {\n            var newHeightValue = vizConfig.cardHeight;\n            if (newHeightValue === undefined) {\n                newHeightValue = 110;\n            }\n            elementHeight = parseInt(newHeightValue, 10);\n        } else {\n            elementHeight = 110;\n        }\n\n        // user adjust sig symbol size\n        if (vizConfig.shouldSetSymbolFontSize === true) {\n            symbolSize = vizConfig.sigSymbolFontSize + "px";\n        } else {\n            symbolSize = "12px";\n        }\n\n        // user adjust line spacing\n        if (vizConfig.shouldSetLineSpacing === true) {\n            vSeparation = vizConfig.lineSpacing;\n        } else {\n            vSeparation = 15;\n        }\n\n        // set legend symbols\n        if (vizConfig.shouldUseUnicode === true) {\n            vizConfig.legendSymbol05 = \'\\u25CE\';\n            vizConfig.legendSymbol01 = \'\\u25C9\';\n            vizConfig.rightArrow = \'\\u25BA\';\n            vizConfig.leftArrow = \'\\u25C4\';\n        } else {\n            vizConfig.legendSymbol05 = \'*\';\n            vizConfig.legendSymbol01 = \'**\';\n            vizConfig.rightArrow = \'>>\';\n            vizConfig.leftArrow = \'<<\';\n        }\n\n        // prepare statements !false sets as default\n        appendNumbersToStatements(outputForDataViz);\n\n        // auto adjust if no card header info\n        var locateStateY;\n        if (vizConfig.shouldShowMatchCounts === true || vizConfig.shouldIndicateDistinguishing) {\n            locateStateY = 40;\n        } else if (vizConfig.shouldIndicateDistinguishing === undefined) {\n            locateStateY = 40;\n        } else {\n            locateStateY = 20;\n        }\n\n        // user trim statements\n        if (vizConfig.shouldTrimStatements === true) {\n            trimStatments(outputForDataViz);\n        }\n\n        // todo - fix so it doesn\'t trigger multiple times\n        if (vizConfig.shouldShowMatchCounts === true || vizConfig.shouldShowBackgroundColor === true) {\n            calcMatchCounts(outputForDataViz);\n        }\n\n        var isNumber = function isNumber(value) {\n            return typeof value === \'number\' &&\n                isFinite(value);\n        };\n\n        function integrateConsensusStatementIndicators() {\n            var consensusStatementArrays = QAV.getState("formattedConsensusStatements");\n            var consensusNums = [];\n            for (var i = 0, iLen = consensusStatementArrays.length; i < iLen; i++) {\n                var testValue = consensusStatementArrays[i]["No."];\n                if (isNumber(testValue)) {\n                    consensusNums.push(testValue);\n                }\n            }\n\n            for (var j = 0, jLen = outputForDataViz.length; j < jLen; j++) {\n                var counter = 0;\n                for (var k = 0, kLen = outputForDataViz[j].length; k < kLen; k++) {\n                    var conStateNum = consensusNums[counter];\n                    if (outputForDataViz[j][k].statement === conStateNum) {\n                        outputForDataViz[j][k].isConsensusState = true;\n                        counter++;\n                    } else {\n                        outputForDataViz[j][k].isConsensusState = false;\n                    }\n                }\n            }\n        }\n        integrateConsensusStatementIndicators();\n\n\n        function setBackgroundColorFill() {\n            var isConsensus, isCaution, matchingCountPercent;\n            var cutoff = vizConfig.backgroundColorCutoff;\n            var caution = Boolean(vizConfig.shouldShowBackgroundColor);\n            var consensus = Boolean(vizConfig.shouldIndicateConsensus);\n\n            // loop through factors, then Q-sorts\n            for (var i = 0, iLen = outputForDataViz.length; i < iLen; i++) {\n                for (var j = 0, jLen = outputForDataViz[0].length; j < jLen; j++) {\n                    isConsensus = outputForDataViz[i][j].isConsensusState;\n                    matchingCountPercent = outputForDataViz[i][j].matchingCountPercent;\n                    if (matchingCountPercent <= cutoff) {\n                        isCaution = true;\n                    } else {\n                        isCaution = false;\n                    }\n\n                    // if user selects both caution and consensus\n                    if (caution === true && consensus === true) {\n                        // and the card shows\n                        if (isConsensus === true && isCaution === true) {\n                            outputForDataViz[i][j].displayFill = overlapIndicator;\n                        } else if (isConsensus === true && isCaution === false) {\n                            outputForDataViz[i][j].displayFill = consensusIndicator;\n                        } else if (isConsensus === false && isCaution === true) {\n                            outputForDataViz[i][j].displayFill = matchCautionIndicator;\n                        } else {\n                            outputForDataViz[i][j].displayFill = \'#ffffff\';\n                        }\n                    } else if (caution === true && consensus === false) {\n                        if (isCaution === true) {\n                            outputForDataViz[i][j].displayFill = matchCautionIndicator;\n                        } else {\n                            outputForDataViz[i][j].displayFill = \'#ffffff\';\n                        }\n                    } else if (caution === false && consensus === true) {\n                        if (isConsensus === true) {\n                            outputForDataViz[i][j].displayFill = consensusIndicator;\n                        } else {\n                            outputForDataViz[i][j].displayFill = \'#ffffff\';\n                        }\n                    } else {\n                        outputForDataViz[i][j].displayFill = \'#ffffff\';\n                    }\n                } // end card loop\n            } // end factor loop\n        } // end function\n\n        if (vizConfig.shouldShowBackgroundColor === true || vizConfig.shouldIndicateConsensus === true) {\n            setBackgroundColorFill();\n        }\n\n        function appendNumbersToStatements(outputForDataViz) {\n            for (var i = 0; i < outputForDataViz.length; i++) {\n                for (var ii = 0; ii < outputForDataViz[i].length; ii++) {\n                    if (vizConfig.shouldShowOnlyStateNo === true) {\n                        outputForDataViz[i][ii].displayStatements = outputForDataViz[i][ii].statement;\n                    } else if (vizConfig.shouldPrependStateNo === false) {\n                        outputForDataViz[i][ii].displayStatements = outputForDataViz[i][ii].sortStatement;\n                    } else {\n                        outputForDataViz[i][ii].displayStatements = outputForDataViz[i][ii].statement + ". " + outputForDataViz[i][ii].sortStatement;\n                    }\n                }\n            }\n            return outputForDataViz;\n        }\n\n        function trimStatments(outputForDataViz) {\n            for (var i = 0; i < outputForDataViz.length; i++) {\n                for (var ii = 0; ii < outputForDataViz[i].length; ii++) {\n                    if (vizConfig.shouldTrimStatements === true) {\n                        var preSubString = outputForDataViz[i][ii].displayStatements;\n                        outputForDataViz[i][ii].displayStatements = preSubString.substring(0, vizConfig.trimStatementSize);\n                    }\n\n\n                }\n            }\n            return outputForDataViz;\n        }\n\n        function calcMatchCounts(outputForDataViz) {\n            var x = 10;\n\n            var data2 = QAV.getState("matchCount");\n\n            for (var i = 0, iLen = userSelectedFactors.length; i < iLen; i++) {\n                var data1 = data2[i];\n                var data = data1.slice(0);\n                data.sort(function (a, b) {\n                    return a.indexer - b.indexer;\n                });\n\n                for (var jj = 0, jjLen = data.length; jj < jjLen; jj++) {\n                    var indexer = data[jj].indexer;\n                    if (indexer === outputForDataViz[i][jj].statement) {\n                        outputForDataViz[i][jj].matchingCount = data[jj].matchingCounts;\n                        outputForDataViz[i][jj].matchingCountPercent = data[jj].matchingCountsPercent;\n                    } else {\n                        console.log("error - statement ordering doesn\'t match");\n                    }\n                }\n                x = x + 3;\n            }\n            QAV.setState("outputForDataViz", outputForDataViz);\n            return outputForDataViz;\n        }\n\n        function findOccurrences(arr, val) {\n            var i,\n                j,\n                count = 0;\n            for (i = 0, j = arr.length; i < j; i++) {\n                if (arr[i] === val) {\n                    count++;\n                }\n            }\n            return count;\n        }\n\n        function getSvgHeight(arr1) {\n            var heightAdjustment = 0;\n            if (vizConfig.shouldIndicateDistinguishing === true) {\n                heightAdjustment = heightAdjustment + 60;\n            }\n            if (vizConfig.shouldShowZscoreArrows === true && vizConfig.shouldIndicateDistinguishing === true) {\n                heightAdjustment = heightAdjustment + 60;\n            }\n            if (vizConfig.shouldIndicateConsensus === true) {\n                heightAdjustment = heightAdjustment + 30;\n            }\n            if (vizConfig.shouldShowZscoreArrows === true) {\n                heightAdjustment = heightAdjustment + 30;\n            }\n            if (vizConfig.shouldShowBackgroundColor === true) {\n                heightAdjustment = heightAdjustment + 30;\n            }\n            if (vizConfig.shouldIndicateConsensus === true && vizConfig.shouldShowBackgroundColor === true) {\n                heightAdjustment = heightAdjustment + 30;\n            }\n\n            vizConfig.heightAdjustment = heightAdjustment;\n\n            var b = [],\n                prev;\n            var arr = _.cloneDeep(arr1);\n            arr.sort();\n            for (var i = 0; i < arr.length; i++) {\n                if (arr[i] !== prev) {\n                    b.push(1);\n                } else {\n                    b[b.length - 1]++;\n                }\n                prev = arr[i];\n            }\n            if (vizConfig.shouldHaveLegend === true) {\n                svgHeightCalc = (((parseInt(elementHeight, 10) + 10) * d3.max(b)) + 160 + heightAdjustment); // plus 150 for legend\n                return svgHeightCalc;\n            } else {\n                svgHeightCalc = (((parseInt(elementHeight, 10) + 10) * d3.max(b)) + 25);\n                return svgHeightCalc; // 25 for the sort values header\n            }\n        }\n\n        // todo - find cause of error with !=\n        function wordwrap(text, max) {\n            var language = QAV.getState("language");\n            var lines = [];\n            var line;\n            if (vizConfig.shouldSetWidthForAsian === true) {\n                max = vizConfig.asianStatmentLength || 12;\n                lines = text.match(new RegExp(\'.{1,\' + max + \'}\', \'g\'));\n            } else {\n                var regex = new RegExp(".{0," + max + "}(?:\\\\s|$)", "g");\n                while ((line = regex.exec(text)) != "") { // DO NOT CHANGE != TO !== - WILL THROW ERROR\n                    lines.push(line);\n                } // end while\n            } // end 294 else\n            return lines;\n        } // end function\n\n        var temp1,\n            k,\n            instances = [];\n        for (k = 0; k < uniques.length; k++) {\n            temp1 = findOccurrences(sortTriangleShape, uniques[k]);\n            instances.push(temp1);\n        }\n\n        // get x position\n        var xPosLoop = [];\n        var counterX = 0;\n        for (var m = 0; m < instances.length; m++) {\n            for (var p = 0; p < instances[m]; p++) {\n                xPosLoop.push(counterX);\n            }\n            counterX = counterX + 1;\n        }\n\n        // get y position\n        var yPosLoop = [];\n        var counterY;\n        for (var r = 0; r < instances.length; r++) {\n            counterY = 0;\n            for (var s = 0; s < instances[r]; s++) {\n                yPosLoop.push(counterY);\n                counterY = counterY + 1;\n            }\n        }\n\n        // legend location\n        var yLegend = ((d3.max(yPosLoop) + 1) * elementHeight) + 50;\n        var xLegendCenterPoint = ((((d3.max(xPosLoop) + 1) * elementWidth) + 20) / 2);\n        var halfLegendWidth = 285;\n\n        // text wrap variables - set in control panel?\n        var maxLength;\n        var newStatementWidth = vizConfig.statementWidth || 6.75;\n        if (vizConfig.shouldSetStatementWidth === true) {\n            maxLength = parseInt(((elementWidth - newStatementWidth) / 6.75), 10);\n        } else {\n            maxLength = parseInt((elementWidth / 6.75), 10);\n        }\n\n        // calc the height of the svg\n        svgHeight = (getSvgHeight(sortTriangleShape) + 15);\n\n        // get Cutoff from state\n        var backgroundColorCutoff = vizConfig.backgroundColorCutoff;\n\n        // adjust if display is only statement numbers\n        var onlyNumbersXAdjustment = 0;\n        if (vizConfig.shouldShowOnlyStateNo === true) {\n            onlyNumbersXAdjustment = 6;\n        }\n\n\n\n\n        /*\n\n\n        BEGIN visualizations calc loop\n\n\n        */\n        // loop through array to draw visualizations   synFactorVizDiv\n        for (var z = 0; z < outputForDataViz.length; z++) {\n\n            var zz = z + 1;\n\n            var factorVizDivName = "factorVizDiv" + zz;\n            $("#synFactorVizDiv")\n                .append("<div id=" + factorVizDivName + "></div>");\n\n            // appending name outside SVG\n            // $("#" + factorVizDivName)\n            //     .append("<h4 class=\'vizTitles\'>" + synFactorVizTitleText + userSelectedFactors[z] + "</h4>");\n\n            var idName = "synSortSvgNo" + zz;\n\n            // add svg\n            var svg = d3\n                .select("#" + factorVizDivName)\n                .append("svg")\n                .attr(\'width\', (containerWidth + 10))\n                .attr(\'height\', svgHeight)\n                .attr(\'id\', idName)\n                .attr(\'class\', "factorViz");\n\n            var textArray1 = outputForDataViz[z];\n\n            // sort by zScore z-score\n            var textArray = textArray1.slice(0);\n            textArray.sort(function (a, b) {\n                if (a.zScore === b.zScore) {\n                    return b.statement - a.statement;\n                } else {\n                    return a.zScore - b.zScore;\n                }\n            });\n\n            // add location data\n            for (var c = 0; c < textArray.length; c++) {\n                textArray[c].xVal = xPosLoop[c];\n                textArray[c].yVal = yPosLoop[c];\n            }\n\n            var index = svg\n                .selectAll("g.node")\n                .data(uniques, function (d) {\n                    return d;\n                });\n\n            var indexGroup = index\n                .enter()\n                .append("g")\n                .attr("class", "node");\n\n            // draw headers    \n            indexGroup\n                .append(\'rect\')\n                .attr(\'width\', elementWidth)\n                .attr(\'height\', \'20\')\n                .attr(\'x\', function (d) {\n                    return ((uniques.indexOf(d) * elementWidth) + 5);\n                })\n                .attr(\'y\', \'45\')\n                .attr(\'fill\', \'white\')\n                .attr(\'stroke\', \'black\');\n\n            // draw column numbers    \n            indexGroup\n                .append(\'text\')\n                .attr(\'x\', function (d) {\n                    return ((uniques.indexOf(d) * elementWidth) + (elementWidth / 2) + 5);\n                })\n                .attr(\'y\', \'58\') // was 16\n                .style(\'text-anchor\', \'middle\')\n                .attr(\'class\', \'headerText\')\n                .attr(\'font-family\', \'Arial\')\n                .attr(\'font-size\', \'14px\')\n                .attr(\'font-weight\', \'bold\')\n                .attr(\'fill\', \'black\')\n                .text(function (d) {\n                    return d;\n                });\n\n            // associate data with identifiers\n            var index2 = svg\n                .selectAll("g.node2")\n                .data(textArray, function (d) {\n                    return d.statement;\n                });\n\n            // append statement rectangles group    \n            var indexGroup2 = index2\n                .enter()\n                .append("g")\n                .attr("class", "node2");\n\n            // Pattern injection\n            var pattern = svg.append("defs")\n                .append("pattern")\n                .attr({\n                    id: "hash4_4",\n                    width: "8",\n                    height: "8",\n                    patternUnits: "userSpaceOnUse",\n                    patternTransform: "rotate(60)"\n                })\n                .append("rect")\n                .attr({\n                    width: "2",\n                    height: "8",\n                    transform: "translate(0,0)",\n                    fill: consensusColor\n                });\n\n            var pattern2 = svg.append("pattern")\n                .append("pattern")\n                .attr({\n                    id: "hash4_4b",\n                    width: "8",\n                    height: "8",\n                    patternUnits: "userSpaceOnUse",\n                    patternTransform: "rotate(135)"\n                })\n                .append("rect")\n                .attr({\n                    width: "2",\n                    height: "8",\n                    transform: "translate(0,0)",\n                    fill: matchCountColor\n                });\n\n            var pattern3 = svg.append("pattern")\n                .append("pattern")\n                .attr({\n                    id: "crosshatch",\n                    width: "8",\n                    height: "8",\n                    patternUnits: "userSpaceOnUse",\n                    patternTransform: "rotate(135)"\n                })\n                .append("rect")\n                .attr({\n                    width: "8",\n                    height: "8",\n                    transform: "translate(0,0)",\n                    fill: "white",\n                    stroke: overlapColor\n                });\n\n            // draw boxes for statements\n            indexGroup2\n                .append(\'rect\')\n                .attr(\'width\', elementWidth)\n                .attr(\'height\', elementHeight)\n                .attr(\'x\', function (d) {\n                    return ((d.xVal * elementWidth) + 5);\n                })\n                .attr(\'y\', function (d) {\n                    return ((d.yVal * elementHeight) + 60);\n                })\n                .attr(\'fill\', function (d) {\n                    if (vizConfig.shouldShowBackgroundColor === true || vizConfig.shouldIndicateConsensus === true) {\n                        return d.displayFill;\n                    } else {\n                        return \'#ffffff\';\n                    }\n                })\n                //.style(\'background-color\', \'#ffffff\');\n                .attr(\'stroke\', \'black\');\n\n            // draw distinguishing statement symbols    \n            if (vizConfig.shouldIndicateDistinguishing !== false) {\n                indexGroup2\n                    .append(\'text\')\n                    .attr(\'width\', elementWidth)\n                    .attr(\'height\', elementHeight)\n                    .attr(\'font-size\', symbolSize)\n                    .attr(\'x\', function (d) {\n                        return ((d.xVal * elementWidth) + 7); // was 5\n                    })\n                    .attr(\'y\', function (d) {\n                        return ((d.yVal * elementHeight) + 75); //was 38\n                    })\n                    .text(function (d) {\n                        return d.sigVisualization;\n                    });\n            }\n            // draw statements\n            indexGroup2\n                .append(\'text\')\n                .attr(\'class\', \'wrap\')\n                .attr(\'font-family\', \'Arial\')\n                .attr(\'font-size\', cardFontSize)\n                .attr(\'x\', function (d) {\n                    return ((d.xVal * elementWidth) + 8);\n                })\n                .attr(\'y\', function (d) {\n                    return ((d.yVal * elementHeight) + locateStateY + 35); // was 25\n                })\n                .attr(\'dy\', 0)\n                .each(function (d) {\n                    var lines = wordwrap(d.displayStatements, maxLength);\n                    for (var iii = 0; iii < lines.length; iii++) {\n                        d3\n                            .select(this)\n                            .append("tspan")\n                            .attr("dy", vSeparation)\n                            .attr(\'text-anchor\', \'middle\')\n                            .attr("x", (d.xVal * elementWidth) + (elementWidth / 2) + onlyNumbersXAdjustment)\n                            .text(lines[iii]);\n                    }\n                });\n\n            if (vizConfig.shouldShowMatchCounts === true) {\n                indexGroup2\n                    .append(\'text\')\n                    .attr(\'font-family\', \'Arial\')\n                    .attr(\'font-size\', cardFontSize)\n                    .attr(\'x\', function (d) {\n                        return ((d.xVal * elementWidth) + (elementWidth * 0.97));\n                    })\n                    .attr(\'y\', function (d) {\n                        return ((d.yVal * elementHeight) + 83); // was 38\n                    })\n                    .style("text-anchor", "end")\n                    .text(function (d) {\n                        return (d.matchingCount + " (" + d.matchingCountPercent + "%)");\n                    });\n            }\n\n            if (vizConfig.shouldHaveLegend === true) {\n\n                var indexGroup3 = svg\n                    .append("g")\n                    .attr("class", "node3");\n\n                indexGroup3\n                    .append(\'rect\')\n                    .attr(\'height\', 50 + vizConfig.heightAdjustment)\n                    .attr(\'width\', 575)\n                    .attr(\'x\', (xLegendCenterPoint - halfLegendWidth))\n                    .attr(\'y\', (yLegend + 35)) // was -5\n                    .attr(\'fill\', \'white\')\n                    .style(\'stroke\', \'black\');\n\n                indexGroup3\n                    .append(\'text\')\n                    //.attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + 20)) // half of legend box width\n                    .attr(\'x\', (xLegendCenterPoint - 8)) // half of legend box width\n                    .attr(\'y\', (yLegend + 80)) // was 30\n                    .attr(\'class\', \'legendHeader\')\n                    .attr(\'font-family\', \'Arial\')\n                    .attr(\'font-size\', \'20px\')\n                    .attr(\'text-anchor\', \'middle\')\n                    //.text(\'Symbol\')\n                    .text(legendTitleText)\n                    .attr(\'font-weight\', \'bold\');\n\n                /*\n                                indexGroup3\n                                    .append(\'text\')\n                                    .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + 100)) // half of legend box width\n                                    .attr(\'y\', (yLegend + 30))\n                                    .attr(\'class\', \'legendHeader\')\n                                    .attr(\'font-family\', \'Arial\')\n                                    .text(\'Interpretation\')\n                                    .attr(\'font-weight\', \'bold\');\n                                    */\n\n                // set X and Y values for legend\n                var symbolY = 80; // was 34\n                var legendTextY = 79; // was 30\n                var legendSymbolX = 40;\n                var legendTextX = 80;\n\n                // symbols  - !==false is to set as default\n                if (vizConfig.shouldIndicateDistinguishing === true) {\n                    symbolY = symbolY + 28;\n                    indexGroup3\n                        .append(\'text\')\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendSymbolX))\n                        .attr(\'y\', (yLegend + symbolY))\n                        .attr(\'font-size\', symbolSize)\n                        .text(vizConfig.legendSymbol05);\n\n                    symbolY = symbolY + 30;\n\n                    indexGroup3\n                        .append(\'text\')\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendSymbolX))\n                        .attr(\'y\', (yLegend + symbolY))\n                        .attr(\'font-size\', symbolSize)\n                        .text(vizConfig.legendSymbol01);\n                }\n\n                if (vizConfig.shouldShowZscoreArrows === true && vizConfig.shouldIndicateDistinguishing === true) {\n                    symbolY = symbolY + 30;\n                    indexGroup3\n                        .append(\'text\')\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendSymbolX))\n                        .attr(\'y\', (yLegend + symbolY))\n                        .attr(\'font-size\', symbolSize)\n                        .text(vizConfig.rightArrow);\n\n                    symbolY = symbolY + 30;\n                    indexGroup3\n                        .append(\'text\')\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendSymbolX))\n                        .attr(\'y\', (yLegend + symbolY))\n                        .attr(\'font-size\', symbolSize)\n                        .text(vizConfig.leftArrow);\n                }\n\n                if (vizConfig.shouldIndicateConsensus === true) {\n                    symbolY = symbolY + 12;\n                    indexGroup3\n                        .append(\'rect\')\n                        .attr(\'height\', 20)\n                        .attr(\'width\', 20)\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendSymbolX - 2))\n                        .attr(\'y\', (yLegend + symbolY))\n                        .attr(\'fill\', consensusIndicator)\n                        .style(\'stroke\', \'black\');\n                    symbolY = symbolY + 18;\n                }\n\n                if (vizConfig.shouldShowBackgroundColor === true) {\n                    symbolY = symbolY + 12;\n                    indexGroup3\n                        .append(\'rect\')\n                        .attr(\'height\', 20)\n                        .attr(\'width\', 20)\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendSymbolX - 2))\n                        .attr(\'y\', (yLegend + symbolY))\n                        .attr(\'fill\', matchCautionIndicator)\n                        .style(\'stroke\', \'black\');\n                    symbolY = symbolY + 18;\n                }\n\n                if (vizConfig.shouldShowBackgroundColor === true && vizConfig.shouldIndicateConsensus === true) {\n                    symbolY = symbolY + 12;\n                    indexGroup3\n                        .append(\'rect\')\n                        .attr(\'height\', 20)\n                        .attr(\'width\', 20)\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendSymbolX - 2))\n                        .attr(\'y\', (yLegend + symbolY))\n                        .attr(\'fill\', overlapIndicator)\n                        .style(\'stroke\', \'black\');\n                    symbolY = symbolY + 18;\n                }\n\n                // if (shouldindi)\n\n                // interpretation text\n                if (vizConfig.shouldIndicateDistinguishing === true) {\n                    legendTextY = legendTextY + 30;\n                    indexGroup3\n                        .append(\'text\')\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendTextX))\n                        .attr(\'y\', (yLegend + legendTextY))\n                        .attr(\'font-family\', \'Arial\')\n                        .text(disting05LegendText);\n\n                    legendTextY = legendTextY + 30;\n                    indexGroup3\n                        .append(\'text\')\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendTextX))\n                        .attr(\'y\', (yLegend + legendTextY))\n                        .attr(\'font-family\', \'Arial\')\n                        .text(disting01LegendText);\n                }\n                if (vizConfig.shouldShowZscoreArrows === true && vizConfig.shouldIndicateDistinguishing === true) {\n                    legendTextY = legendTextY + 30;\n                    indexGroup3\n                        .append(\'text\')\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendTextX))\n                        .attr(\'y\', (yLegend + legendTextY))\n                        .attr(\'font-family\', \'Arial\')\n                        .text(zscoreHigherLegendText);\n\n                    legendTextY = legendTextY + 30;\n                    indexGroup3\n                        .append(\'text\')\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendTextX))\n                        .attr(\'y\', (yLegend + legendTextY))\n                        .attr(\'font-family\', \'Arial\')\n                        .text(zscoreLowerLegendText);\n                }\n                if (vizConfig.shouldIndicateConsensus === true) {\n                    legendTextY = legendTextY + 30;\n                    indexGroup3\n                        .append(\'text\')\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendTextX))\n                        .attr(\'y\', (yLegend + legendTextY))\n                        .attr(\'font-family\', \'Arial\')\n                        .text(consensusLegendText);\n                }\n\n                if (vizConfig.shouldShowBackgroundColor === true) {\n                    legendTextY = legendTextY + 30;\n                    indexGroup3\n                        .append(\'text\')\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendTextX))\n                        .attr(\'y\', (yLegend + legendTextY))\n                        .attr(\'font-family\', \'Arial\')\n                        .text(matchingCountLegendText + " " + vizConfig.backgroundColorCutoff + \'%)\');\n                }\n                if (vizConfig.shouldShowBackgroundColor === true && vizConfig.shouldIndicateConsensus === true) {\n                    legendTextY = legendTextY + 30;\n                    indexGroup3\n                        .append(\'text\')\n                        .attr(\'x\', ((xLegendCenterPoint - halfLegendWidth) + legendTextX))\n                        .attr(\'y\', (yLegend + legendTextY))\n                        .attr(\'font-family\', \'Arial\')\n                        .text(overlapLegendText);\n                }\n            } // end of should have legend\n\n            // add Factor Names inside SVG\n            var newText;\n            if (vizConfig.addCustomFactorName === true && vizConfig.customFactorNames[z]) {\n                newText = vizConfig.customFactorNames[z];\n            } else {\n                var capitalizedFactorName = userSelectedFactors[z].charAt(0).toUpperCase() + userSelectedFactors[z].slice(1);\n                newText = synFactorVizTitleText + capitalizedFactorName;\n            }\n            svg.append(\'text\')\n                .attr(\'x\', 5)\n                .attr(\'y\', 28)\n                .attr(\'font-family\', \'Arial\')\n                .attr(\'font-size\', \'30px\')\n                .attr(\'fill\', \'black\')\n                .text(newText);\n\n\n            var thisFactorName = userSelectedFactors[z].replace(/\\s/g, \'\');\n            var downloadText = resources[language].translation.downloadImage;\n            var $thisSvg = $("#" + factorVizDivName);\n            $thisSvg.append(\'<input class="svgDownloadButton blackHover" name="downloadButton" id="\' + thisFactorName + \'Image"   type="button" value="\' + userSelectedFactors[z] + downloadText + \'" />\');\n            $thisSvg.append(\'<input class="pngDownloadButton blackHover" name="downloadPngButton" id="\' + thisFactorName + \'PngImage"   type="button" value="\' + userSelectedFactors[z] + \' - Download image as PNG\' + \'" />\');\n        } // end z loop to add visualizations\n\n        $(\'.svgDownloadButton\')\n            .on(\'mousedown\', function (event) {\n                var vizConfig = QAV.getState("vizConfig") || {};\n                var shouldAddName = vizConfig.shouldAddCustomName;\n                var svgId = $(this)\n                    .parent()\n                    .find("svg")\n                    .attr(\'id\');\n                var arrayIndexNumber = (svgId.slice(-1) - 1);\n                var factorName = userSelectedFactors[arrayIndexNumber];\n                var cleanFactorName = factorName.replace(/\\s+/g, \'\');\n                var date = UTIL.currentDate1();\n                var time = UTIL.currentTime1();\n                var dateTime = date + "_" + time;\n                var projectName = QAV.getState("qavProjectName");\n                var customName = vizConfig.customName;\n                if (shouldAddName === true) {\n                    if (vizConfig.customNameLocation === "prepend") {\n                        config = {\n                            filename: customName + "_" + projectName + "_" + cleanFactorName + "_" + dateTime\n                        };\n                    } else if (vizConfig.customNameLocation === "append") {\n                        config = {\n                            filename: projectName + "_" + cleanFactorName + "_" + dateTime + "_" + customName\n                        };\n                    } else if (vizConfig.customNameLocation === "replace") {\n                        config = {\n                            filename: customName\n                        };\n                    } else {\n                        config = {\n                            filename: projectName + "_" + cleanFactorName + "_" + dateTime\n                        };\n                    }\n                } else {\n                    config = {\n                        filename: projectName + "_" + cleanFactorName + "_" + dateTime\n                    };\n                }\n                d3_save_svg.save(d3.select(\'#\' + svgId)\n                    .node(), config);\n            });\n\n        $(\'.pngDownloadButton\')\n            .on(\'mousedown\', function (event) {\n                var nameConfig;\n                var vizConfig = QAV.getState("vizConfig") || {};\n                var shouldAddName = vizConfig.shouldAddCustomName;\n                console.log(shouldAddName);\n                var svgId = $(this)\n                    .parent()\n                    .find("svg")\n                    .attr(\'id\');\n                var arrayIndexNumber = (svgId.slice(-1) - 1);\n                var factorName = userSelectedFactors[arrayIndexNumber];\n                var cleanFactorName = factorName.replace(/\\s+/g, \'\');\n                var date = UTIL.currentDate1();\n                var time = UTIL.currentTime1();\n                var dateTime = date + "_" + time;\n                var projectName = QAV.getState("qavProjectName");\n                var customName = vizConfig.customName;\n                console.log(customName);\n                if (shouldAddName === true) {\n                    if (vizConfig.customNameLocation === "prepend") {\n                        nameConfig = customName + "_" + projectName + "_" + cleanFactorName;\n                    } else if (vizConfig.customNameLocation === "append") {\n                        nameConfig = projectName + "_" + cleanFactorName + "_" + customName;\n                    } else if (vizConfig.customNameLocation === "replace") {\n                        nameConfig = customName;\n                    } else {\n                        nameConfig = projectName + "_" + cleanFactorName;\n                    }\n                } else {\n                    nameConfig = projectName + "_" + cleanFactorName;\n                }\n\n                var svgString = UTIL.getSVGString(d3.select(\'#\' + svgId)\n                    .node());\n                var svgCharacteristics = d3.select(\'#\' + svgId);\n                // var width = parseInt(thisSvgCharacteristics.style("width"), 10) + 2;\n                // var height = parseInt(thisSvgCharacteristics.style("height"), 10);\n                UTIL.downloadPngImages(svgString, svgCharacteristics, nameConfig); // passes Blob and filesize \n            });\n\n\n        PRELIMOUT.showPreliminaryOutput1b();\n    };\n\n\n\n    // ************************************************************************  view\n    // ******  Preliminary Results 1b - draw factor score correlations table  ********\n    // ******************************************************************************\n    PRELIMOUT.showPreliminaryOutput1b = function () {\n        var language = QAV.getState("language");\n        var headerText = resources[language].translation["Factor score correlations"];\n\n        // add factor correlations and loadings tables\n        $("#factorCorrelationTableTitle").append("<h4>" + headerText + "</h4>");\n\n        //  todo - fix ordering error of factors - use large demo set with 7 factors to see error and reduce appends to only one\n\n        $("#factorCorrelationTableDiv").append(\'<table id="factorCorrelationTable" class="display compact nowrap cell-border stripe"></table>\');\n\n        // var data = QAV.getState("outputSpreadsheetArray");\n\n        // var newData = data[6];\n\n        var newData = QAV.getState("correlationTableArrayHolder");\n\n\n        //        var columnHeadersArray = data[5][0];\n        var columnHeadersArray = newData[0];\n        var columnHeaders = [];\n        for (var i = 0; i < columnHeadersArray.length; i++) {\n            var tempObj = {};\n            tempObj.title = columnHeadersArray[i];\n            tempObj.class = "dt-head-center dt-body-right";\n            columnHeaders.push(tempObj);\n        }\n\n        columnHeaders[0].class = "dt-head-center dt-body-center";\n\n        newData.shift();\n\n        $("#factorCorrelationTable").DataTable({\n            "retrieve": true,\n            "searching": false,\n            "ordering": false,\n            "info": false,\n            "scrollY": 350,\n            "scrollCollapse": false,\n            "scrollX": false,\n            "paging": false,\n            "data": newData,\n            "columns": columnHeaders\n        });\n\n        var table = $(\'#factorCorrelationTable\').DataTable();\n        var lastIdx = null;\n        $(\'#factorCorrelationTable tbody\').on(\'mouseover\', \'td\', function () {\n                var colIdx = table\n                    .cell(this)\n                    .index()\n                    .column;\n                if (colIdx !== lastIdx) {\n                    $(table.cells().nodes()).removeClass(\'highlight\');\n                    $(table.column(colIdx).nodes()).addClass(\'highlight\');\n                }\n            })\n            .on(\'mouseleave\', function () {\n                $(table.cells().nodes()).removeClass(\'highlight\');\n            });\n        showPreliminaryOutput2();\n    };\n\n    // **********************************************************************  view\n    // ******  Preliminary Results 2 - draw factor score tables  ******************\n    // ****************************************************************************\n\n    // todo - use document fragment to get rid of all these appends\n\n    function showPreliminaryOutput2() {\n\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n\n        //  todo - fix ordering error of factors - use large demo set with 7 factors to see error\n        //var data = QAV.getState("outputSpreadsheetArray");\n\n\n        var language = QAV.getState("language");\n        var chartText1 = resources[language].translation["Flagged q - sort weights"];\n        var chartText2 = resources[language].translation["Flagged q-sort correlations"];\n        var chartText3 = resources[language].translation["Z-scores, sort values, raw sorts"];\n        var chartText4 = resources[language].translation["Statement Number"];\n        var chartText5 = resources[language].translation.Statement;\n        var chartText6 = resources[language].translation["Z-score"];\n        var chartText7 = resources[language].translation["Sort Values"];\n        var chartText8 = resources[language].translation.Weight;\n\n        var factorWeightFactorArray = QAV.getState("factorWeightFactorArrayHolder");\n        var miniCorrelationArray = QAV.getState("miniCorrelationArrayHolder");\n        var synFactorArray1 = QAV.getState("synFactorArray1Holder");\n\n\n        // START FOR EACH FACTOR LOOP\n        for (var j = 0; j < userSelectedFactors.length; j++) {\n\n            var factorNumber = j + 1;\n\n            var factorH4Label = _.capitalize(userSelectedFactors[j]);\n\n            $("#factorTables").append(\'<div class="resultsLabel1"><h4>\' + factorH4Label + \' - \' + chartText1 + \'</h4></div><table id="factorWeightResults\' + factorNumber + \'" class="display compact nowrap cell-border stripe"></table>\');\n\n            var newWeightData = factorWeightFactorArray[j];\n            newWeightData.shift();\n            var weightColumnHeaders = [{\n                title: "Q-Sort",\n                class: "dt-head-center dt-body-center"\n            }, {\n                title: chartText8,\n                class: "dt-head-center dt-body-center"\n            }];\n\n            $("#factorWeightResults" + factorNumber).DataTable({\n                "retrieve": true,\n                "searching": false,\n                "ordering": true,\n                "order": [\n                    [1, "desc"]\n                ],\n                "info": false,\n                "scrollY": 800,\n                "scrollCollapse": true,\n                "scrollX": true,\n                "paging": false,\n                "data": newWeightData,\n                "columns": weightColumnHeaders,\n                "columnDefs": [{\n                    targets: [0],\n                    className: \'dt-body-center dt-body-name\'\n                }, {\n                    targets: \'_all\',\n                    "createdCell": function (td, cellData, rowData, row, col) {\n                        if (cellData < 0) {\n                            $(td).css(\'color\', \'red\');\n                        }\n                    }\n                }]\n            });\n\n            $("#factorTables").append(\'<div class="resultsLabel1"><h4>\' + factorH4Label + \' - \' + chartText2 + \'</h4></div><table id="factorMiniCorrelResults\' + factorNumber + \'" class="display compact nowrap cell-border stripe"></table>\');\n\n            var newMiniCorrData = miniCorrelationArray[j];\n            var miniCorrColumnHeaders = [{\n                title: "Q-Sort",\n                class: "dt-head-center dt-body-center"\n            }];\n\n            for (var k = 1; k < newMiniCorrData[0].length; k++) {\n                var tempObjMC = {};\n                tempObjMC.title = newMiniCorrData[0][k];\n                tempObjMC.class = "dt-head-center dt-body-center";\n                miniCorrColumnHeaders.push(tempObjMC);\n            }\n\n            newMiniCorrData.shift();\n\n            $("#factorMiniCorrelResults" + factorNumber).DataTable({\n                "retrieve": true,\n                "searching": false,\n                "ordering": false,\n                "info": false,\n                "scrollY": 800,\n                "scrollCollapse": true,\n                "scrollX": true,\n                "paging": false,\n                "data": newMiniCorrData,\n                "columns": miniCorrColumnHeaders,\n                "columnDefs": [{\n                    targets: [0],\n                    className: \'dt-body-center dt-body-name\'\n                }, {\n                    targets: \'_all\',\n                    "createdCell": function (td, cellData, rowData, row, col) {\n                        if (cellData < 0) {\n                            $(td).css(\'color\', \'red\');\n                        }\n                    }\n                }]\n            });\n\n            $("#factorTables").append(\'<div class="resultsLabel1"><h4>\' + factorH4Label + \' - \' + chartText3 + \'</h4></div><table id="prelimResults\' + factorNumber + \'" class="display compact nowrap cell-border stripe"></table>\');\n\n            var newData = synFactorArray1[j];\n\n            // resort back to high to low z-score sort\n            newData\n                .sort(function (a, b) {\n                    if (b[chartText6] === a[chartText6]) {\n                        return a[chartText4] - b[chartText4];\n                    } else {\n                        return b[chartText6] - a[chartText6];\n                    }\n                });\n\n            var columnHeadersArray = Object.keys(newData[0]);\n\n            // the set leftmost 4 columns\n            var columnHeaders = [{\n                title: chartText4,\n                class: "dt-head-center dt-body-center",\n                "data": chartText4\n            }, {\n                title: chartText5,\n                class: "dt-head-center dt-body-left",\n                "data": chartText5\n            }, {\n                "data": chartText6,\n                title: chartText6,\n                class: "dt-head-center dt-body-right"\n            }, {\n                title: chartText7,\n                class: "dt-head-center dt-body-center",\n                "data": chartText7\n            }];\n            // looping in all of the raw sort column headers\n            for (var i = 4; i < columnHeadersArray.length; i++) {\n                var tempObj = {};\n                tempObj.title = columnHeadersArray[i];\n                tempObj.class = "dt-head-center dt-body-center";\n                tempObj.data = columnHeadersArray[i];\n                columnHeaders.push(tempObj);\n            }\n\n            $("#prelimResults" + factorNumber).DataTable({\n                "fixedColumns": {\n                    leftColumns: 1\n                },\n                "retrieve": true,\n                "searching": false,\n                "ordering": true,\n                "order": false,\n                "info": false,\n                "scrollY": 800,\n                "scrollCollapse": true,\n                "scrollX": true,\n                "paging": false,\n                "data": newData,\n                "columns": columnHeaders\n            });\n\n        }\n    }\n\n    // **********************************************************************  view\n    // ******  dynamicallly append checkboxs to select factors for analysis *******\n    // ****************************************************************************\n    PRELIMOUT.appendFactorSelectionCheckboxes = function () {\n\n        var hasSplitFactor = QAV.getState("hasSplitFactor");\n        var j,\n            len,\n            k,\n            temp5,\n            pcaFactorLabels = [];\n        // read in factor labels to generate checkboxes (and checking for split factor)\n        var factorsToSelect;\n\n        var loopLen;\n        loopLen = QAV.getState("numFactorsRetained");\n\n        if (hasSplitFactor > 0) {\n\n            var headers = QAV.getState("factorLabels");\n            var i,\n                temp1,\n                temp3;\n            factorsToSelect = [];\n\n            headers.shift();\n            headers.shift();\n            headers.shift();\n            headers.pop();\n\n            for (i = 0; i < headers.length; i++) {\n                temp1 = headers[i].title;\n                if (temp1 !== "flag") {\n                    temp3 = temp1.replace(/Ftr/g, \'Factor\');\n                    factorsToSelect.push(temp3);\n                }\n            }\n            loopLen = factorsToSelect.length;\n\n        } else {\n\n            if (QAV.typeOfFactor === "PCA") {\n                for (k = 0, len = QAV.numFactorsRetained; k < len; k++) {\n                    temp5 = "factor " + (k + 1);\n                    pcaFactorLabels.push(temp5);\n                }\n\n                factorsToSelect = pcaFactorLabels;\n            } else {\n\n                factorsToSelect = QAV.getState("factorLabels");\n                if (factorsToSelect[0] === "") {\n                    factorsToSelect.shift();\n                }\n            }\n        }\n\n        QAV.setState("factorLabelsArray", factorsToSelect);\n\n        // check to see if checkboxes are already appended, and if so remove them\n        VIEW.removeOutputFactorCheckboxes();\n\n        //  generate and append checkboxes\n        for (j = 0; j < loopLen; j++) {\n\n            var checkbox = document.createElement(\'input\');\n            checkbox.type = "checkbox";\n            checkbox.name = "analysisFactors";\n            checkbox.className = "factorSelectBox";\n            checkbox.value = "value";\n            checkbox.id = factorsToSelect[j];\n\n            var label = document.createElement(\'label\');\n            label.htmlFor = factorsToSelect[j];\n            label.classList.add("checkboxLabel");\n            label.appendChild(document.createTextNode(factorsToSelect[j]));\n            document\n                .getElementById("selectFactorsForOutputDiv")\n                .appendChild(checkbox);\n            document\n                .getElementById("selectFactorsForOutputDiv")\n                .appendChild(label);\n        }\n    };\n\n\n    // *****************************************************************************  \n    // **************  pull user-selected factors for analysis *********************\n    // *****************************************************************************\n\n    PRELIMOUT.getFactorsForAnalysis = function () {\n        var checkboxes = document.getElementsByName(\'analysisFactors\');\n        var vals = [];\n        for (var i = 0; i < checkboxes.length; i++) {\n            if (checkboxes[i].checked) {\n                vals.push(checkboxes[i].id);\n            }\n        }\n        QAV.setState("userSelectedFactors", vals);\n    };\n\n    // *********************************************************************  model\n    // **************  pull loadings that have been flagged  **********************\n    // ****************************************************************************\n\n    PRELIMOUT.pullFlaggedFactorLoadings = function () {\n        var numberFactorsExtracted = parseInt(QAV.getState("numberFactorsExtracted"));\n        var results = QAV.getState("results");\n        var jLoopLen = (numberFactorsExtracted * 2) + 3;\n        var significantLoadingsArray = [];\n        var i,\n            j;\n        var isLoadingSignificant,\n            factorNumber,\n            respondentName,\n            factorLoading;\n        // todo check to see if this can be removed see bind dump button function\n        var iLoopLen = results.length;\n        var factorLabelsArray = QAV.getState("factorLabelsArray");\n        var loadingSortCheckArray = [];\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n\n        // loop thru results array to find user-selected factor loadings\n        for (i = 0; i < iLoopLen; i++) {\n            var factorNumberCount = 0;\n\n            var tempArray = [];\n            for (j = 4; j < jLoopLen; j += 2) {\n                isLoadingSignificant = results[i][j];\n                factorNumber = factorLabelsArray[factorNumberCount];\n                factorNumberCount = factorNumberCount + 1;\n                respondentName = results[i][1];\n                factorLoading = results[i][j - 1];\n\n                // if flagged and in a user-selected factor\n                if (isLoadingSignificant === "true" && (userSelectedFactors.indexOf(factorNumber) > -1)) {\n                    tempArray.push(factorNumber, respondentName, factorLoading);\n                    loadingSortCheckArray.push(factorNumber);\n                }\n            }\n            if (tempArray.length === 0) {\n                tempArray.push(99, respondentName, "Unique Sort");\n                significantLoadingsArray.push(tempArray);\n            } else {\n                significantLoadingsArray.push(tempArray);\n            }\n        }\n\n        // check for sorts flagged for more than one factor user error\n        var multipleFlags;\n        var problemSort;\n        for (var k = 0; k < significantLoadingsArray.length; k++) {\n\n            var test = significantLoadingsArray[k];\n\n            if (test.length > 3) {\n                problemSort = significantLoadingsArray[k][1];\n                multipleFlags = false;\n            }\n        }\n\n        // check for user-selected factors with no loading sorts user error\n        var loadingSortCheck = $(userSelectedFactors)\n            .not(loadingSortCheckArray)\n            .length === 0;\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation["The sort for respondent"];\n        var appendText2 = resources[language].translation["is flagged for more than one factor"];\n\n        if (loadingSortCheck === false) {\n            VIEW.showNoSortsFlaggedOnFactorModal();\n            // prevent display output of factors\n            return "false";\n\n        } else if (multipleFlags === false) {\n            $("#multipleFlagModalMessageDiv p").remove();\n            $("#multipleFlagModalMessageDiv").append("<p>" + appendText1 + problemSort + appendText2 + "</p>");\n            VIEW.showSortFlaggedOnMultipleFactorsModal();\n            return "false";\n        } else {\n            significantLoadingsArray\n                .sort(function (a, b) {\n                    if (a[0] < b[0]) {\n                        return -1;\n                    }\n                    if (a[0] > b[0]) {\n                        return 1;\n                    }\n                    return 0;\n                });\n            computeFactorWeights(significantLoadingsArray);\n        }\n    };\n\n    function computeFactorWeights(significantLoadingsArray) {\n        // source code line 4440\n\n        for (var i = 0; i < significantLoadingsArray.length; i++) {\n            var f = evenRound((significantLoadingsArray[i][2]), 8);\n            var f2 = evenRound((f * f), 8);\n            var oneMinusF2,\n                w;\n            if (f2 === 1) {\n                oneMinusF2 = f2;\n                w = evenRound((f / oneMinusF2), 8);\n            } else if (f2 > 1) {\n                oneMinusF2 = evenRound((1 - f2), 8);\n                w = evenRound((f / -oneMinusF2), 8);\n            } else {\n                oneMinusF2 = evenRound((1 - f2), 8);\n                w = evenRound((f / oneMinusF2), 8);\n            }\n            significantLoadingsArray[i].push(w);\n        }\n        QAV.setState("sortWeights", significantLoadingsArray);\n\n        findLargestFactorWeights(significantLoadingsArray);\n    }\n\n    // create array of highest values to use later for calcuations\n    function findLargestFactorWeights(significantLoadingsArray) {\n\n        // remove unique sorts (value 99) from array\n        var factorSelect = _.filter(significantLoadingsArray, function (n) {\n            return n[0] !== 99;\n        });\n\n        // pull out just factor number and W value to array\n        var factorNumbersArray2 = [];\n        var factorNumbersArray = [];\n        _(factorSelect).forEach(function (n) {\n            var tempArray = [];\n            var factorNumber = n[0];\n            factorNumbersArray2.push(factorNumber);\n            var factorWeightW = n[3];\n            tempArray[0] = factorNumber;\n            tempArray[1] = factorWeightW;\n            factorNumbersArray.push(tempArray);\n        }).value();\n\n        var sigArray = _.cloneDeep(factorNumbersArray2);\n\n        // get unique array of significant factors labels\n        var sigFactorNumbersArray = _.uniq(sigArray);\n\n        var maxFactorValuesArray = [];\n        var factorValue = 0;\n        _(sigFactorNumbersArray).forEach(function () {\n            var temp = _(factorNumbersArray).filter(function (j) {\n                return j[0] === sigArray[factorValue];\n            });\n\n            var tempArray2 = [];\n            var maxFactorLoadings = _(temp).forEach(function (q) {\n                var tempVar3 = evenRound((Math.abs(1 / q[1])), 8);\n                tempArray2.push(tempVar3);\n            }).value();\n\n            // numbers inverted, so using min rather max somewhere else\n            var maxFactorValue = _.min(tempArray2);\n\n            maxFactorValuesArray.push(maxFactorValue);\n\n            factorValue = factorValue + 1;\n        }).value();\n\n        // array\n        QAV.setState("sigFactorNumbersArray", sigFactorNumbersArray);\n\n        // highest values\n        weightFactorScores(significantLoadingsArray, sigFactorNumbersArray, maxFactorValuesArray);\n    }\n\n    function weightFactorScores(significantLoadingsArray, sigFactorNumbersArray, maxFactorValuesArray) {\n        // produces array with factor number, flagged respondent name, and 2 weight values\n        var significantFactors = [];\n        for (var j = 0, jLen = sigFactorNumbersArray.length; j < jLen; j++) {\n            for (var k = 0; k < significantLoadingsArray.length; k++) {\n                var temp1 = significantLoadingsArray[k][0];\n                var temp2 = sigFactorNumbersArray[j];\n                if (temp1 === temp2) {\n                    var divisor = maxFactorValuesArray[j];\n                    significantLoadingsArray[k][3] = evenRound((significantLoadingsArray[k][3] * divisor), 8) * 10;\n                    significantFactors.push(significantLoadingsArray[k]);\n                }\n            }\n        }\n        weightRawSorts(significantFactors);\n    }\n\n    function weightRawSorts(significantFactors) {\n        // produces MD array with factor number, flagged respondent, weighted values for each statement (for each flagged respondent)\n        var respondentNames = QAV.getState("qavRespondentNames");\n        var rawSorts = QAV.getState("positiveShiftedRawSorts");\n        var weightedSorts = [];\n        // normalize weights by sort\n        var normalizedSorts = [];\n        for (var s = 0, sLen = rawSorts.length; s < sLen; s++) {\n            var tempArray2a = [];\n            var sortAverage = UTIL.average(rawSorts[s]);\n            var sortStandardDeviation = UTIL.standardDeviation(rawSorts[s]);\n            for (var r = 0, rLen = rawSorts[s].length; r < rLen; r++) {\n                var zScore = evenRound(((rawSorts[s][r] - sortAverage) / sortStandardDeviation), 3);\n                tempArray2a.push(zScore);\n            }\n            normalizedSorts.push(tempArray2a);\n        }\n        var rawSortsPrep = _.zip(respondentNames, normalizedSorts);\n\n        // multiply normaized sorts by weighting value\n        for (var i = 0, iLen = significantFactors.length; i < iLen; i++) {\n            for (var j = 0, jLen = rawSortsPrep.length; j < jLen; j++) {\n                var temp1 = significantFactors[i][1];\n                var temp2 = rawSortsPrep[j][0];\n                var temp3 = rawSortsPrep[j][1];\n                var temp4 = significantFactors[i][3];\n                var tempArray = [];\n                if (temp1 === temp2) {\n                    var newWeightedSort = _.map(temp3, roundNumbers);\n                    // push factor number\n                    tempArray.push(significantFactors[i][0]);\n                    // push respondent name\n                    tempArray.push(temp1);\n                    tempArray.push(newWeightedSort);\n                    weightedSorts.push(tempArray);\n                }\n            }\n        }\n        combineWeightedSorts(weightedSorts);\n\n        function roundNumbers(n) {\n            var temp5 = evenRound((n * temp4), 8);\n            return temp5;\n        }\n    }\n\n    function combineWeightedSorts(weightedSorts) {\n        var sigFactorNumbersArray1 = QAV.getState("sigFactorNumbersArray");\n        var sigFactorNumbersArray = sigFactorNumbersArray1.sort();\n        var tempArray2,\n            summedWeightedSorts;\n\n        summedWeightedSorts = [];\n        var sigSortsArray = [];\n\n        // looping through all selected factor names in sig factor array\n        for (var i = 0, iLen = sigFactorNumbersArray.length; i < iLen; i++) {\n            var tempArray4 = [];\n            var tempArray1 = [];\n            var factor = sigFactorNumbersArray[i];\n            tempArray2 = [];\n            var tempObj2 = {};\n\n            // loop through all data for all factors and pull data for only for selected factors\n            for (var j = 0, jLen = weightedSorts.length; j < jLen; j++) {\n                var temp2 = weightedSorts[j][0]; // gives number 1 or 2 or 3 etc...\n                if (temp2 === factor) {\n                    tempArray1.push(weightedSorts[j][2]); // pushes weight for each statement\n                    tempArray2.push(weightedSorts[j][1]); // pushes flagged sort respondent name\n                }\n            }\n\n            // pushes factor numbers and representative sorts into array\n            tempArray4.push(factor); // array of names of user selected factors\n            tempArray4.push(tempArray2); // array of flagged respondent names\n\n            // converts array of factor numbers and rep sorts to object\n            tempObj2["Factor Number"] = factor;\n            tempObj2.SigSorts = tempArray2;\n            sigSortsArray.push(tempObj2);\n\n            // summing weights for statements across flagged sorts for each factor\n            var tempArray3 = [];\n            for (var k = 0, kLen = tempArray1[0].length; k < kLen; k++) {\n                var temp3 = 0;\n                for (var m = 0, mLen = tempArray1.length; m < mLen; m++) {\n                    temp3 = evenRound((temp3 + tempArray1[m][k]), 3);\n                }\n                tempArray3.push(temp3);\n            }\n\n            // re-normalize factor loadings after summing across statements\n            var tempArray3a = [];\n            var sortAverage = UTIL.average(tempArray3);\n            var sortStandardDeviation = UTIL.standardDeviation(tempArray3);\n            for (var r = 0, rLen = tempArray3.length; r < rLen; r++) {\n                var zScore = evenRound(((tempArray3[r] - sortAverage) / sortStandardDeviation), 3);\n                tempArray3a.push(zScore);\n            }\n            tempArray4.push(tempArray3a);\n            summedWeightedSorts.push(tempArray4);\n        }\n        QAV.setState("sigSortsArray", sigSortsArray);\n        calculateZScores(summedWeightedSorts);\n    }\n\n    function calculateZScores(summedWeightedSorts) {\n        // changing format from MD array to array of objects\n        // add in statements\n        var statements = QAV.getState("qavCurrentStatements");\n        var sigFactorNumbersArray = QAV.getState("sigFactorNumbersArray");\n        // so that the diff 2 factors output is correct\n        sigFactorNumbersArray.sort();\n        var length = summedWeightedSorts.length;\n        var zScoreArray = [];\n\n        for (var i = 0; i < length; i++) {\n            var zScoreTempObj = {};\n            zScoreTempObj.factor = sigFactorNumbersArray[i];\n            var tempArray1 = [];\n            var zScoreTempArray = [];\n            for (var j = 0; j < summedWeightedSorts[0][2].length; j++) {\n                var tempObj = {};\n                var zScore = evenRound((summedWeightedSorts[i][2][j]), 3);\n\n                tempObj.factor = sigFactorNumbersArray[i];\n                tempObj.statement = (j + 1);\n                tempObj.sortStatement = statements[j];\n                tempObj.zScore = zScore;\n\n                zScoreTempArray.push(zScore);\n                tempArray1.push(tempObj);\n            }\n            zScoreArray.push(tempArray1);\n            zScoreTempObj["FactorZscores" + sigFactorNumbersArray[i]] = zScoreTempArray;\n        }\n        assignFactorScores(zScoreArray);\n    }\n\n    function assignFactorScores(zScoreArray) {\n        var qavSortTriangleShape = QAV.getState("qavSortTriangleShape");\n        var sortedZScoreArray = [];\n        for (var i = 0; i < zScoreArray.length; i++) {\n            var factorNumbers = zScoreArray[i];\n\n            var temp1 = _.cloneDeep(factorNumbers);\n\n            temp1.sort(function (a, b) {\n                if (a.zScore === b.zScore) {\n                    return b.statement - a.statement;\n                } else {\n                    return a.zScore - b.zScore;\n                }\n            });\n\n            for (var j = 0; j < qavSortTriangleShape.length; j++) {\n                temp1[j].sortValue = qavSortTriangleShape[j];\n                temp1[j].sigVisualization = "";\n            }\n            temp1.sort(function (a, b) {\n                return a.statement - b.statement;\n            });\n            sortedZScoreArray.push(temp1);\n        }\n        QAV.setState("analysisOutput", sortedZScoreArray);\n    }\n\n}(window.PRELIMOUT = window.PRELIMOUT || {}, QAV));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUFJFTElNT1VULmpzP2NlZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQHByZXNlcnZlXG5LZW4tUSBBbmFseXNpc1xuQ29weXJpZ2h0IChDKSAyMDE2IFNoYXduIEJhbmFzaWNrXG5UaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbnRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4oYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuKi9cbi8qICBKU2xpbnQgZGVjbGFyYXRpb25zXG4gZ2xvYmFsIHJlc291cmNlcywgZDMsIFZJRVcsIGQzX3NhdmVfc3ZnLCBDT1JSLCBhbGFzcWwsIHdpbmRvdywgUUFWLCAkLCBkb2N1bWVudCwgZXZlblJvdW5kLCBVVElMLCBfICBcbiAqL1xuXG4oZnVuY3Rpb24gKFBSRUxJTU9VVCwgUUFWLCB1bmRlZmluZWQpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICB2aWV3XG4gICAgLy8gKioqKioqICBQcmVsaW1pbmFyeSBSZXN1bHRzIDEgLSBkcmF3IGZhY3RvciBzeW50aGV0aWMgUS1zb3J0cyB2aXN1YWxzICoqKioqKioqXG4gICAgLy8gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIFBSRUxJTU9VVC5zaG93UHJlbGltaW5hcnlPdXRwdXQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhZGQgc3ludGhldGljIGZhY3RvcnMgdmlzdWFsaXphdGlvbnNcbiAgICAgICAgLy8gJChcIiNzeW5GYWN0b3JWaXpUaXRsZVwiKS5hcHBlbmQoXCI8aDQ+XCIgKyBzeW5GYWN0b3JWaXpUaXRsZVRleHQgKyBcIjwvaDQ+XCIpOyBcblxuICAgICAgICB2YXIgZGlzdFN0YXRlbWVudERhdGFWaXpBcnJheSA9IFFBVi5nZXRTdGF0ZShcImRpc3RTdGF0ZW1lbnREYXRhVml6QXJyYXlcIik7XG4gICAgICAgIHZhciBvdXRwdXRGb3JEYXRhVml6ID0gUUFWLmdldFN0YXRlKFwib3V0cHV0Rm9yRGF0YVZpelwiKTtcbiAgICAgICAgdmFyIHVzZXJTZWxlY3RlZEZhY3RvcnMgPSBRQVYuZ2V0U3RhdGUoXCJ1c2VyU2VsZWN0ZWRGYWN0b3JzXCIpO1xuICAgICAgICAvLyB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIHZpekNvbmZpZyA9IFFBVi5nZXRTdGF0ZShcInZpekNvbmZpZ1wiKSB8fCB7fTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShvdXRwdXRGb3JEYXRhVml6KSk7XG5cblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggdXNlclNlbGVjdGVkRmFjdG9ycyB0byBnZXQgZWFjaCBzeW5GYWN0b3JWaXpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRGb3JEYXRhVml6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyB2YXIgc3luRmFjdG9yVml6TmFtZSA9IFwic3luRmFjdG9yVml6XCIgKyAoaSArIDEpO1xuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBkaXN0aW5ndWlzaGluZyBzdGF0ZW1lbnQgaW4gZGlzdFN0YXRlbWVudERhdGFWaXpBcnJheVtpXVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkaXN0U3RhdGVtZW50RGF0YVZpekFycmF5W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHN0YXRlbWVudCBudW1iZXJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVtZW50SWQgPSBkaXN0U3RhdGVtZW50RGF0YVZpekFycmF5W2ldW2pdW1wiTm8uXCJdO1xuICAgICAgICAgICAgICAgIC8vIGF2b2lkIGVtcHR5IG9iamVjdHNcbiAgICAgICAgICAgICAgICB2YXIgc2lnU3ltYm9sO1xuICAgICAgICAgICAgICAgIHZhciB0ZXN0VmFsdWUgPSBwYXJzZUludChzdGF0ZW1lbnRJZCwgMTApO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odGVzdFZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB2YWx1ZXMgZm9yIGNhbGMgb2YgZGlyZWN0aW9uIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnRmFjdG9yWnNjb3JlS2V5ID0gXCJaLVNDUi1cIiArIHVzZXJTZWxlY3RlZEZhY3RvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWdGYWN0b3Jac2NvcmVWYWx1ZSA9IGRpc3RTdGF0ZW1lbnREYXRhVml6QXJyYXlbaV1bal1bc2lnRmFjdG9yWnNjb3JlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsbEZhY3RvclpzY29yZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIG9mIHRoZSBmYWN0b3Igei1zY29yZXMgYW5kIHB1c2ggdG8gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB1c2VyU2VsZWN0ZWRGYWN0b3JzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcDEgPSBcIlotU0NSLVwiICsgdXNlclNlbGVjdGVkRmFjdG9yc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wMiA9IGRpc3RTdGF0ZW1lbnREYXRhVml6QXJyYXlbaV1bal1bdGVtcDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmFjdG9yWnNjb3Jlcy5wdXNoKHRlbXAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjIGRpcmVjdGlvblN5bWJvbCBieSBjaGVja2luZyBhZ2FpbnN0IFpzY29yZSBpbiBhbGwgb3RoZXIgZmFjdG9yc1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJGYWN0b3Jac2NvcmVzID0gXy5wdWxsKGFsbEZhY3RvclpzY29yZXMsIHNpZ0ZhY3RvclpzY29yZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGZhY3RvclpzY29yZUF2ZXJhZ2UgPSBkMy5tZWFuKG90aGVyRmFjdG9yWnNjb3Jlcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJvd1BvaW50ZXJBcnJheUxlZnQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycm93UG9pbnRlckFycmF5UmlnaHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2sgPSAwOyBrayA8IG90aGVyRmFjdG9yWnNjb3Jlcy5sZW5ndGg7IGtrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWdGYWN0b3Jac2NvcmVWYWx1ZSAtIG90aGVyRmFjdG9yWnNjb3Jlc1tra10gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3dQb2ludGVyQXJyYXlSaWdodC5wdXNoKFwiMVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3dQb2ludGVyQXJyYXlMZWZ0LnB1c2goXCIxXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvblN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyRmFjdG9yWnNjb3Jlcy5sZW5ndGggPT09IGFycm93UG9pbnRlckFycmF5UmlnaHQubGVuZ3RoICYmIHVzZXJTZWxlY3RlZEZhY3RvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uU3ltYm9sID0gdml6Q29uZmlnLnNob3VsZFVzZVVuaWNvZGUgIT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdTI1QkFcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI+PlwiOyAvLyBcIiA+Pj5cIjsgXCImIzk2NTg7XCI7ICByaWdodC1wb2ludGluZyBwb2ludGVyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3RoZXJGYWN0b3Jac2NvcmVzLmxlbmd0aCA9PT0gYXJyb3dQb2ludGVyQXJyYXlMZWZ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uU3ltYm9sID0gdml6Q29uZmlnLnNob3VsZFVzZVVuaWNvZGUgIT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdTI1QzRcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8PFwiOyAvL1wiIDw8PFwiOyAgXCImIzk2Njg7XCI7ICBsZWZ0LXBvaW50aW5nIHBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvblN5bWJvbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcHV0IGl0IGFsbCB0b2dldGhlciBhbmQgaW5zZXJ0IGludG8gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWdGYWN0b3JOYW1lID0gXCJTSUdcIiArIHVzZXJTZWxlY3RlZEZhY3RvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWdBdDAxTGV2ZWwgPSBkaXN0U3RhdGVtZW50RGF0YVZpekFycmF5W2ldW2pdW3NpZ0ZhY3Rvck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBzdGF0ZW1lbnRJZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWdBdDAxTGV2ZWwgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWdTeW1ib2wgPSB2aXpDb25maWcuc2hvdWxkVXNlVW5pY29kZSAhPT0gZmFsc2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx1MjVDOVwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIioqIFwiOyAvL1wiKipcIjsgIFwiJiM5NjczO1wiOyAgc2lnIGF0IC4wMVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpZ0F0MDFMZXZlbCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnU3ltYm9sID0gdml6Q29uZmlnLnNob3VsZFVzZVVuaWNvZGUgIT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdTI1Q0VcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIqIFwiOyAvLyBcIipcIjsgIFwiJiM5Njc4O1wiOyAgc2lnIGF0IC4wNVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkU2hvd1pzY29yZUFycm93cyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZvckRhdGFWaXpbaV1bbG9jYXRpb25dLnNpZ1Zpc3VhbGl6YXRpb24gPSAoc2lnU3ltYm9sICsgZGlyZWN0aW9uU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aXpDb25maWcuc2hvdWxkU2hvd1pzY29yZUFycm93cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZvckRhdGFWaXpbaV1bbG9jYXRpb25dLnNpZ1Zpc3VhbGl6YXRpb24gPSBzaWdTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUUFWLnNldFN0YXRlKFwib3V0cHV0Rm9yRGF0YVZpelwiLCBvdXRwdXRGb3JEYXRhVml6KTtcblxuICAgICAgICBQUkVMSU1PVVQuZHJhd1N5blNvcnRUcmlhbmdsZXNGb3JPdXRwdXQob3V0cHV0Rm9yRGF0YVZpeiwgdXNlclNlbGVjdGVkRmFjdG9ycyk7XG4gICAgfTtcblxuXG4gICAgUFJFTElNT1VULmRyYXdTeW5Tb3J0VHJpYW5nbGVzRm9yT3V0cHV0ID0gZnVuY3Rpb24gKG91dHB1dEZvckRhdGFWaXosIHVzZXJTZWxlY3RlZEZhY3RvcnMpIHtcbiAgICAgICAgdmFyIHNvcnRUcmlhbmdsZVNoYXBlID0gUUFWLmdldFN0YXRlKFwicWF2U29ydFRyaWFuZ2xlU2hhcGVcIik7XG4gICAgICAgIHZhciB1bmlxdWVzID0gXy51bmlxKHNvcnRUcmlhbmdsZVNoYXBlKTtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZW1lbnRzID0gUUFWLmdldFN0YXRlKFwicWF2Q3VycmVudFN0YXRlbWVudHNcIik7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICB2YXIgc3luRmFjdG9yVml6VGl0bGVUZXh0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlN5bnRoZXRpYyBTb3J0IGZvclwiXTtcbiAgICAgICAgdmFyIGRpc3RpbmcwNUxlZ2VuZFRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiRGlzdGluZ3Vpc2hpbmcgc3RhdGVtZW50IGF0IFAgPCAwLjA1XCJdO1xuICAgICAgICB2YXIgZGlzdGluZzAxTGVnZW5kVGV4dCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJEaXN0aW5ndWlzaGluZyBzdGF0ZW1lbnQgYXQgUCA8IDAuMDFcIl07XG4gICAgICAgIHZhciBsZWdlbmRUaXRsZVRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLkxlZ2VuZDtcbiAgICAgICAgdmFyIHpzY29yZUhpZ2hlckxlZ2VuZFRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiei1TY29yZSBmb3IgdGhlIHN0YXRlbWVudCBpcyBoaWdoZXIgdGhhbiBpbiBhbGwgb2YgdGhlIG90aGVyIGZhY3RvcnNcIl07XG4gICAgICAgIHZhciB6c2NvcmVMb3dlckxlZ2VuZFRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiei1TY29yZSBmb3IgdGhlIHN0YXRlbWVudCBpcyBsb3dlciB0aGFuIGluIGFsbCBvZiB0aGUgb3RoZXIgZmFjdG9yc1wiXTtcbiAgICAgICAgdmFyIGNvbnNlbnN1c0xlZ2VuZFRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiQ29uc2Vuc3VzIHN0YXRlbWVudCAobm9uLXNpZ25pZmljYW50IGF0IFAgPiAwLjEpXCJdO1xuICAgICAgICB2YXIgbWF0Y2hpbmdDb3VudExlZ2VuZFRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiTG93IG51bWJlciBvZiByYXcgUS1zb3J0IG1hdGNoaW5nIHZhbHVlcyAoY3V0b2ZmXCJdO1xuICAgICAgICB2YXIgb3ZlcmxhcExlZ2VuZFRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiQ29uc2Vuc3VzIHN0YXRlbWVudCB3aXRoIGxvdyBudW1iZXIgb2YgbWF0Y2hpbmcgdmFsdWVzXCJdO1xuXG5cbiAgICAgICAgdmFyIHN2Z0hlaWdodDtcbiAgICAgICAgdmFyIGVsZW1lbnRIZWlnaHQsXG4gICAgICAgICAgICBzeW1ib2xTaXplLFxuICAgICAgICAgICAgdlNlcGFyYXRpb24sXG4gICAgICAgICAgICBzdmdIZWlnaHRDYWxjO1xuICAgICAgICB2YXIgdml6Q29uZmlnID0gUUFWLmdldFN0YXRlKFwidml6Q29uZmlnXCIpIHx8IHt9O1xuICAgICAgICB2YXIgY2FyZEZvbnRTaXplID0gXCIxMnB4XCI7IC8vIGRlZmF1bHQgc2V0dGluZ1xuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSAoJChcIi5jb250YWluZXJcIilcbiAgICAgICAgICAgIC53aWR0aCgpIC0gNDApO1xuICAgICAgICB2YXIgZWxlbWVudFdpZHRoLFxuICAgICAgICAgICAgY29uZmlnO1xuICAgICAgICB2YXIgY29uc2Vuc3VzQ29sb3IgPSB2aXpDb25maWcuY29uc2Vuc3VzQ3VzdG9tQ29sb3I7XG4gICAgICAgIHZhciBtYXRjaENvdW50Q29sb3IgPSB2aXpDb25maWcubWF0Y2hDb3VudEN1c3RvbUNvbG9yO1xuICAgICAgICB2YXIgb3ZlcmxhcENvbG9yID0gdml6Q29uZmlnLm92ZXJsYXBDdXN0b21Db2xvcjtcbiAgICAgICAgdmFyIGNvbnNlbnN1c0luZGljYXRvciA9IHZpekNvbmZpZy5zaG91bGRVc2VUb0luZGljYXRlQ29uc2Vuc3VzOyAvL1wiY29sb3IgLyBzdHJpcGVcIlxuICAgICAgICB2YXIgbWF0Y2hDYXV0aW9uSW5kaWNhdG9yID0gdml6Q29uZmlnLnNob3VsZFVzZVRvSW5kaWNhdGVNYXRjaENhdXRpb247IC8vIGNvbG9yIHN0cmlwZVxuICAgICAgICB2YXIgb3ZlcmxhcEluZGljYXRvciA9IHZpekNvbmZpZy5zaG91bGRVc2VUb0luZGljYXRlT3ZlcmxhcDsgLy8gY29sb3IgY3Jvc3NoYXRjaFxuXG4gICAgICAgIC8vIHVzZXIgYWRqdXN0IGluZGljYXRvciB0eXBlc1xuICAgICAgICBpZiAoY29uc2Vuc3VzSW5kaWNhdG9yID09PSBcInN0cmlwZVwiKSB7XG4gICAgICAgICAgICBjb25zZW5zdXNJbmRpY2F0b3IgPSAndXJsKCNoYXNoNF80KSc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc2Vuc3VzSW5kaWNhdG9yID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgICAgIGNvbnNlbnN1c0luZGljYXRvciA9IGNvbnNlbnN1c0NvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoQ2F1dGlvbkluZGljYXRvciA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgICBtYXRjaENhdXRpb25JbmRpY2F0b3IgPSBtYXRjaENvdW50Q29sb3I7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hDYXV0aW9uSW5kaWNhdG9yID09PSBcInN0cmlwZVwiKSB7XG4gICAgICAgICAgICBtYXRjaENhdXRpb25JbmRpY2F0b3IgPSAndXJsKCNoYXNoNF80YiknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJsYXBJbmRpY2F0b3IgPT09IFwiY29sb3JcIikge1xuICAgICAgICAgICAgb3ZlcmxhcEluZGljYXRvciA9IG92ZXJsYXBDb2xvcjtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwSW5kaWNhdG9yID09PSBcImNyb3NzaGF0Y2hcIikge1xuICAgICAgICAgICAgb3ZlcmxhcEluZGljYXRvciA9ICd1cmwoI2Nyb3NzaGF0Y2gpJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZXIgYWRqdXN0IGNhcmQgd2lkdGhcbiAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRTZXRDYXJkV2lkdGggPT09IHRydWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnRXaWR0aCA9IHZpekNvbmZpZy5jYXJkV2lkdGg7XG4gICAgICAgICAgICBjb250YWluZXJXaWR0aCA9IChlbGVtZW50V2lkdGggKiB1bmlxdWVzLmxlbmd0aCkgKyAxMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC8gdW5pcXVlcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1c2VyIGFkanVzdCBmb250IHNpemUgZm9yIGNhcmRzXG4gICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkU2V0Rm9udFNpemUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNhcmRGb250U2l6ZSA9IHZpekNvbmZpZy5mb250U2l6ZSArIFwicHhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZXIgYWRqdXN0IGNhcmQgaGVpZ2h0XG4gICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkU2V0Q2FyZEhlaWdodCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5ld0hlaWdodFZhbHVlID0gdml6Q29uZmlnLmNhcmRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAobmV3SGVpZ2h0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodFZhbHVlID0gMTEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudEhlaWdodCA9IHBhcnNlSW50KG5ld0hlaWdodFZhbHVlLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50SGVpZ2h0ID0gMTEwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlciBhZGp1c3Qgc2lnIHN5bWJvbCBzaXplXG4gICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkU2V0U3ltYm9sRm9udFNpemUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN5bWJvbFNpemUgPSB2aXpDb25maWcuc2lnU3ltYm9sRm9udFNpemUgKyBcInB4XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzeW1ib2xTaXplID0gXCIxMnB4XCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1c2VyIGFkanVzdCBsaW5lIHNwYWNpbmdcbiAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRTZXRMaW5lU3BhY2luZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdlNlcGFyYXRpb24gPSB2aXpDb25maWcubGluZVNwYWNpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2U2VwYXJhdGlvbiA9IDE1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IGxlZ2VuZCBzeW1ib2xzXG4gICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkVXNlVW5pY29kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdml6Q29uZmlnLmxlZ2VuZFN5bWJvbDA1ID0gJ1xcdTI1Q0UnO1xuICAgICAgICAgICAgdml6Q29uZmlnLmxlZ2VuZFN5bWJvbDAxID0gJ1xcdTI1QzknO1xuICAgICAgICAgICAgdml6Q29uZmlnLnJpZ2h0QXJyb3cgPSAnXFx1MjVCQSc7XG4gICAgICAgICAgICB2aXpDb25maWcubGVmdEFycm93ID0gJ1xcdTI1QzQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdml6Q29uZmlnLmxlZ2VuZFN5bWJvbDA1ID0gJyonO1xuICAgICAgICAgICAgdml6Q29uZmlnLmxlZ2VuZFN5bWJvbDAxID0gJyoqJztcbiAgICAgICAgICAgIHZpekNvbmZpZy5yaWdodEFycm93ID0gJz4+JztcbiAgICAgICAgICAgIHZpekNvbmZpZy5sZWZ0QXJyb3cgPSAnPDwnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlcGFyZSBzdGF0ZW1lbnRzICFmYWxzZSBzZXRzIGFzIGRlZmF1bHRcbiAgICAgICAgYXBwZW5kTnVtYmVyc1RvU3RhdGVtZW50cyhvdXRwdXRGb3JEYXRhVml6KTtcblxuICAgICAgICAvLyBhdXRvIGFkanVzdCBpZiBubyBjYXJkIGhlYWRlciBpbmZvXG4gICAgICAgIHZhciBsb2NhdGVTdGF0ZVk7XG4gICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkU2hvd01hdGNoQ291bnRzID09PSB0cnVlIHx8IHZpekNvbmZpZy5zaG91bGRJbmRpY2F0ZURpc3Rpbmd1aXNoaW5nKSB7XG4gICAgICAgICAgICBsb2NhdGVTdGF0ZVkgPSA0MDtcbiAgICAgICAgfSBlbHNlIGlmICh2aXpDb25maWcuc2hvdWxkSW5kaWNhdGVEaXN0aW5ndWlzaGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsb2NhdGVTdGF0ZVkgPSA0MDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2F0ZVN0YXRlWSA9IDIwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlciB0cmltIHN0YXRlbWVudHNcbiAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRUcmltU3RhdGVtZW50cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdHJpbVN0YXRtZW50cyhvdXRwdXRGb3JEYXRhVml6KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZG8gLSBmaXggc28gaXQgZG9lc24ndCB0cmlnZ2VyIG11bHRpcGxlIHRpbWVzXG4gICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkU2hvd01hdGNoQ291bnRzID09PSB0cnVlIHx8IHZpekNvbmZpZy5zaG91bGRTaG93QmFja2dyb3VuZENvbG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjYWxjTWF0Y2hDb3VudHMob3V0cHV0Rm9yRGF0YVZpeik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNOdW1iZXIgPSBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICBpc0Zpbml0ZSh2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaW50ZWdyYXRlQ29uc2Vuc3VzU3RhdGVtZW50SW5kaWNhdG9ycygpIHtcbiAgICAgICAgICAgIHZhciBjb25zZW5zdXNTdGF0ZW1lbnRBcnJheXMgPSBRQVYuZ2V0U3RhdGUoXCJmb3JtYXR0ZWRDb25zZW5zdXNTdGF0ZW1lbnRzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnNlbnN1c051bXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gY29uc2Vuc3VzU3RhdGVtZW50QXJyYXlzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXN0VmFsdWUgPSBjb25zZW5zdXNTdGF0ZW1lbnRBcnJheXNbaV1bXCJOby5cIl07XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHRlc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc2Vuc3VzTnVtcy5wdXNoKHRlc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IG91dHB1dEZvckRhdGFWaXoubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrTGVuID0gb3V0cHV0Rm9yRGF0YVZpeltqXS5sZW5ndGg7IGsgPCBrTGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvblN0YXRlTnVtID0gY29uc2Vuc3VzTnVtc1tjb3VudGVyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dEZvckRhdGFWaXpbal1ba10uc3RhdGVtZW50ID09PSBjb25TdGF0ZU51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9yRGF0YVZpeltqXVtrXS5pc0NvbnNlbnN1c1N0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZvckRhdGFWaXpbal1ba10uaXNDb25zZW5zdXNTdGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGludGVncmF0ZUNvbnNlbnN1c1N0YXRlbWVudEluZGljYXRvcnMoKTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIHNldEJhY2tncm91bmRDb2xvckZpbGwoKSB7XG4gICAgICAgICAgICB2YXIgaXNDb25zZW5zdXMsIGlzQ2F1dGlvbiwgbWF0Y2hpbmdDb3VudFBlcmNlbnQ7XG4gICAgICAgICAgICB2YXIgY3V0b2ZmID0gdml6Q29uZmlnLmJhY2tncm91bmRDb2xvckN1dG9mZjtcbiAgICAgICAgICAgIHZhciBjYXV0aW9uID0gQm9vbGVhbih2aXpDb25maWcuc2hvdWxkU2hvd0JhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICB2YXIgY29uc2Vuc3VzID0gQm9vbGVhbih2aXpDb25maWcuc2hvdWxkSW5kaWNhdGVDb25zZW5zdXMpO1xuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggZmFjdG9ycywgdGhlbiBRLXNvcnRzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IG91dHB1dEZvckRhdGFWaXoubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSBvdXRwdXRGb3JEYXRhVml6WzBdLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpc0NvbnNlbnN1cyA9IG91dHB1dEZvckRhdGFWaXpbaV1bal0uaXNDb25zZW5zdXNTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdDb3VudFBlcmNlbnQgPSBvdXRwdXRGb3JEYXRhVml6W2ldW2pdLm1hdGNoaW5nQ291bnRQZXJjZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdDb3VudFBlcmNlbnQgPD0gY3V0b2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NhdXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDYXV0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB1c2VyIHNlbGVjdHMgYm90aCBjYXV0aW9uIGFuZCBjb25zZW5zdXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhdXRpb24gPT09IHRydWUgJiYgY29uc2Vuc3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIGNhcmQgc2hvd3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbnNlbnN1cyA9PT0gdHJ1ZSAmJiBpc0NhdXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRGb3JEYXRhVml6W2ldW2pdLmRpc3BsYXlGaWxsID0gb3ZlcmxhcEluZGljYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDb25zZW5zdXMgPT09IHRydWUgJiYgaXNDYXV0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZvckRhdGFWaXpbaV1bal0uZGlzcGxheUZpbGwgPSBjb25zZW5zdXNJbmRpY2F0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ29uc2Vuc3VzID09PSBmYWxzZSAmJiBpc0NhdXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRGb3JEYXRhVml6W2ldW2pdLmRpc3BsYXlGaWxsID0gbWF0Y2hDYXV0aW9uSW5kaWNhdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRGb3JEYXRhVml6W2ldW2pdLmRpc3BsYXlGaWxsID0gJyNmZmZmZmYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhdXRpb24gPT09IHRydWUgJiYgY29uc2Vuc3VzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2F1dGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZvckRhdGFWaXpbaV1bal0uZGlzcGxheUZpbGwgPSBtYXRjaENhdXRpb25JbmRpY2F0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZvckRhdGFWaXpbaV1bal0uZGlzcGxheUZpbGwgPSAnI2ZmZmZmZic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2F1dGlvbiA9PT0gZmFsc2UgJiYgY29uc2Vuc3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb25zZW5zdXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRGb3JEYXRhVml6W2ldW2pdLmRpc3BsYXlGaWxsID0gY29uc2Vuc3VzSW5kaWNhdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRGb3JEYXRhVml6W2ldW2pdLmRpc3BsYXlGaWxsID0gJyNmZmZmZmYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9yRGF0YVZpeltpXVtqXS5kaXNwbGF5RmlsbCA9ICcjZmZmZmZmJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZW5kIGNhcmQgbG9vcFxuICAgICAgICAgICAgfSAvLyBlbmQgZmFjdG9yIGxvb3BcbiAgICAgICAgfSAvLyBlbmQgZnVuY3Rpb25cblxuICAgICAgICBpZiAodml6Q29uZmlnLnNob3VsZFNob3dCYWNrZ3JvdW5kQ29sb3IgPT09IHRydWUgfHwgdml6Q29uZmlnLnNob3VsZEluZGljYXRlQ29uc2Vuc3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzZXRCYWNrZ3JvdW5kQ29sb3JGaWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhcHBlbmROdW1iZXJzVG9TdGF0ZW1lbnRzKG91dHB1dEZvckRhdGFWaXopIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0Rm9yRGF0YVZpei5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBvdXRwdXRGb3JEYXRhVml6W2ldLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodml6Q29uZmlnLnNob3VsZFNob3dPbmx5U3RhdGVObyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9yRGF0YVZpeltpXVtpaV0uZGlzcGxheVN0YXRlbWVudHMgPSBvdXRwdXRGb3JEYXRhVml6W2ldW2lpXS5zdGF0ZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodml6Q29uZmlnLnNob3VsZFByZXBlbmRTdGF0ZU5vID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9yRGF0YVZpeltpXVtpaV0uZGlzcGxheVN0YXRlbWVudHMgPSBvdXRwdXRGb3JEYXRhVml6W2ldW2lpXS5zb3J0U3RhdGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9yRGF0YVZpeltpXVtpaV0uZGlzcGxheVN0YXRlbWVudHMgPSBvdXRwdXRGb3JEYXRhVml6W2ldW2lpXS5zdGF0ZW1lbnQgKyBcIi4gXCIgKyBvdXRwdXRGb3JEYXRhVml6W2ldW2lpXS5zb3J0U3RhdGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEZvckRhdGFWaXo7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cmltU3RhdG1lbnRzKG91dHB1dEZvckRhdGFWaXopIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0Rm9yRGF0YVZpei5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBvdXRwdXRGb3JEYXRhVml6W2ldLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodml6Q29uZmlnLnNob3VsZFRyaW1TdGF0ZW1lbnRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlU3ViU3RyaW5nID0gb3V0cHV0Rm9yRGF0YVZpeltpXVtpaV0uZGlzcGxheVN0YXRlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRGb3JEYXRhVml6W2ldW2lpXS5kaXNwbGF5U3RhdGVtZW50cyA9IHByZVN1YlN0cmluZy5zdWJzdHJpbmcoMCwgdml6Q29uZmlnLnRyaW1TdGF0ZW1lbnRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Rm9yRGF0YVZpejtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGNNYXRjaENvdW50cyhvdXRwdXRGb3JEYXRhVml6KSB7XG4gICAgICAgICAgICB2YXIgeCA9IDEwO1xuXG4gICAgICAgICAgICB2YXIgZGF0YTIgPSBRQVYuZ2V0U3RhdGUoXCJtYXRjaENvdW50XCIpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IHVzZXJTZWxlY3RlZEZhY3RvcnMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGExID0gZGF0YTJbaV07XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhMS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICBkYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXhlciAtIGIuaW5kZXhlcjtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGpqID0gMCwgampMZW4gPSBkYXRhLmxlbmd0aDsgamogPCBqakxlbjsgamorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhlciA9IGRhdGFbampdLmluZGV4ZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleGVyID09PSBvdXRwdXRGb3JEYXRhVml6W2ldW2pqXS5zdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZvckRhdGFWaXpbaV1bampdLm1hdGNoaW5nQ291bnQgPSBkYXRhW2pqXS5tYXRjaGluZ0NvdW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEZvckRhdGFWaXpbaV1bampdLm1hdGNoaW5nQ291bnRQZXJjZW50ID0gZGF0YVtqal0ubWF0Y2hpbmdDb3VudHNQZXJjZW50O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJlcnJvciAtIHN0YXRlbWVudCBvcmRlcmluZyBkb2Vzbid0IG1hdGNoXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHggPSB4ICsgMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFFBVi5zZXRTdGF0ZShcIm91dHB1dEZvckRhdGFWaXpcIiwgb3V0cHV0Rm9yRGF0YVZpeik7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Rm9yRGF0YVZpejtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmRPY2N1cnJlbmNlcyhhcnIsIHZhbCkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gYXJyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJbaV0gPT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFN2Z0hlaWdodChhcnIxKSB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0QWRqdXN0bWVudCA9IDA7XG4gICAgICAgICAgICBpZiAodml6Q29uZmlnLnNob3VsZEluZGljYXRlRGlzdGluZ3Vpc2hpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHRBZGp1c3RtZW50ID0gaGVpZ2h0QWRqdXN0bWVudCArIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRTaG93WnNjb3JlQXJyb3dzID09PSB0cnVlICYmIHZpekNvbmZpZy5zaG91bGRJbmRpY2F0ZURpc3Rpbmd1aXNoaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0QWRqdXN0bWVudCA9IGhlaWdodEFkanVzdG1lbnQgKyA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkSW5kaWNhdGVDb25zZW5zdXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHRBZGp1c3RtZW50ID0gaGVpZ2h0QWRqdXN0bWVudCArIDMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRTaG93WnNjb3JlQXJyb3dzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0QWRqdXN0bWVudCA9IGhlaWdodEFkanVzdG1lbnQgKyAzMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkU2hvd0JhY2tncm91bmRDb2xvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGhlaWdodEFkanVzdG1lbnQgPSBoZWlnaHRBZGp1c3RtZW50ICsgMzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodml6Q29uZmlnLnNob3VsZEluZGljYXRlQ29uc2Vuc3VzID09PSB0cnVlICYmIHZpekNvbmZpZy5zaG91bGRTaG93QmFja2dyb3VuZENvbG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0QWRqdXN0bWVudCA9IGhlaWdodEFkanVzdG1lbnQgKyAzMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdml6Q29uZmlnLmhlaWdodEFkanVzdG1lbnQgPSBoZWlnaHRBZGp1c3RtZW50O1xuXG4gICAgICAgICAgICB2YXIgYiA9IFtdLFxuICAgICAgICAgICAgICAgIHByZXY7XG4gICAgICAgICAgICB2YXIgYXJyID0gXy5jbG9uZURlZXAoYXJyMSk7XG4gICAgICAgICAgICBhcnIuc29ydCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldICE9PSBwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIGIucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiW2IubGVuZ3RoIC0gMV0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldiA9IGFycltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkSGF2ZUxlZ2VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHN2Z0hlaWdodENhbGMgPSAoKChwYXJzZUludChlbGVtZW50SGVpZ2h0LCAxMCkgKyAxMCkgKiBkMy5tYXgoYikpICsgMTYwICsgaGVpZ2h0QWRqdXN0bWVudCk7IC8vIHBsdXMgMTUwIGZvciBsZWdlbmRcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ZnSGVpZ2h0Q2FsYztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ZnSGVpZ2h0Q2FsYyA9ICgoKHBhcnNlSW50KGVsZW1lbnRIZWlnaHQsIDEwKSArIDEwKSAqIGQzLm1heChiKSkgKyAyNSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN2Z0hlaWdodENhbGM7IC8vIDI1IGZvciB0aGUgc29ydCB2YWx1ZXMgaGVhZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2RvIC0gZmluZCBjYXVzZSBvZiBlcnJvciB3aXRoICE9XG4gICAgICAgIGZ1bmN0aW9uIHdvcmR3cmFwKHRleHQsIG1heCkge1xuICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsaW5lO1xuICAgICAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRTZXRXaWR0aEZvckFzaWFuID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gdml6Q29uZmlnLmFzaWFuU3RhdG1lbnRMZW5ndGggfHwgMTI7XG4gICAgICAgICAgICAgICAgbGluZXMgPSB0ZXh0Lm1hdGNoKG5ldyBSZWdFeHAoJy57MSwnICsgbWF4ICsgJ30nLCAnZycpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIi57MCxcIiArIG1heCArIFwifSg/OlxcXFxzfCQpXCIsIFwiZ1wiKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGxpbmUgPSByZWdleC5leGVjKHRleHQpKSAhPSBcIlwiKSB7IC8vIERPIE5PVCBDSEFOR0UgIT0gVE8gIT09IC0gV0lMTCBUSFJPVyBFUlJPUlxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIH0gLy8gZW5kIHdoaWxlXG4gICAgICAgICAgICB9IC8vIGVuZCAyOTQgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgICAgICB9IC8vIGVuZCBmdW5jdGlvblxuXG4gICAgICAgIHZhciB0ZW1wMSxcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBpbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IHVuaXF1ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHRlbXAxID0gZmluZE9jY3VycmVuY2VzKHNvcnRUcmlhbmdsZVNoYXBlLCB1bmlxdWVzW2tdKTtcbiAgICAgICAgICAgIGluc3RhbmNlcy5wdXNoKHRlbXAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB4IHBvc2l0aW9uXG4gICAgICAgIHZhciB4UG9zTG9vcCA9IFtdO1xuICAgICAgICB2YXIgY291bnRlclggPSAwO1xuICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IGluc3RhbmNlcy5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBpbnN0YW5jZXNbbV07IHArKykge1xuICAgICAgICAgICAgICAgIHhQb3NMb29wLnB1c2goY291bnRlclgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlclggPSBjb3VudGVyWCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgeSBwb3NpdGlvblxuICAgICAgICB2YXIgeVBvc0xvb3AgPSBbXTtcbiAgICAgICAgdmFyIGNvdW50ZXJZO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGluc3RhbmNlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgY291bnRlclkgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBpbnN0YW5jZXNbcl07IHMrKykge1xuICAgICAgICAgICAgICAgIHlQb3NMb29wLnB1c2goY291bnRlclkpO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJZID0gY291bnRlclkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVnZW5kIGxvY2F0aW9uXG4gICAgICAgIHZhciB5TGVnZW5kID0gKChkMy5tYXgoeVBvc0xvb3ApICsgMSkgKiBlbGVtZW50SGVpZ2h0KSArIDUwO1xuICAgICAgICB2YXIgeExlZ2VuZENlbnRlclBvaW50ID0gKCgoKGQzLm1heCh4UG9zTG9vcCkgKyAxKSAqIGVsZW1lbnRXaWR0aCkgKyAyMCkgLyAyKTtcbiAgICAgICAgdmFyIGhhbGZMZWdlbmRXaWR0aCA9IDI4NTtcblxuICAgICAgICAvLyB0ZXh0IHdyYXAgdmFyaWFibGVzIC0gc2V0IGluIGNvbnRyb2wgcGFuZWw/XG4gICAgICAgIHZhciBtYXhMZW5ndGg7XG4gICAgICAgIHZhciBuZXdTdGF0ZW1lbnRXaWR0aCA9IHZpekNvbmZpZy5zdGF0ZW1lbnRXaWR0aCB8fCA2Ljc1O1xuICAgICAgICBpZiAodml6Q29uZmlnLnNob3VsZFNldFN0YXRlbWVudFdpZHRoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBtYXhMZW5ndGggPSBwYXJzZUludCgoKGVsZW1lbnRXaWR0aCAtIG5ld1N0YXRlbWVudFdpZHRoKSAvIDYuNzUpLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhMZW5ndGggPSBwYXJzZUludCgoZWxlbWVudFdpZHRoIC8gNi43NSksIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGMgdGhlIGhlaWdodCBvZiB0aGUgc3ZnXG4gICAgICAgIHN2Z0hlaWdodCA9IChnZXRTdmdIZWlnaHQoc29ydFRyaWFuZ2xlU2hhcGUpICsgMTUpO1xuXG4gICAgICAgIC8vIGdldCBDdXRvZmYgZnJvbSBzdGF0ZVxuICAgICAgICB2YXIgYmFja2dyb3VuZENvbG9yQ3V0b2ZmID0gdml6Q29uZmlnLmJhY2tncm91bmRDb2xvckN1dG9mZjtcblxuICAgICAgICAvLyBhZGp1c3QgaWYgZGlzcGxheSBpcyBvbmx5IHN0YXRlbWVudCBudW1iZXJzXG4gICAgICAgIHZhciBvbmx5TnVtYmVyc1hBZGp1c3RtZW50ID0gMDtcbiAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRTaG93T25seVN0YXRlTm8gPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9ubHlOdW1iZXJzWEFkanVzdG1lbnQgPSA2O1xuICAgICAgICB9XG5cblxuXG5cbiAgICAgICAgLypcblxuXG4gICAgICAgIEJFR0lOIHZpc3VhbGl6YXRpb25zIGNhbGMgbG9vcFxuXG5cbiAgICAgICAgKi9cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFycmF5IHRvIGRyYXcgdmlzdWFsaXphdGlvbnMgICBzeW5GYWN0b3JWaXpEaXZcbiAgICAgICAgZm9yICh2YXIgeiA9IDA7IHogPCBvdXRwdXRGb3JEYXRhVml6Lmxlbmd0aDsgeisrKSB7XG5cbiAgICAgICAgICAgIHZhciB6eiA9IHogKyAxO1xuXG4gICAgICAgICAgICB2YXIgZmFjdG9yVml6RGl2TmFtZSA9IFwiZmFjdG9yVml6RGl2XCIgKyB6ejtcbiAgICAgICAgICAgICQoXCIjc3luRmFjdG9yVml6RGl2XCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcIjxkaXYgaWQ9XCIgKyBmYWN0b3JWaXpEaXZOYW1lICsgXCI+PC9kaXY+XCIpO1xuXG4gICAgICAgICAgICAvLyBhcHBlbmRpbmcgbmFtZSBvdXRzaWRlIFNWR1xuICAgICAgICAgICAgLy8gJChcIiNcIiArIGZhY3RvclZpekRpdk5hbWUpXG4gICAgICAgICAgICAvLyAgICAgLmFwcGVuZChcIjxoNCBjbGFzcz0ndml6VGl0bGVzJz5cIiArIHN5bkZhY3RvclZpelRpdGxlVGV4dCArIHVzZXJTZWxlY3RlZEZhY3RvcnNbel0gKyBcIjwvaDQ+XCIpO1xuXG4gICAgICAgICAgICB2YXIgaWROYW1lID0gXCJzeW5Tb3J0U3ZnTm9cIiArIHp6O1xuXG4gICAgICAgICAgICAvLyBhZGQgc3ZnXG4gICAgICAgICAgICB2YXIgc3ZnID0gZDNcbiAgICAgICAgICAgICAgICAuc2VsZWN0KFwiI1wiICsgZmFjdG9yVml6RGl2TmFtZSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGNvbnRhaW5lcldpZHRoICsgMTApKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBzdmdIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgaWROYW1lKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIFwiZmFjdG9yVml6XCIpO1xuXG4gICAgICAgICAgICB2YXIgdGV4dEFycmF5MSA9IG91dHB1dEZvckRhdGFWaXpbel07XG5cbiAgICAgICAgICAgIC8vIHNvcnQgYnkgelNjb3JlIHotc2NvcmVcbiAgICAgICAgICAgIHZhciB0ZXh0QXJyYXkgPSB0ZXh0QXJyYXkxLnNsaWNlKDApO1xuICAgICAgICAgICAgdGV4dEFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYS56U2NvcmUgPT09IGIuelNjb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiLnN0YXRlbWVudCAtIGEuc3RhdGVtZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnpTY29yZSAtIGIuelNjb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhZGQgbG9jYXRpb24gZGF0YVxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0ZXh0QXJyYXkubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICB0ZXh0QXJyYXlbY10ueFZhbCA9IHhQb3NMb29wW2NdO1xuICAgICAgICAgICAgICAgIHRleHRBcnJheVtjXS55VmFsID0geVBvc0xvb3BbY107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHN2Z1xuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJnLm5vZGVcIilcbiAgICAgICAgICAgICAgICAuZGF0YSh1bmlxdWVzLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGluZGV4R3JvdXAgPSBpbmRleFxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibm9kZVwiKTtcblxuICAgICAgICAgICAgLy8gZHJhdyBoZWFkZXJzICAgIFxuICAgICAgICAgICAgaW5kZXhHcm91cFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGVsZW1lbnRXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgJzIwJylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHVuaXF1ZXMuaW5kZXhPZihkKSAqIGVsZW1lbnRXaWR0aCkgKyA1KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgJzQ1JylcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICd3aGl0ZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IGNvbHVtbiBudW1iZXJzICAgIFxuICAgICAgICAgICAgaW5kZXhHcm91cFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodW5pcXVlcy5pbmRleE9mKGQpICogZWxlbWVudFdpZHRoKSArIChlbGVtZW50V2lkdGggLyAyKSArIDUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAnNTgnKSAvLyB3YXMgMTZcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hlYWRlclRleHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdBcmlhbCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsICcxNHB4JylcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC13ZWlnaHQnLCAnYm9sZCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxuICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhc3NvY2lhdGUgZGF0YSB3aXRoIGlkZW50aWZpZXJzXG4gICAgICAgICAgICB2YXIgaW5kZXgyID0gc3ZnXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcImcubm9kZTJcIilcbiAgICAgICAgICAgICAgICAuZGF0YSh0ZXh0QXJyYXksIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnN0YXRlbWVudDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYXBwZW5kIHN0YXRlbWVudCByZWN0YW5nbGVzIGdyb3VwICAgIFxuICAgICAgICAgICAgdmFyIGluZGV4R3JvdXAyID0gaW5kZXgyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJub2RlMlwiKTtcblxuICAgICAgICAgICAgLy8gUGF0dGVybiBpbmplY3Rpb25cbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gc3ZnLmFwcGVuZChcImRlZnNcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicGF0dGVyblwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IFwiaGFzaDRfNFwiLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCI4XCIsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCI4XCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuVHJhbnNmb3JtOiBcInJvdGF0ZSg2MClcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjJcIixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjhcIixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgwLDApXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IGNvbnNlbnN1c0NvbG9yXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBwYXR0ZXJuMiA9IHN2Zy5hcHBlbmQoXCJwYXR0ZXJuXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInBhdHRlcm5cIilcbiAgICAgICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBcImhhc2g0XzRiXCIsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjhcIixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjhcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5UcmFuc2Zvcm06IFwicm90YXRlKDEzNSlcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjJcIixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjhcIixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgwLDApXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG1hdGNoQ291bnRDb2xvclxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGF0dGVybjMgPSBzdmcuYXBwZW5kKFwicGF0dGVyblwiKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJwYXR0ZXJuXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICBpZDogXCJjcm9zc2hhdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjhcIixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjhcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5UcmFuc2Zvcm06IFwicm90YXRlKDEzNSlcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjhcIixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjhcIixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgwLDApXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBvdmVybGFwQ29sb3JcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gZHJhdyBib3hlcyBmb3Igc3RhdGVtZW50c1xuICAgICAgICAgICAgaW5kZXhHcm91cDJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBlbGVtZW50V2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGVsZW1lbnRIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChkLnhWYWwgKiBlbGVtZW50V2lkdGgpICsgNSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGQueVZhbCAqIGVsZW1lbnRIZWlnaHQpICsgNjApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodml6Q29uZmlnLnNob3VsZFNob3dCYWNrZ3JvdW5kQ29sb3IgPT09IHRydWUgfHwgdml6Q29uZmlnLnNob3VsZEluZGljYXRlQ29uc2Vuc3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5kaXNwbGF5RmlsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnI2ZmZmZmZic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC8vLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgJyNmZmZmZmYnKTtcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJyk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgZGlzdGluZ3Vpc2hpbmcgc3RhdGVtZW50IHN5bWJvbHMgICAgXG4gICAgICAgICAgICBpZiAodml6Q29uZmlnLnNob3VsZEluZGljYXRlRGlzdGluZ3Vpc2hpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhHcm91cDJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGVsZW1lbnRXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGVsZW1lbnRIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCBzeW1ib2xTaXplKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChkLnhWYWwgKiBlbGVtZW50V2lkdGgpICsgNyk7IC8vIHdhcyA1XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGQueVZhbCAqIGVsZW1lbnRIZWlnaHQpICsgNzUpOyAvL3dhcyAzOFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuc2lnVmlzdWFsaXphdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkcmF3IHN0YXRlbWVudHNcbiAgICAgICAgICAgIGluZGV4R3JvdXAyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3dyYXAnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdBcmlhbCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNhcmRGb250U2l6ZSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGQueFZhbCAqIGVsZW1lbnRXaWR0aCkgKyA4KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoZC55VmFsICogZWxlbWVudEhlaWdodCkgKyBsb2NhdGVTdGF0ZVkgKyAzNSk7IC8vIHdhcyAyNVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgMClcbiAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSB3b3Jkd3JhcChkLmRpc3BsYXlTdGF0ZW1lbnRzLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpaWkgPSAwOyBpaWkgPCBsaW5lcy5sZW5ndGg7IGlpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidHNwYW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIHZTZXBhcmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCAoZC54VmFsICogZWxlbWVudFdpZHRoKSArIChlbGVtZW50V2lkdGggLyAyKSArIG9ubHlOdW1iZXJzWEFkanVzdG1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQobGluZXNbaWlpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRTaG93TWF0Y2hDb3VudHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpbmRleEdyb3VwMlxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ0FyaWFsJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNhcmRGb250U2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoZC54VmFsICogZWxlbWVudFdpZHRoKSArIChlbGVtZW50V2lkdGggKiAwLjk3KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGQueVZhbCAqIGVsZW1lbnRIZWlnaHQpICsgODMpOyAvLyB3YXMgMzhcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZC5tYXRjaGluZ0NvdW50ICsgXCIgKFwiICsgZC5tYXRjaGluZ0NvdW50UGVyY2VudCArIFwiJSlcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodml6Q29uZmlnLnNob3VsZEhhdmVMZWdlbmQgPT09IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleEdyb3VwMyA9IHN2Z1xuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibm9kZTNcIik7XG5cbiAgICAgICAgICAgICAgICBpbmRleEdyb3VwM1xuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDUwICsgdml6Q29uZmlnLmhlaWdodEFkanVzdG1lbnQpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDU3NSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoeExlZ2VuZENlbnRlclBvaW50IC0gaGFsZkxlZ2VuZFdpZHRoKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoeUxlZ2VuZCArIDM1KSkgLy8gd2FzIC01XG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3doaXRlJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnYmxhY2snKTtcblxuICAgICAgICAgICAgICAgIGluZGV4R3JvdXAzXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAvLy5hdHRyKCd4JywgKCh4TGVnZW5kQ2VudGVyUG9pbnQgLSBoYWxmTGVnZW5kV2lkdGgpICsgMjApKSAvLyBoYWxmIG9mIGxlZ2VuZCBib3ggd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoeExlZ2VuZENlbnRlclBvaW50IC0gOCkpIC8vIGhhbGYgb2YgbGVnZW5kIGJveCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsICh5TGVnZW5kICsgODApKSAvLyB3YXMgMzBcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZEhlYWRlcicpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdBcmlhbCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAnMjBweCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgICAgICAgICAgICAgICAvLy50ZXh0KCdTeW1ib2wnKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChsZWdlbmRUaXRsZVRleHQpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXdlaWdodCcsICdib2xkJyk7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEdyb3VwM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsICgoeExlZ2VuZENlbnRlclBvaW50IC0gaGFsZkxlZ2VuZFdpZHRoKSArIDEwMCkpIC8vIGhhbGYgb2YgbGVnZW5kIGJveCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoeUxlZ2VuZCArIDMwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsZWdlbmRIZWFkZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ0FyaWFsJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KCdJbnRlcnByZXRhdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC13ZWlnaHQnLCAnYm9sZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIC8vIHNldCBYIGFuZCBZIHZhbHVlcyBmb3IgbGVnZW5kXG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbFkgPSA4MDsgLy8gd2FzIDM0XG4gICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFRleHRZID0gNzk7IC8vIHdhcyAzMFxuICAgICAgICAgICAgICAgIHZhciBsZWdlbmRTeW1ib2xYID0gNDA7XG4gICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFRleHRYID0gODA7XG5cbiAgICAgICAgICAgICAgICAvLyBzeW1ib2xzICAtICE9PWZhbHNlIGlzIHRvIHNldCBhcyBkZWZhdWx0XG4gICAgICAgICAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRJbmRpY2F0ZURpc3Rpbmd1aXNoaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFkgPSBzeW1ib2xZICsgMjg7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4R3JvdXAzXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKCh4TGVnZW5kQ2VudGVyUG9pbnQgLSBoYWxmTGVnZW5kV2lkdGgpICsgbGVnZW5kU3ltYm9sWCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsICh5TGVnZW5kICsgc3ltYm9sWSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgc3ltYm9sU2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KHZpekNvbmZpZy5sZWdlbmRTeW1ib2wwNSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sWSA9IHN5bWJvbFkgKyAzMDtcblxuICAgICAgICAgICAgICAgICAgICBpbmRleEdyb3VwM1xuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsICgoeExlZ2VuZENlbnRlclBvaW50IC0gaGFsZkxlZ2VuZFdpZHRoKSArIGxlZ2VuZFN5bWJvbFgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoeUxlZ2VuZCArIHN5bWJvbFkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIHN5bWJvbFNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dCh2aXpDb25maWcubGVnZW5kU3ltYm9sMDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkU2hvd1pzY29yZUFycm93cyA9PT0gdHJ1ZSAmJiB2aXpDb25maWcuc2hvdWxkSW5kaWNhdGVEaXN0aW5ndWlzaGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xZID0gc3ltYm9sWSArIDMwO1xuICAgICAgICAgICAgICAgICAgICBpbmRleEdyb3VwM1xuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsICgoeExlZ2VuZENlbnRlclBvaW50IC0gaGFsZkxlZ2VuZFdpZHRoKSArIGxlZ2VuZFN5bWJvbFgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoeUxlZ2VuZCArIHN5bWJvbFkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIHN5bWJvbFNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dCh2aXpDb25maWcucmlnaHRBcnJvdyk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sWSA9IHN5bWJvbFkgKyAzMDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhHcm91cDNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoKHhMZWdlbmRDZW50ZXJQb2ludCAtIGhhbGZMZWdlbmRXaWR0aCkgKyBsZWdlbmRTeW1ib2xYKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKHlMZWdlbmQgKyBzeW1ib2xZKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCBzeW1ib2xTaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQodml6Q29uZmlnLmxlZnRBcnJvdyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRJbmRpY2F0ZUNvbnNlbnN1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xZID0gc3ltYm9sWSArIDEyO1xuICAgICAgICAgICAgICAgICAgICBpbmRleEdyb3VwM1xuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMjApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAyMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKCh4TGVnZW5kQ2VudGVyUG9pbnQgLSBoYWxmTGVnZW5kV2lkdGgpICsgbGVnZW5kU3ltYm9sWCAtIDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoeUxlZ2VuZCArIHN5bWJvbFkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjb25zZW5zdXNJbmRpY2F0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdibGFjaycpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xZID0gc3ltYm9sWSArIDE4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkU2hvd0JhY2tncm91bmRDb2xvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xZID0gc3ltYm9sWSArIDEyO1xuICAgICAgICAgICAgICAgICAgICBpbmRleEdyb3VwM1xuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMjApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAyMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKCh4TGVnZW5kQ2VudGVyUG9pbnQgLSBoYWxmTGVnZW5kV2lkdGgpICsgbGVnZW5kU3ltYm9sWCAtIDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoeUxlZ2VuZCArIHN5bWJvbFkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBtYXRjaENhdXRpb25JbmRpY2F0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdibGFjaycpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xZID0gc3ltYm9sWSArIDE4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2aXpDb25maWcuc2hvdWxkU2hvd0JhY2tncm91bmRDb2xvciA9PT0gdHJ1ZSAmJiB2aXpDb25maWcuc2hvdWxkSW5kaWNhdGVDb25zZW5zdXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sWSA9IHN5bWJvbFkgKyAxMjtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhHcm91cDNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDIwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMjApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsICgoeExlZ2VuZENlbnRlclBvaW50IC0gaGFsZkxlZ2VuZFdpZHRoKSArIGxlZ2VuZFN5bWJvbFggLSAyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKHlMZWdlbmQgKyBzeW1ib2xZKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgb3ZlcmxhcEluZGljYXRvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJyk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFkgPSBzeW1ib2xZICsgMTg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgKHNob3VsZGluZGkpXG5cbiAgICAgICAgICAgICAgICAvLyBpbnRlcnByZXRhdGlvbiB0ZXh0XG4gICAgICAgICAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRJbmRpY2F0ZURpc3Rpbmd1aXNoaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZFRleHRZID0gbGVnZW5kVGV4dFkgKyAzMDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhHcm91cDNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoKHhMZWdlbmRDZW50ZXJQb2ludCAtIGhhbGZMZWdlbmRXaWR0aCkgKyBsZWdlbmRUZXh0WCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsICh5TGVnZW5kICsgbGVnZW5kVGV4dFkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ0FyaWFsJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGRpc3RpbmcwNUxlZ2VuZFRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZFRleHRZID0gbGVnZW5kVGV4dFkgKyAzMDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhHcm91cDNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoKHhMZWdlbmRDZW50ZXJQb2ludCAtIGhhbGZMZWdlbmRXaWR0aCkgKyBsZWdlbmRUZXh0WCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsICh5TGVnZW5kICsgbGVnZW5kVGV4dFkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ0FyaWFsJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGRpc3RpbmcwMUxlZ2VuZFRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodml6Q29uZmlnLnNob3VsZFNob3dac2NvcmVBcnJvd3MgPT09IHRydWUgJiYgdml6Q29uZmlnLnNob3VsZEluZGljYXRlRGlzdGluZ3Vpc2hpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kVGV4dFkgPSBsZWdlbmRUZXh0WSArIDMwO1xuICAgICAgICAgICAgICAgICAgICBpbmRleEdyb3VwM1xuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsICgoeExlZ2VuZENlbnRlclBvaW50IC0gaGFsZkxlZ2VuZFdpZHRoKSArIGxlZ2VuZFRleHRYKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKHlMZWdlbmQgKyBsZWdlbmRUZXh0WSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCAnQXJpYWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoenNjb3JlSGlnaGVyTGVnZW5kVGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kVGV4dFkgPSBsZWdlbmRUZXh0WSArIDMwO1xuICAgICAgICAgICAgICAgICAgICBpbmRleEdyb3VwM1xuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsICgoeExlZ2VuZENlbnRlclBvaW50IC0gaGFsZkxlZ2VuZFdpZHRoKSArIGxlZ2VuZFRleHRYKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKHlMZWdlbmQgKyBsZWdlbmRUZXh0WSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCAnQXJpYWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoenNjb3JlTG93ZXJMZWdlbmRUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRJbmRpY2F0ZUNvbnNlbnN1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmRUZXh0WSA9IGxlZ2VuZFRleHRZICsgMzA7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4R3JvdXAzXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKCh4TGVnZW5kQ2VudGVyUG9pbnQgLSBoYWxmTGVnZW5kV2lkdGgpICsgbGVnZW5kVGV4dFgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoeUxlZ2VuZCArIGxlZ2VuZFRleHRZKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdBcmlhbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dChjb25zZW5zdXNMZWdlbmRUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodml6Q29uZmlnLnNob3VsZFNob3dCYWNrZ3JvdW5kQ29sb3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kVGV4dFkgPSBsZWdlbmRUZXh0WSArIDMwO1xuICAgICAgICAgICAgICAgICAgICBpbmRleEdyb3VwM1xuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsICgoeExlZ2VuZENlbnRlclBvaW50IC0gaGFsZkxlZ2VuZFdpZHRoKSArIGxlZ2VuZFRleHRYKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKHlMZWdlbmQgKyBsZWdlbmRUZXh0WSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCAnQXJpYWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQobWF0Y2hpbmdDb3VudExlZ2VuZFRleHQgKyBcIiBcIiArIHZpekNvbmZpZy5iYWNrZ3JvdW5kQ29sb3JDdXRvZmYgKyAnJSknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZpekNvbmZpZy5zaG91bGRTaG93QmFja2dyb3VuZENvbG9yID09PSB0cnVlICYmIHZpekNvbmZpZy5zaG91bGRJbmRpY2F0ZUNvbnNlbnN1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmRUZXh0WSA9IGxlZ2VuZFRleHRZICsgMzA7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4R3JvdXAzXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKCh4TGVnZW5kQ2VudGVyUG9pbnQgLSBoYWxmTGVnZW5kV2lkdGgpICsgbGVnZW5kVGV4dFgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoeUxlZ2VuZCArIGxlZ2VuZFRleHRZKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdBcmlhbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dChvdmVybGFwTGVnZW5kVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBlbmQgb2Ygc2hvdWxkIGhhdmUgbGVnZW5kXG5cbiAgICAgICAgICAgIC8vIGFkZCBGYWN0b3IgTmFtZXMgaW5zaWRlIFNWR1xuICAgICAgICAgICAgdmFyIG5ld1RleHQ7XG4gICAgICAgICAgICBpZiAodml6Q29uZmlnLmFkZEN1c3RvbUZhY3Rvck5hbWUgPT09IHRydWUgJiYgdml6Q29uZmlnLmN1c3RvbUZhY3Rvck5hbWVzW3pdKSB7XG4gICAgICAgICAgICAgICAgbmV3VGV4dCA9IHZpekNvbmZpZy5jdXN0b21GYWN0b3JOYW1lc1t6XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhcGl0YWxpemVkRmFjdG9yTmFtZSA9IHVzZXJTZWxlY3RlZEZhY3RvcnNbel0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB1c2VyU2VsZWN0ZWRGYWN0b3JzW3pdLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIG5ld1RleHQgPSBzeW5GYWN0b3JWaXpUaXRsZVRleHQgKyBjYXBpdGFsaXplZEZhY3Rvck5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdmcuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDUpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAyOClcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCAnQXJpYWwnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAnMzBweCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxuICAgICAgICAgICAgICAgIC50ZXh0KG5ld1RleHQpO1xuXG5cbiAgICAgICAgICAgIHZhciB0aGlzRmFjdG9yTmFtZSA9IHVzZXJTZWxlY3RlZEZhY3RvcnNbel0ucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICAgICAgICAgIHZhciBkb3dubG9hZFRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLmRvd25sb2FkSW1hZ2U7XG4gICAgICAgICAgICB2YXIgJHRoaXNTdmcgPSAkKFwiI1wiICsgZmFjdG9yVml6RGl2TmFtZSk7XG4gICAgICAgICAgICAkdGhpc1N2Zy5hcHBlbmQoJzxpbnB1dCBjbGFzcz1cInN2Z0Rvd25sb2FkQnV0dG9uIGJsYWNrSG92ZXJcIiBuYW1lPVwiZG93bmxvYWRCdXR0b25cIiBpZD1cIicgKyB0aGlzRmFjdG9yTmFtZSArICdJbWFnZVwiICAgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwiJyArIHVzZXJTZWxlY3RlZEZhY3RvcnNbel0gKyBkb3dubG9hZFRleHQgKyAnXCIgLz4nKTtcbiAgICAgICAgICAgICR0aGlzU3ZnLmFwcGVuZCgnPGlucHV0IGNsYXNzPVwicG5nRG93bmxvYWRCdXR0b24gYmxhY2tIb3ZlclwiIG5hbWU9XCJkb3dubG9hZFBuZ0J1dHRvblwiIGlkPVwiJyArIHRoaXNGYWN0b3JOYW1lICsgJ1BuZ0ltYWdlXCIgICB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCInICsgdXNlclNlbGVjdGVkRmFjdG9yc1t6XSArICcgLSBEb3dubG9hZCBpbWFnZSBhcyBQTkcnICsgJ1wiIC8+Jyk7XG4gICAgICAgIH0gLy8gZW5kIHogbG9vcCB0byBhZGQgdmlzdWFsaXphdGlvbnNcblxuICAgICAgICAkKCcuc3ZnRG93bmxvYWRCdXR0b24nKVxuICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdml6Q29uZmlnID0gUUFWLmdldFN0YXRlKFwidml6Q29uZmlnXCIpIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciBzaG91bGRBZGROYW1lID0gdml6Q29uZmlnLnNob3VsZEFkZEN1c3RvbU5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHN2Z0lkID0gJCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoXCJzdmdcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJyk7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5SW5kZXhOdW1iZXIgPSAoc3ZnSWQuc2xpY2UoLTEpIC0gMSk7XG4gICAgICAgICAgICAgICAgdmFyIGZhY3Rvck5hbWUgPSB1c2VyU2VsZWN0ZWRGYWN0b3JzW2FycmF5SW5kZXhOdW1iZXJdO1xuICAgICAgICAgICAgICAgIHZhciBjbGVhbkZhY3Rvck5hbWUgPSBmYWN0b3JOYW1lLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gVVRJTC5jdXJyZW50RGF0ZTEoKTtcbiAgICAgICAgICAgICAgICB2YXIgdGltZSA9IFVUSUwuY3VycmVudFRpbWUxKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVUaW1lID0gZGF0ZSArIFwiX1wiICsgdGltZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvamVjdE5hbWUgPSBRQVYuZ2V0U3RhdGUoXCJxYXZQcm9qZWN0TmFtZVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tTmFtZSA9IHZpekNvbmZpZy5jdXN0b21OYW1lO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGROYW1lID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXpDb25maWcuY3VzdG9tTmFtZUxvY2F0aW9uID09PSBcInByZXBlbmRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBjdXN0b21OYW1lICsgXCJfXCIgKyBwcm9qZWN0TmFtZSArIFwiX1wiICsgY2xlYW5GYWN0b3JOYW1lICsgXCJfXCIgKyBkYXRlVGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aXpDb25maWcuY3VzdG9tTmFtZUxvY2F0aW9uID09PSBcImFwcGVuZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHByb2plY3ROYW1lICsgXCJfXCIgKyBjbGVhbkZhY3Rvck5hbWUgKyBcIl9cIiArIGRhdGVUaW1lICsgXCJfXCIgKyBjdXN0b21OYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpekNvbmZpZy5jdXN0b21OYW1lTG9jYXRpb24gPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGN1c3RvbU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHByb2plY3ROYW1lICsgXCJfXCIgKyBjbGVhbkZhY3Rvck5hbWUgKyBcIl9cIiArIGRhdGVUaW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHByb2plY3ROYW1lICsgXCJfXCIgKyBjbGVhbkZhY3Rvck5hbWUgKyBcIl9cIiArIGRhdGVUaW1lXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGQzX3NhdmVfc3ZnLnNhdmUoZDMuc2VsZWN0KCcjJyArIHN2Z0lkKVxuICAgICAgICAgICAgICAgICAgICAubm9kZSgpLCBjb25maWcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgJCgnLnBuZ0Rvd25sb2FkQnV0dG9uJylcbiAgICAgICAgICAgIC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVDb25maWc7XG4gICAgICAgICAgICAgICAgdmFyIHZpekNvbmZpZyA9IFFBVi5nZXRTdGF0ZShcInZpekNvbmZpZ1wiKSB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgc2hvdWxkQWRkTmFtZSA9IHZpekNvbmZpZy5zaG91bGRBZGRDdXN0b21OYW1lO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNob3VsZEFkZE5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBzdmdJZCA9ICQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcpO1xuICAgICAgICAgICAgICAgIHZhciBhcnJheUluZGV4TnVtYmVyID0gKHN2Z0lkLnNsaWNlKC0xKSAtIDEpO1xuICAgICAgICAgICAgICAgIHZhciBmYWN0b3JOYW1lID0gdXNlclNlbGVjdGVkRmFjdG9yc1thcnJheUluZGV4TnVtYmVyXTtcbiAgICAgICAgICAgICAgICB2YXIgY2xlYW5GYWN0b3JOYW1lID0gZmFjdG9yTmFtZS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IFVUSUwuY3VycmVudERhdGUxKCk7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBVVElMLmN1cnJlbnRUaW1lMSgpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRlVGltZSA9IGRhdGUgKyBcIl9cIiArIHRpbWU7XG4gICAgICAgICAgICAgICAgdmFyIHByb2plY3ROYW1lID0gUUFWLmdldFN0YXRlKFwicWF2UHJvamVjdE5hbWVcIik7XG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbU5hbWUgPSB2aXpDb25maWcuY3VzdG9tTmFtZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjdXN0b21OYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWRkTmFtZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodml6Q29uZmlnLmN1c3RvbU5hbWVMb2NhdGlvbiA9PT0gXCJwcmVwZW5kXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVDb25maWcgPSBjdXN0b21OYW1lICsgXCJfXCIgKyBwcm9qZWN0TmFtZSArIFwiX1wiICsgY2xlYW5GYWN0b3JOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpekNvbmZpZy5jdXN0b21OYW1lTG9jYXRpb24gPT09IFwiYXBwZW5kXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVDb25maWcgPSBwcm9qZWN0TmFtZSArIFwiX1wiICsgY2xlYW5GYWN0b3JOYW1lICsgXCJfXCIgKyBjdXN0b21OYW1lO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpekNvbmZpZy5jdXN0b21OYW1lTG9jYXRpb24gPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lQ29uZmlnID0gY3VzdG9tTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVDb25maWcgPSBwcm9qZWN0TmFtZSArIFwiX1wiICsgY2xlYW5GYWN0b3JOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUNvbmZpZyA9IHByb2plY3ROYW1lICsgXCJfXCIgKyBjbGVhbkZhY3Rvck5hbWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN2Z1N0cmluZyA9IFVUSUwuZ2V0U1ZHU3RyaW5nKGQzLnNlbGVjdCgnIycgKyBzdmdJZClcbiAgICAgICAgICAgICAgICAgICAgLm5vZGUoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHN2Z0NoYXJhY3RlcmlzdGljcyA9IGQzLnNlbGVjdCgnIycgKyBzdmdJZCk7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHdpZHRoID0gcGFyc2VJbnQodGhpc1N2Z0NoYXJhY3RlcmlzdGljcy5zdHlsZShcIndpZHRoXCIpLCAxMCkgKyAyO1xuICAgICAgICAgICAgICAgIC8vIHZhciBoZWlnaHQgPSBwYXJzZUludCh0aGlzU3ZnQ2hhcmFjdGVyaXN0aWNzLnN0eWxlKFwiaGVpZ2h0XCIpLCAxMCk7XG4gICAgICAgICAgICAgICAgVVRJTC5kb3dubG9hZFBuZ0ltYWdlcyhzdmdTdHJpbmcsIHN2Z0NoYXJhY3RlcmlzdGljcywgbmFtZUNvbmZpZyk7IC8vIHBhc3NlcyBCbG9iIGFuZCBmaWxlc2l6ZSBcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgUFJFTElNT1VULnNob3dQcmVsaW1pbmFyeU91dHB1dDFiKCk7XG4gICAgfTtcblxuXG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogIHZpZXdcbiAgICAvLyAqKioqKiogIFByZWxpbWluYXJ5IFJlc3VsdHMgMWIgLSBkcmF3IGZhY3RvciBzY29yZSBjb3JyZWxhdGlvbnMgdGFibGUgICoqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgUFJFTElNT1VULnNob3dQcmVsaW1pbmFyeU91dHB1dDFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIGhlYWRlclRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiRmFjdG9yIHNjb3JlIGNvcnJlbGF0aW9uc1wiXTtcblxuICAgICAgICAvLyBhZGQgZmFjdG9yIGNvcnJlbGF0aW9ucyBhbmQgbG9hZGluZ3MgdGFibGVzXG4gICAgICAgICQoXCIjZmFjdG9yQ29ycmVsYXRpb25UYWJsZVRpdGxlXCIpLmFwcGVuZChcIjxoND5cIiArIGhlYWRlclRleHQgKyBcIjwvaDQ+XCIpO1xuXG4gICAgICAgIC8vICB0b2RvIC0gZml4IG9yZGVyaW5nIGVycm9yIG9mIGZhY3RvcnMgLSB1c2UgbGFyZ2UgZGVtbyBzZXQgd2l0aCA3IGZhY3RvcnMgdG8gc2VlIGVycm9yIGFuZCByZWR1Y2UgYXBwZW5kcyB0byBvbmx5IG9uZVxuXG4gICAgICAgICQoXCIjZmFjdG9yQ29ycmVsYXRpb25UYWJsZURpdlwiKS5hcHBlbmQoJzx0YWJsZSBpZD1cImZhY3RvckNvcnJlbGF0aW9uVGFibGVcIiBjbGFzcz1cImRpc3BsYXkgY29tcGFjdCBub3dyYXAgY2VsbC1ib3JkZXIgc3RyaXBlXCI+PC90YWJsZT4nKTtcblxuICAgICAgICAvLyB2YXIgZGF0YSA9IFFBVi5nZXRTdGF0ZShcIm91dHB1dFNwcmVhZHNoZWV0QXJyYXlcIik7XG5cbiAgICAgICAgLy8gdmFyIG5ld0RhdGEgPSBkYXRhWzZdO1xuXG4gICAgICAgIHZhciBuZXdEYXRhID0gUUFWLmdldFN0YXRlKFwiY29ycmVsYXRpb25UYWJsZUFycmF5SG9sZGVyXCIpO1xuXG5cbiAgICAgICAgLy8gICAgICAgIHZhciBjb2x1bW5IZWFkZXJzQXJyYXkgPSBkYXRhWzVdWzBdO1xuICAgICAgICB2YXIgY29sdW1uSGVhZGVyc0FycmF5ID0gbmV3RGF0YVswXTtcbiAgICAgICAgdmFyIGNvbHVtbkhlYWRlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5IZWFkZXJzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZW1wT2JqID0ge307XG4gICAgICAgICAgICB0ZW1wT2JqLnRpdGxlID0gY29sdW1uSGVhZGVyc0FycmF5W2ldO1xuICAgICAgICAgICAgdGVtcE9iai5jbGFzcyA9IFwiZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1yaWdodFwiO1xuICAgICAgICAgICAgY29sdW1uSGVhZGVycy5wdXNoKHRlbXBPYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sdW1uSGVhZGVyc1swXS5jbGFzcyA9IFwiZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1jZW50ZXJcIjtcblxuICAgICAgICBuZXdEYXRhLnNoaWZ0KCk7XG5cbiAgICAgICAgJChcIiNmYWN0b3JDb3JyZWxhdGlvblRhYmxlXCIpLkRhdGFUYWJsZSh7XG4gICAgICAgICAgICBcInJldHJpZXZlXCI6IHRydWUsXG4gICAgICAgICAgICBcInNlYXJjaGluZ1wiOiBmYWxzZSxcbiAgICAgICAgICAgIFwib3JkZXJpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICBcImluZm9cIjogZmFsc2UsXG4gICAgICAgICAgICBcInNjcm9sbFlcIjogMzUwLFxuICAgICAgICAgICAgXCJzY3JvbGxDb2xsYXBzZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwic2Nyb2xsWFwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwicGFnaW5nXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJkYXRhXCI6IG5ld0RhdGEsXG4gICAgICAgICAgICBcImNvbHVtbnNcIjogY29sdW1uSGVhZGVyc1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdGFibGUgPSAkKCcjZmFjdG9yQ29ycmVsYXRpb25UYWJsZScpLkRhdGFUYWJsZSgpO1xuICAgICAgICB2YXIgbGFzdElkeCA9IG51bGw7XG4gICAgICAgICQoJyNmYWN0b3JDb3JyZWxhdGlvblRhYmxlIHRib2R5Jykub24oJ21vdXNlb3ZlcicsICd0ZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sSWR4ID0gdGFibGVcbiAgICAgICAgICAgICAgICAgICAgLmNlbGwodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLmluZGV4KClcbiAgICAgICAgICAgICAgICAgICAgLmNvbHVtbjtcbiAgICAgICAgICAgICAgICBpZiAoY29sSWR4ICE9PSBsYXN0SWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICQodGFibGUuY2VsbHMoKS5ub2RlcygpKS5yZW1vdmVDbGFzcygnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgICQodGFibGUuY29sdW1uKGNvbElkeCkubm9kZXMoKSkuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgJCh0YWJsZS5jZWxscygpLm5vZGVzKCkpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBzaG93UHJlbGltaW5hcnlPdXRwdXQyKCk7XG4gICAgfTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogIHZpZXdcbiAgICAvLyAqKioqKiogIFByZWxpbWluYXJ5IFJlc3VsdHMgMiAtIGRyYXcgZmFjdG9yIHNjb3JlIHRhYmxlcyAgKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLy8gdG9kbyAtIHVzZSBkb2N1bWVudCBmcmFnbWVudCB0byBnZXQgcmlkIG9mIGFsbCB0aGVzZSBhcHBlbmRzXG5cbiAgICBmdW5jdGlvbiBzaG93UHJlbGltaW5hcnlPdXRwdXQyKCkge1xuXG4gICAgICAgIHZhciB1c2VyU2VsZWN0ZWRGYWN0b3JzID0gUUFWLmdldFN0YXRlKFwidXNlclNlbGVjdGVkRmFjdG9yc1wiKTtcblxuICAgICAgICAvLyAgdG9kbyAtIGZpeCBvcmRlcmluZyBlcnJvciBvZiBmYWN0b3JzIC0gdXNlIGxhcmdlIGRlbW8gc2V0IHdpdGggNyBmYWN0b3JzIHRvIHNlZSBlcnJvclxuICAgICAgICAvL3ZhciBkYXRhID0gUUFWLmdldFN0YXRlKFwib3V0cHV0U3ByZWFkc2hlZXRBcnJheVwiKTtcblxuXG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICB2YXIgY2hhcnRUZXh0MSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJGbGFnZ2VkIHEgLSBzb3J0IHdlaWdodHNcIl07XG4gICAgICAgIHZhciBjaGFydFRleHQyID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIkZsYWdnZWQgcS1zb3J0IGNvcnJlbGF0aW9uc1wiXTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDMgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiWi1zY29yZXMsIHNvcnQgdmFsdWVzLCByYXcgc29ydHNcIl07XG4gICAgICAgIHZhciBjaGFydFRleHQ0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlN0YXRlbWVudCBOdW1iZXJcIl07XG4gICAgICAgIHZhciBjaGFydFRleHQ1ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5TdGF0ZW1lbnQ7XG4gICAgICAgIHZhciBjaGFydFRleHQ2ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlotc2NvcmVcIl07XG4gICAgICAgIHZhciBjaGFydFRleHQ3ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlNvcnQgVmFsdWVzXCJdO1xuICAgICAgICB2YXIgY2hhcnRUZXh0OCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uV2VpZ2h0O1xuXG4gICAgICAgIHZhciBmYWN0b3JXZWlnaHRGYWN0b3JBcnJheSA9IFFBVi5nZXRTdGF0ZShcImZhY3RvcldlaWdodEZhY3RvckFycmF5SG9sZGVyXCIpO1xuICAgICAgICB2YXIgbWluaUNvcnJlbGF0aW9uQXJyYXkgPSBRQVYuZ2V0U3RhdGUoXCJtaW5pQ29ycmVsYXRpb25BcnJheUhvbGRlclwiKTtcbiAgICAgICAgdmFyIHN5bkZhY3RvckFycmF5MSA9IFFBVi5nZXRTdGF0ZShcInN5bkZhY3RvckFycmF5MUhvbGRlclwiKTtcblxuXG4gICAgICAgIC8vIFNUQVJUIEZPUiBFQUNIIEZBQ1RPUiBMT09QXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdXNlclNlbGVjdGVkRmFjdG9ycy5sZW5ndGg7IGorKykge1xuXG4gICAgICAgICAgICB2YXIgZmFjdG9yTnVtYmVyID0gaiArIDE7XG5cbiAgICAgICAgICAgIHZhciBmYWN0b3JINExhYmVsID0gXy5jYXBpdGFsaXplKHVzZXJTZWxlY3RlZEZhY3RvcnNbal0pO1xuXG4gICAgICAgICAgICAkKFwiI2ZhY3RvclRhYmxlc1wiKS5hcHBlbmQoJzxkaXYgY2xhc3M9XCJyZXN1bHRzTGFiZWwxXCI+PGg0PicgKyBmYWN0b3JINExhYmVsICsgJyAtICcgKyBjaGFydFRleHQxICsgJzwvaDQ+PC9kaXY+PHRhYmxlIGlkPVwiZmFjdG9yV2VpZ2h0UmVzdWx0cycgKyBmYWN0b3JOdW1iZXIgKyAnXCIgY2xhc3M9XCJkaXNwbGF5IGNvbXBhY3Qgbm93cmFwIGNlbGwtYm9yZGVyIHN0cmlwZVwiPjwvdGFibGU+Jyk7XG5cbiAgICAgICAgICAgIHZhciBuZXdXZWlnaHREYXRhID0gZmFjdG9yV2VpZ2h0RmFjdG9yQXJyYXlbal07XG4gICAgICAgICAgICBuZXdXZWlnaHREYXRhLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgd2VpZ2h0Q29sdW1uSGVhZGVycyA9IFt7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiUS1Tb3J0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1jZW50ZXJcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBjaGFydFRleHQ4LFxuICAgICAgICAgICAgICAgIGNsYXNzOiBcImR0LWhlYWQtY2VudGVyIGR0LWJvZHktY2VudGVyXCJcbiAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICAkKFwiI2ZhY3RvcldlaWdodFJlc3VsdHNcIiArIGZhY3Rvck51bWJlcikuRGF0YVRhYmxlKHtcbiAgICAgICAgICAgICAgICBcInJldHJpZXZlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJzZWFyY2hpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJvcmRlcmluZ1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwib3JkZXJcIjogW1xuICAgICAgICAgICAgICAgICAgICBbMSwgXCJkZXNjXCJdXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImluZm9cIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJzY3JvbGxZXCI6IDgwMCxcbiAgICAgICAgICAgICAgICBcInNjcm9sbENvbGxhcHNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJzY3JvbGxYXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJwYWdpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IG5ld1dlaWdodERhdGEsXG4gICAgICAgICAgICAgICAgXCJjb2x1bW5zXCI6IHdlaWdodENvbHVtbkhlYWRlcnMsXG4gICAgICAgICAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFt7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHM6IFswXSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZHQtYm9keS1jZW50ZXIgZHQtYm9keS1uYW1lJ1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogJ19hbGwnLFxuICAgICAgICAgICAgICAgICAgICBcImNyZWF0ZWRDZWxsXCI6IGZ1bmN0aW9uICh0ZCwgY2VsbERhdGEsIHJvd0RhdGEsIHJvdywgY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbERhdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0ZCkuY3NzKCdjb2xvcicsICdyZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJChcIiNmYWN0b3JUYWJsZXNcIikuYXBwZW5kKCc8ZGl2IGNsYXNzPVwicmVzdWx0c0xhYmVsMVwiPjxoND4nICsgZmFjdG9ySDRMYWJlbCArICcgLSAnICsgY2hhcnRUZXh0MiArICc8L2g0PjwvZGl2Pjx0YWJsZSBpZD1cImZhY3Rvck1pbmlDb3JyZWxSZXN1bHRzJyArIGZhY3Rvck51bWJlciArICdcIiBjbGFzcz1cImRpc3BsYXkgY29tcGFjdCBub3dyYXAgY2VsbC1ib3JkZXIgc3RyaXBlXCI+PC90YWJsZT4nKTtcblxuICAgICAgICAgICAgdmFyIG5ld01pbmlDb3JyRGF0YSA9IG1pbmlDb3JyZWxhdGlvbkFycmF5W2pdO1xuICAgICAgICAgICAgdmFyIG1pbmlDb3JyQ29sdW1uSGVhZGVycyA9IFt7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiUS1Tb3J0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1jZW50ZXJcIlxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbmV3TWluaUNvcnJEYXRhWzBdLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBPYmpNQyA9IHt9O1xuICAgICAgICAgICAgICAgIHRlbXBPYmpNQy50aXRsZSA9IG5ld01pbmlDb3JyRGF0YVswXVtrXTtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqTUMuY2xhc3MgPSBcImR0LWhlYWQtY2VudGVyIGR0LWJvZHktY2VudGVyXCI7XG4gICAgICAgICAgICAgICAgbWluaUNvcnJDb2x1bW5IZWFkZXJzLnB1c2godGVtcE9iak1DKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3TWluaUNvcnJEYXRhLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICQoXCIjZmFjdG9yTWluaUNvcnJlbFJlc3VsdHNcIiArIGZhY3Rvck51bWJlcikuRGF0YVRhYmxlKHtcbiAgICAgICAgICAgICAgICBcInJldHJpZXZlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJzZWFyY2hpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJvcmRlcmluZ1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImluZm9cIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJzY3JvbGxZXCI6IDgwMCxcbiAgICAgICAgICAgICAgICBcInNjcm9sbENvbGxhcHNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJzY3JvbGxYXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJwYWdpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IG5ld01pbmlDb3JyRGF0YSxcbiAgICAgICAgICAgICAgICBcImNvbHVtbnNcIjogbWluaUNvcnJDb2x1bW5IZWFkZXJzLFxuICAgICAgICAgICAgICAgIFwiY29sdW1uRGVmc1wiOiBbe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzOiBbMF0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2R0LWJvZHktY2VudGVyIGR0LWJvZHktbmFtZSdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHM6ICdfYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgXCJjcmVhdGVkQ2VsbFwiOiBmdW5jdGlvbiAodGQsIGNlbGxEYXRhLCByb3dEYXRhLCByb3csIGNvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxEYXRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGQpLmNzcygnY29sb3InLCAncmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQoXCIjZmFjdG9yVGFibGVzXCIpLmFwcGVuZCgnPGRpdiBjbGFzcz1cInJlc3VsdHNMYWJlbDFcIj48aDQ+JyArIGZhY3Rvckg0TGFiZWwgKyAnIC0gJyArIGNoYXJ0VGV4dDMgKyAnPC9oND48L2Rpdj48dGFibGUgaWQ9XCJwcmVsaW1SZXN1bHRzJyArIGZhY3Rvck51bWJlciArICdcIiBjbGFzcz1cImRpc3BsYXkgY29tcGFjdCBub3dyYXAgY2VsbC1ib3JkZXIgc3RyaXBlXCI+PC90YWJsZT4nKTtcblxuICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBzeW5GYWN0b3JBcnJheTFbal07XG5cbiAgICAgICAgICAgIC8vIHJlc29ydCBiYWNrIHRvIGhpZ2ggdG8gbG93IHotc2NvcmUgc29ydFxuICAgICAgICAgICAgbmV3RGF0YVxuICAgICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiW2NoYXJ0VGV4dDZdID09PSBhW2NoYXJ0VGV4dDZdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVtjaGFydFRleHQ0XSAtIGJbY2hhcnRUZXh0NF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYltjaGFydFRleHQ2XSAtIGFbY2hhcnRUZXh0Nl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGNvbHVtbkhlYWRlcnNBcnJheSA9IE9iamVjdC5rZXlzKG5ld0RhdGFbMF0pO1xuXG4gICAgICAgICAgICAvLyB0aGUgc2V0IGxlZnRtb3N0IDQgY29sdW1uc1xuICAgICAgICAgICAgdmFyIGNvbHVtbkhlYWRlcnMgPSBbe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBjaGFydFRleHQ0LFxuICAgICAgICAgICAgICAgIGNsYXNzOiBcImR0LWhlYWQtY2VudGVyIGR0LWJvZHktY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IGNoYXJ0VGV4dDRcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogY2hhcnRUZXh0NSxcbiAgICAgICAgICAgICAgICBjbGFzczogXCJkdC1oZWFkLWNlbnRlciBkdC1ib2R5LWxlZnRcIixcbiAgICAgICAgICAgICAgICBcImRhdGFcIjogY2hhcnRUZXh0NVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwiZGF0YVwiOiBjaGFydFRleHQ2LFxuICAgICAgICAgICAgICAgIHRpdGxlOiBjaGFydFRleHQ2LFxuICAgICAgICAgICAgICAgIGNsYXNzOiBcImR0LWhlYWQtY2VudGVyIGR0LWJvZHktcmlnaHRcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBjaGFydFRleHQ3LFxuICAgICAgICAgICAgICAgIGNsYXNzOiBcImR0LWhlYWQtY2VudGVyIGR0LWJvZHktY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IGNoYXJ0VGV4dDdcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgLy8gbG9vcGluZyBpbiBhbGwgb2YgdGhlIHJhdyBzb3J0IGNvbHVtbiBoZWFkZXJzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gNDsgaSA8IGNvbHVtbkhlYWRlcnNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wT2JqID0ge307XG4gICAgICAgICAgICAgICAgdGVtcE9iai50aXRsZSA9IGNvbHVtbkhlYWRlcnNBcnJheVtpXTtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqLmNsYXNzID0gXCJkdC1oZWFkLWNlbnRlciBkdC1ib2R5LWNlbnRlclwiO1xuICAgICAgICAgICAgICAgIHRlbXBPYmouZGF0YSA9IGNvbHVtbkhlYWRlcnNBcnJheVtpXTtcbiAgICAgICAgICAgICAgICBjb2x1bW5IZWFkZXJzLnB1c2godGVtcE9iaik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQoXCIjcHJlbGltUmVzdWx0c1wiICsgZmFjdG9yTnVtYmVyKS5EYXRhVGFibGUoe1xuICAgICAgICAgICAgICAgIFwiZml4ZWRDb2x1bW5zXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdENvbHVtbnM6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwicmV0cmlldmVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInNlYXJjaGluZ1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcIm9yZGVyaW5nXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJvcmRlclwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcImluZm9cIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJzY3JvbGxZXCI6IDgwMCxcbiAgICAgICAgICAgICAgICBcInNjcm9sbENvbGxhcHNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJzY3JvbGxYXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJwYWdpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IG5ld0RhdGEsXG4gICAgICAgICAgICAgICAgXCJjb2x1bW5zXCI6IGNvbHVtbkhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICB2aWV3XG4gICAgLy8gKioqKioqICBkeW5hbWljYWxsbHkgYXBwZW5kIGNoZWNrYm94cyB0byBzZWxlY3QgZmFjdG9ycyBmb3IgYW5hbHlzaXMgKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBQUkVMSU1PVVQuYXBwZW5kRmFjdG9yU2VsZWN0aW9uQ2hlY2tib3hlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgaGFzU3BsaXRGYWN0b3IgPSBRQVYuZ2V0U3RhdGUoXCJoYXNTcGxpdEZhY3RvclwiKTtcbiAgICAgICAgdmFyIGosXG4gICAgICAgICAgICBsZW4sXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgdGVtcDUsXG4gICAgICAgICAgICBwY2FGYWN0b3JMYWJlbHMgPSBbXTtcbiAgICAgICAgLy8gcmVhZCBpbiBmYWN0b3IgbGFiZWxzIHRvIGdlbmVyYXRlIGNoZWNrYm94ZXMgKGFuZCBjaGVja2luZyBmb3Igc3BsaXQgZmFjdG9yKVxuICAgICAgICB2YXIgZmFjdG9yc1RvU2VsZWN0O1xuXG4gICAgICAgIHZhciBsb29wTGVuO1xuICAgICAgICBsb29wTGVuID0gUUFWLmdldFN0YXRlKFwibnVtRmFjdG9yc1JldGFpbmVkXCIpO1xuXG4gICAgICAgIGlmIChoYXNTcGxpdEZhY3RvciA+IDApIHtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBRQVYuZ2V0U3RhdGUoXCJmYWN0b3JMYWJlbHNcIik7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICB0ZW1wMSxcbiAgICAgICAgICAgICAgICB0ZW1wMztcbiAgICAgICAgICAgIGZhY3RvcnNUb1NlbGVjdCA9IFtdO1xuXG4gICAgICAgICAgICBoZWFkZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICBoZWFkZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICBoZWFkZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICBoZWFkZXJzLnBvcCgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRlbXAxID0gaGVhZGVyc1tpXS50aXRsZTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcDEgIT09IFwiZmxhZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXAzID0gdGVtcDEucmVwbGFjZSgvRnRyL2csICdGYWN0b3InKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yc1RvU2VsZWN0LnB1c2godGVtcDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvb3BMZW4gPSBmYWN0b3JzVG9TZWxlY3QubGVuZ3RoO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChRQVYudHlwZU9mRmFjdG9yID09PSBcIlBDQVwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuID0gUUFWLm51bUZhY3RvcnNSZXRhaW5lZDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXA1ID0gXCJmYWN0b3IgXCIgKyAoayArIDEpO1xuICAgICAgICAgICAgICAgICAgICBwY2FGYWN0b3JMYWJlbHMucHVzaCh0ZW1wNSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmFjdG9yc1RvU2VsZWN0ID0gcGNhRmFjdG9yTGFiZWxzO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGZhY3RvcnNUb1NlbGVjdCA9IFFBVi5nZXRTdGF0ZShcImZhY3RvckxhYmVsc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoZmFjdG9yc1RvU2VsZWN0WzBdID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnNUb1NlbGVjdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFFBVi5zZXRTdGF0ZShcImZhY3RvckxhYmVsc0FycmF5XCIsIGZhY3RvcnNUb1NlbGVjdCk7XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIGNoZWNrYm94ZXMgYXJlIGFscmVhZHkgYXBwZW5kZWQsIGFuZCBpZiBzbyByZW1vdmUgdGhlbVxuICAgICAgICBWSUVXLnJlbW92ZU91dHB1dEZhY3RvckNoZWNrYm94ZXMoKTtcblxuICAgICAgICAvLyAgZ2VuZXJhdGUgYW5kIGFwcGVuZCBjaGVja2JveGVzXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsb29wTGVuOyBqKyspIHtcblxuICAgICAgICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIGNoZWNrYm94LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgICAgICBjaGVja2JveC5uYW1lID0gXCJhbmFseXNpc0ZhY3RvcnNcIjtcbiAgICAgICAgICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9IFwiZmFjdG9yU2VsZWN0Qm94XCI7XG4gICAgICAgICAgICBjaGVja2JveC52YWx1ZSA9IFwidmFsdWVcIjtcbiAgICAgICAgICAgIGNoZWNrYm94LmlkID0gZmFjdG9yc1RvU2VsZWN0W2pdO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgbGFiZWwuaHRtbEZvciA9IGZhY3RvcnNUb1NlbGVjdFtqXTtcbiAgICAgICAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoXCJjaGVja2JveExhYmVsXCIpO1xuICAgICAgICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZmFjdG9yc1RvU2VsZWN0W2pdKSk7XG4gICAgICAgICAgICBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC5nZXRFbGVtZW50QnlJZChcInNlbGVjdEZhY3RvcnNGb3JPdXRwdXREaXZcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kQ2hpbGQoY2hlY2tib3gpO1xuICAgICAgICAgICAgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAuZ2V0RWxlbWVudEJ5SWQoXCJzZWxlY3RGYWN0b3JzRm9yT3V0cHV0RGl2XCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICBcbiAgICAvLyAqKioqKioqKioqKioqKiAgcHVsbCB1c2VyLXNlbGVjdGVkIGZhY3RvcnMgZm9yIGFuYWx5c2lzICoqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBQUkVMSU1PVVQuZ2V0RmFjdG9yc0ZvckFuYWx5c2lzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hlY2tib3hlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCdhbmFseXNpc0ZhY3RvcnMnKTtcbiAgICAgICAgdmFyIHZhbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGVja2JveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tib3hlc1tpXS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgdmFscy5wdXNoKGNoZWNrYm94ZXNbaV0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInVzZXJTZWxlY3RlZEZhY3RvcnNcIiwgdmFscyk7XG4gICAgfTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgbW9kZWxcbiAgICAvLyAqKioqKioqKioqKioqKiAgcHVsbCBsb2FkaW5ncyB0aGF0IGhhdmUgYmVlbiBmbGFnZ2VkICAqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgUFJFTElNT1VULnB1bGxGbGFnZ2VkRmFjdG9yTG9hZGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBudW1iZXJGYWN0b3JzRXh0cmFjdGVkID0gcGFyc2VJbnQoUUFWLmdldFN0YXRlKFwibnVtYmVyRmFjdG9yc0V4dHJhY3RlZFwiKSk7XG4gICAgICAgIHZhciByZXN1bHRzID0gUUFWLmdldFN0YXRlKFwicmVzdWx0c1wiKTtcbiAgICAgICAgdmFyIGpMb29wTGVuID0gKG51bWJlckZhY3RvcnNFeHRyYWN0ZWQgKiAyKSArIDM7XG4gICAgICAgIHZhciBzaWduaWZpY2FudExvYWRpbmdzQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBqO1xuICAgICAgICB2YXIgaXNMb2FkaW5nU2lnbmlmaWNhbnQsXG4gICAgICAgICAgICBmYWN0b3JOdW1iZXIsXG4gICAgICAgICAgICByZXNwb25kZW50TmFtZSxcbiAgICAgICAgICAgIGZhY3RvckxvYWRpbmc7XG4gICAgICAgIC8vIHRvZG8gY2hlY2sgdG8gc2VlIGlmIHRoaXMgY2FuIGJlIHJlbW92ZWQgc2VlIGJpbmQgZHVtcCBidXR0b24gZnVuY3Rpb25cbiAgICAgICAgdmFyIGlMb29wTGVuID0gcmVzdWx0cy5sZW5ndGg7XG4gICAgICAgIHZhciBmYWN0b3JMYWJlbHNBcnJheSA9IFFBVi5nZXRTdGF0ZShcImZhY3RvckxhYmVsc0FycmF5XCIpO1xuICAgICAgICB2YXIgbG9hZGluZ1NvcnRDaGVja0FycmF5ID0gW107XG4gICAgICAgIHZhciB1c2VyU2VsZWN0ZWRGYWN0b3JzID0gUUFWLmdldFN0YXRlKFwidXNlclNlbGVjdGVkRmFjdG9yc1wiKTtcblxuICAgICAgICAvLyBsb29wIHRocnUgcmVzdWx0cyBhcnJheSB0byBmaW5kIHVzZXItc2VsZWN0ZWQgZmFjdG9yIGxvYWRpbmdzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpTG9vcExlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmFjdG9yTnVtYmVyQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSA0OyBqIDwgakxvb3BMZW47IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGlzTG9hZGluZ1NpZ25pZmljYW50ID0gcmVzdWx0c1tpXVtqXTtcbiAgICAgICAgICAgICAgICBmYWN0b3JOdW1iZXIgPSBmYWN0b3JMYWJlbHNBcnJheVtmYWN0b3JOdW1iZXJDb3VudF07XG4gICAgICAgICAgICAgICAgZmFjdG9yTnVtYmVyQ291bnQgPSBmYWN0b3JOdW1iZXJDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgcmVzcG9uZGVudE5hbWUgPSByZXN1bHRzW2ldWzFdO1xuICAgICAgICAgICAgICAgIGZhY3RvckxvYWRpbmcgPSByZXN1bHRzW2ldW2ogLSAxXTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGZsYWdnZWQgYW5kIGluIGEgdXNlci1zZWxlY3RlZCBmYWN0b3JcbiAgICAgICAgICAgICAgICBpZiAoaXNMb2FkaW5nU2lnbmlmaWNhbnQgPT09IFwidHJ1ZVwiICYmICh1c2VyU2VsZWN0ZWRGYWN0b3JzLmluZGV4T2YoZmFjdG9yTnVtYmVyKSA+IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQXJyYXkucHVzaChmYWN0b3JOdW1iZXIsIHJlc3BvbmRlbnROYW1lLCBmYWN0b3JMb2FkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1NvcnRDaGVja0FycmF5LnB1c2goZmFjdG9yTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVtcEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheS5wdXNoKDk5LCByZXNwb25kZW50TmFtZSwgXCJVbmlxdWUgU29ydFwiKTtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FudExvYWRpbmdzQXJyYXkucHVzaCh0ZW1wQXJyYXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FudExvYWRpbmdzQXJyYXkucHVzaCh0ZW1wQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHNvcnRzIGZsYWdnZWQgZm9yIG1vcmUgdGhhbiBvbmUgZmFjdG9yIHVzZXIgZXJyb3JcbiAgICAgICAgdmFyIG11bHRpcGxlRmxhZ3M7XG4gICAgICAgIHZhciBwcm9ibGVtU29ydDtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaWduaWZpY2FudExvYWRpbmdzQXJyYXkubGVuZ3RoOyBrKyspIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBzaWduaWZpY2FudExvYWRpbmdzQXJyYXlba107XG5cbiAgICAgICAgICAgIGlmICh0ZXN0Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICBwcm9ibGVtU29ydCA9IHNpZ25pZmljYW50TG9hZGluZ3NBcnJheVtrXVsxXTtcbiAgICAgICAgICAgICAgICBtdWx0aXBsZUZsYWdzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgdXNlci1zZWxlY3RlZCBmYWN0b3JzIHdpdGggbm8gbG9hZGluZyBzb3J0cyB1c2VyIGVycm9yXG4gICAgICAgIHZhciBsb2FkaW5nU29ydENoZWNrID0gJCh1c2VyU2VsZWN0ZWRGYWN0b3JzKVxuICAgICAgICAgICAgLm5vdChsb2FkaW5nU29ydENoZWNrQXJyYXkpXG4gICAgICAgICAgICAubGVuZ3RoID09PSAwO1xuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQxID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlRoZSBzb3J0IGZvciByZXNwb25kZW50XCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDIgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiaXMgZmxhZ2dlZCBmb3IgbW9yZSB0aGFuIG9uZSBmYWN0b3JcIl07XG5cbiAgICAgICAgaWYgKGxvYWRpbmdTb3J0Q2hlY2sgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBWSUVXLnNob3dOb1NvcnRzRmxhZ2dlZE9uRmFjdG9yTW9kYWwoKTtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZGlzcGxheSBvdXRwdXQgb2YgZmFjdG9yc1xuICAgICAgICAgICAgcmV0dXJuIFwiZmFsc2VcIjtcblxuICAgICAgICB9IGVsc2UgaWYgKG11bHRpcGxlRmxhZ3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAkKFwiI211bHRpcGxlRmxhZ01vZGFsTWVzc2FnZURpdiBwXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgJChcIiNtdWx0aXBsZUZsYWdNb2RhbE1lc3NhZ2VEaXZcIikuYXBwZW5kKFwiPHA+XCIgKyBhcHBlbmRUZXh0MSArIHByb2JsZW1Tb3J0ICsgYXBwZW5kVGV4dDIgKyBcIjwvcD5cIik7XG4gICAgICAgICAgICBWSUVXLnNob3dTb3J0RmxhZ2dlZE9uTXVsdGlwbGVGYWN0b3JzTW9kYWwoKTtcbiAgICAgICAgICAgIHJldHVybiBcImZhbHNlXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWduaWZpY2FudExvYWRpbmdzQXJyYXlcbiAgICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYVswXSA8IGJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYVswXSA+IGJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29tcHV0ZUZhY3RvcldlaWdodHMoc2lnbmlmaWNhbnRMb2FkaW5nc0FycmF5KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlRmFjdG9yV2VpZ2h0cyhzaWduaWZpY2FudExvYWRpbmdzQXJyYXkpIHtcbiAgICAgICAgLy8gc291cmNlIGNvZGUgbGluZSA0NDQwXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduaWZpY2FudExvYWRpbmdzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gZXZlblJvdW5kKChzaWduaWZpY2FudExvYWRpbmdzQXJyYXlbaV1bMl0pLCA4KTtcbiAgICAgICAgICAgIHZhciBmMiA9IGV2ZW5Sb3VuZCgoZiAqIGYpLCA4KTtcbiAgICAgICAgICAgIHZhciBvbmVNaW51c0YyLFxuICAgICAgICAgICAgICAgIHc7XG4gICAgICAgICAgICBpZiAoZjIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBvbmVNaW51c0YyID0gZjI7XG4gICAgICAgICAgICAgICAgdyA9IGV2ZW5Sb3VuZCgoZiAvIG9uZU1pbnVzRjIpLCA4KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZjIgPiAxKSB7XG4gICAgICAgICAgICAgICAgb25lTWludXNGMiA9IGV2ZW5Sb3VuZCgoMSAtIGYyKSwgOCk7XG4gICAgICAgICAgICAgICAgdyA9IGV2ZW5Sb3VuZCgoZiAvIC1vbmVNaW51c0YyKSwgOCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uZU1pbnVzRjIgPSBldmVuUm91bmQoKDEgLSBmMiksIDgpO1xuICAgICAgICAgICAgICAgIHcgPSBldmVuUm91bmQoKGYgLyBvbmVNaW51c0YyKSwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWduaWZpY2FudExvYWRpbmdzQXJyYXlbaV0ucHVzaCh3KTtcbiAgICAgICAgfVxuICAgICAgICBRQVYuc2V0U3RhdGUoXCJzb3J0V2VpZ2h0c1wiLCBzaWduaWZpY2FudExvYWRpbmdzQXJyYXkpO1xuXG4gICAgICAgIGZpbmRMYXJnZXN0RmFjdG9yV2VpZ2h0cyhzaWduaWZpY2FudExvYWRpbmdzQXJyYXkpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhcnJheSBvZiBoaWdoZXN0IHZhbHVlcyB0byB1c2UgbGF0ZXIgZm9yIGNhbGN1YXRpb25zXG4gICAgZnVuY3Rpb24gZmluZExhcmdlc3RGYWN0b3JXZWlnaHRzKHNpZ25pZmljYW50TG9hZGluZ3NBcnJheSkge1xuXG4gICAgICAgIC8vIHJlbW92ZSB1bmlxdWUgc29ydHMgKHZhbHVlIDk5KSBmcm9tIGFycmF5XG4gICAgICAgIHZhciBmYWN0b3JTZWxlY3QgPSBfLmZpbHRlcihzaWduaWZpY2FudExvYWRpbmdzQXJyYXksIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gblswXSAhPT0gOTk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHB1bGwgb3V0IGp1c3QgZmFjdG9yIG51bWJlciBhbmQgVyB2YWx1ZSB0byBhcnJheVxuICAgICAgICB2YXIgZmFjdG9yTnVtYmVyc0FycmF5MiA9IFtdO1xuICAgICAgICB2YXIgZmFjdG9yTnVtYmVyc0FycmF5ID0gW107XG4gICAgICAgIF8oZmFjdG9yU2VsZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5ID0gW107XG4gICAgICAgICAgICB2YXIgZmFjdG9yTnVtYmVyID0gblswXTtcbiAgICAgICAgICAgIGZhY3Rvck51bWJlcnNBcnJheTIucHVzaChmYWN0b3JOdW1iZXIpO1xuICAgICAgICAgICAgdmFyIGZhY3RvcldlaWdodFcgPSBuWzNdO1xuICAgICAgICAgICAgdGVtcEFycmF5WzBdID0gZmFjdG9yTnVtYmVyO1xuICAgICAgICAgICAgdGVtcEFycmF5WzFdID0gZmFjdG9yV2VpZ2h0VztcbiAgICAgICAgICAgIGZhY3Rvck51bWJlcnNBcnJheS5wdXNoKHRlbXBBcnJheSk7XG4gICAgICAgIH0pLnZhbHVlKCk7XG5cbiAgICAgICAgdmFyIHNpZ0FycmF5ID0gXy5jbG9uZURlZXAoZmFjdG9yTnVtYmVyc0FycmF5Mik7XG5cbiAgICAgICAgLy8gZ2V0IHVuaXF1ZSBhcnJheSBvZiBzaWduaWZpY2FudCBmYWN0b3JzIGxhYmVsc1xuICAgICAgICB2YXIgc2lnRmFjdG9yTnVtYmVyc0FycmF5ID0gXy51bmlxKHNpZ0FycmF5KTtcblxuICAgICAgICB2YXIgbWF4RmFjdG9yVmFsdWVzQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGZhY3RvclZhbHVlID0gMDtcbiAgICAgICAgXyhzaWdGYWN0b3JOdW1iZXJzQXJyYXkpLmZvckVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBfKGZhY3Rvck51bWJlcnNBcnJheSkuZmlsdGVyKGZ1bmN0aW9uIChqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpbMF0gPT09IHNpZ0FycmF5W2ZhY3RvclZhbHVlXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5MiA9IFtdO1xuICAgICAgICAgICAgdmFyIG1heEZhY3RvckxvYWRpbmdzID0gXyh0ZW1wKS5mb3JFYWNoKGZ1bmN0aW9uIChxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBWYXIzID0gZXZlblJvdW5kKChNYXRoLmFicygxIC8gcVsxXSkpLCA4KTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkyLnB1c2godGVtcFZhcjMpO1xuICAgICAgICAgICAgfSkudmFsdWUoKTtcblxuICAgICAgICAgICAgLy8gbnVtYmVycyBpbnZlcnRlZCwgc28gdXNpbmcgbWluIHJhdGhlciBtYXggc29tZXdoZXJlIGVsc2VcbiAgICAgICAgICAgIHZhciBtYXhGYWN0b3JWYWx1ZSA9IF8ubWluKHRlbXBBcnJheTIpO1xuXG4gICAgICAgICAgICBtYXhGYWN0b3JWYWx1ZXNBcnJheS5wdXNoKG1heEZhY3RvclZhbHVlKTtcblxuICAgICAgICAgICAgZmFjdG9yVmFsdWUgPSBmYWN0b3JWYWx1ZSArIDE7XG4gICAgICAgIH0pLnZhbHVlKCk7XG5cbiAgICAgICAgLy8gYXJyYXlcbiAgICAgICAgUUFWLnNldFN0YXRlKFwic2lnRmFjdG9yTnVtYmVyc0FycmF5XCIsIHNpZ0ZhY3Rvck51bWJlcnNBcnJheSk7XG5cbiAgICAgICAgLy8gaGlnaGVzdCB2YWx1ZXNcbiAgICAgICAgd2VpZ2h0RmFjdG9yU2NvcmVzKHNpZ25pZmljYW50TG9hZGluZ3NBcnJheSwgc2lnRmFjdG9yTnVtYmVyc0FycmF5LCBtYXhGYWN0b3JWYWx1ZXNBcnJheSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2VpZ2h0RmFjdG9yU2NvcmVzKHNpZ25pZmljYW50TG9hZGluZ3NBcnJheSwgc2lnRmFjdG9yTnVtYmVyc0FycmF5LCBtYXhGYWN0b3JWYWx1ZXNBcnJheSkge1xuICAgICAgICAvLyBwcm9kdWNlcyBhcnJheSB3aXRoIGZhY3RvciBudW1iZXIsIGZsYWdnZWQgcmVzcG9uZGVudCBuYW1lLCBhbmQgMiB3ZWlnaHQgdmFsdWVzXG4gICAgICAgIHZhciBzaWduaWZpY2FudEZhY3RvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSBzaWdGYWN0b3JOdW1iZXJzQXJyYXkubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNpZ25pZmljYW50TG9hZGluZ3NBcnJheS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wMSA9IHNpZ25pZmljYW50TG9hZGluZ3NBcnJheVtrXVswXTtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcDIgPSBzaWdGYWN0b3JOdW1iZXJzQXJyYXlbal07XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAxID09PSB0ZW1wMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGl2aXNvciA9IG1heEZhY3RvclZhbHVlc0FycmF5W2pdO1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FudExvYWRpbmdzQXJyYXlba11bM10gPSBldmVuUm91bmQoKHNpZ25pZmljYW50TG9hZGluZ3NBcnJheVtrXVszXSAqIGRpdmlzb3IpLCA4KSAqIDEwO1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FudEZhY3RvcnMucHVzaChzaWduaWZpY2FudExvYWRpbmdzQXJyYXlba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3ZWlnaHRSYXdTb3J0cyhzaWduaWZpY2FudEZhY3RvcnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlaWdodFJhd1NvcnRzKHNpZ25pZmljYW50RmFjdG9ycykge1xuICAgICAgICAvLyBwcm9kdWNlcyBNRCBhcnJheSB3aXRoIGZhY3RvciBudW1iZXIsIGZsYWdnZWQgcmVzcG9uZGVudCwgd2VpZ2h0ZWQgdmFsdWVzIGZvciBlYWNoIHN0YXRlbWVudCAoZm9yIGVhY2ggZmxhZ2dlZCByZXNwb25kZW50KVxuICAgICAgICB2YXIgcmVzcG9uZGVudE5hbWVzID0gUUFWLmdldFN0YXRlKFwicWF2UmVzcG9uZGVudE5hbWVzXCIpO1xuICAgICAgICB2YXIgcmF3U29ydHMgPSBRQVYuZ2V0U3RhdGUoXCJwb3NpdGl2ZVNoaWZ0ZWRSYXdTb3J0c1wiKTtcbiAgICAgICAgdmFyIHdlaWdodGVkU29ydHMgPSBbXTtcbiAgICAgICAgLy8gbm9ybWFsaXplIHdlaWdodHMgYnkgc29ydFxuICAgICAgICB2YXIgbm9ybWFsaXplZFNvcnRzID0gW107XG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBzTGVuID0gcmF3U29ydHMubGVuZ3RoOyBzIDwgc0xlbjsgcysrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5MmEgPSBbXTtcbiAgICAgICAgICAgIHZhciBzb3J0QXZlcmFnZSA9IFVUSUwuYXZlcmFnZShyYXdTb3J0c1tzXSk7XG4gICAgICAgICAgICB2YXIgc29ydFN0YW5kYXJkRGV2aWF0aW9uID0gVVRJTC5zdGFuZGFyZERldmlhdGlvbihyYXdTb3J0c1tzXSk7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMCwgckxlbiA9IHJhd1NvcnRzW3NdLmxlbmd0aDsgciA8IHJMZW47IHIrKykge1xuICAgICAgICAgICAgICAgIHZhciB6U2NvcmUgPSBldmVuUm91bmQoKChyYXdTb3J0c1tzXVtyXSAtIHNvcnRBdmVyYWdlKSAvIHNvcnRTdGFuZGFyZERldmlhdGlvbiksIDMpO1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheTJhLnB1c2goelNjb3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1hbGl6ZWRTb3J0cy5wdXNoKHRlbXBBcnJheTJhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmF3U29ydHNQcmVwID0gXy56aXAocmVzcG9uZGVudE5hbWVzLCBub3JtYWxpemVkU29ydHMpO1xuXG4gICAgICAgIC8vIG11bHRpcGx5IG5vcm1haXplZCBzb3J0cyBieSB3ZWlnaHRpbmcgdmFsdWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBzaWduaWZpY2FudEZhY3RvcnMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IHJhd1NvcnRzUHJlcC5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcDEgPSBzaWduaWZpY2FudEZhY3RvcnNbaV1bMV07XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAyID0gcmF3U29ydHNQcmVwW2pdWzBdO1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wMyA9IHJhd1NvcnRzUHJlcFtqXVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcDQgPSBzaWduaWZpY2FudEZhY3RvcnNbaV1bM107XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wMSA9PT0gdGVtcDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1dlaWdodGVkU29ydCA9IF8ubWFwKHRlbXAzLCByb3VuZE51bWJlcnMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGZhY3RvciBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgdGVtcEFycmF5LnB1c2goc2lnbmlmaWNhbnRGYWN0b3JzW2ldWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCByZXNwb25kZW50IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgdGVtcEFycmF5LnB1c2godGVtcDEpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQXJyYXkucHVzaChuZXdXZWlnaHRlZFNvcnQpO1xuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRlZFNvcnRzLnB1c2godGVtcEFycmF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29tYmluZVdlaWdodGVkU29ydHMod2VpZ2h0ZWRTb3J0cyk7XG5cbiAgICAgICAgZnVuY3Rpb24gcm91bmROdW1iZXJzKG4pIHtcbiAgICAgICAgICAgIHZhciB0ZW1wNSA9IGV2ZW5Sb3VuZCgobiAqIHRlbXA0KSwgOCk7XG4gICAgICAgICAgICByZXR1cm4gdGVtcDU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21iaW5lV2VpZ2h0ZWRTb3J0cyh3ZWlnaHRlZFNvcnRzKSB7XG4gICAgICAgIHZhciBzaWdGYWN0b3JOdW1iZXJzQXJyYXkxID0gUUFWLmdldFN0YXRlKFwic2lnRmFjdG9yTnVtYmVyc0FycmF5XCIpO1xuICAgICAgICB2YXIgc2lnRmFjdG9yTnVtYmVyc0FycmF5ID0gc2lnRmFjdG9yTnVtYmVyc0FycmF5MS5zb3J0KCk7XG4gICAgICAgIHZhciB0ZW1wQXJyYXkyLFxuICAgICAgICAgICAgc3VtbWVkV2VpZ2h0ZWRTb3J0cztcblxuICAgICAgICBzdW1tZWRXZWlnaHRlZFNvcnRzID0gW107XG4gICAgICAgIHZhciBzaWdTb3J0c0FycmF5ID0gW107XG5cbiAgICAgICAgLy8gbG9vcGluZyB0aHJvdWdoIGFsbCBzZWxlY3RlZCBmYWN0b3IgbmFtZXMgaW4gc2lnIGZhY3RvciBhcnJheVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IHNpZ0ZhY3Rvck51bWJlcnNBcnJheS5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZW1wQXJyYXk0ID0gW107XG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5MSA9IFtdO1xuICAgICAgICAgICAgdmFyIGZhY3RvciA9IHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtpXTtcbiAgICAgICAgICAgIHRlbXBBcnJheTIgPSBbXTtcbiAgICAgICAgICAgIHZhciB0ZW1wT2JqMiA9IHt9O1xuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIGRhdGEgZm9yIGFsbCBmYWN0b3JzIGFuZCBwdWxsIGRhdGEgZm9yIG9ubHkgZm9yIHNlbGVjdGVkIGZhY3RvcnNcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gd2VpZ2h0ZWRTb3J0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcDIgPSB3ZWlnaHRlZFNvcnRzW2pdWzBdOyAvLyBnaXZlcyBudW1iZXIgMSBvciAyIG9yIDMgZXRjLi4uXG4gICAgICAgICAgICAgICAgaWYgKHRlbXAyID09PSBmYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEFycmF5MS5wdXNoKHdlaWdodGVkU29ydHNbal1bMl0pOyAvLyBwdXNoZXMgd2VpZ2h0IGZvciBlYWNoIHN0YXRlbWVudFxuICAgICAgICAgICAgICAgICAgICB0ZW1wQXJyYXkyLnB1c2god2VpZ2h0ZWRTb3J0c1tqXVsxXSk7IC8vIHB1c2hlcyBmbGFnZ2VkIHNvcnQgcmVzcG9uZGVudCBuYW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwdXNoZXMgZmFjdG9yIG51bWJlcnMgYW5kIHJlcHJlc2VudGF0aXZlIHNvcnRzIGludG8gYXJyYXlcbiAgICAgICAgICAgIHRlbXBBcnJheTQucHVzaChmYWN0b3IpOyAvLyBhcnJheSBvZiBuYW1lcyBvZiB1c2VyIHNlbGVjdGVkIGZhY3RvcnNcbiAgICAgICAgICAgIHRlbXBBcnJheTQucHVzaCh0ZW1wQXJyYXkyKTsgLy8gYXJyYXkgb2YgZmxhZ2dlZCByZXNwb25kZW50IG5hbWVzXG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnRzIGFycmF5IG9mIGZhY3RvciBudW1iZXJzIGFuZCByZXAgc29ydHMgdG8gb2JqZWN0XG4gICAgICAgICAgICB0ZW1wT2JqMltcIkZhY3RvciBOdW1iZXJcIl0gPSBmYWN0b3I7XG4gICAgICAgICAgICB0ZW1wT2JqMi5TaWdTb3J0cyA9IHRlbXBBcnJheTI7XG4gICAgICAgICAgICBzaWdTb3J0c0FycmF5LnB1c2godGVtcE9iajIpO1xuXG4gICAgICAgICAgICAvLyBzdW1taW5nIHdlaWdodHMgZm9yIHN0YXRlbWVudHMgYWNyb3NzIGZsYWdnZWQgc29ydHMgZm9yIGVhY2ggZmFjdG9yXG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5MyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGtMZW4gPSB0ZW1wQXJyYXkxWzBdLmxlbmd0aDsgayA8IGtMZW47IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wMyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDAsIG1MZW4gPSB0ZW1wQXJyYXkxLmxlbmd0aDsgbSA8IG1MZW47IG0rKykge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wMyA9IGV2ZW5Sb3VuZCgodGVtcDMgKyB0ZW1wQXJyYXkxW21dW2tdKSwgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXBBcnJheTMucHVzaCh0ZW1wMyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlLW5vcm1hbGl6ZSBmYWN0b3IgbG9hZGluZ3MgYWZ0ZXIgc3VtbWluZyBhY3Jvc3Mgc3RhdGVtZW50c1xuICAgICAgICAgICAgdmFyIHRlbXBBcnJheTNhID0gW107XG4gICAgICAgICAgICB2YXIgc29ydEF2ZXJhZ2UgPSBVVElMLmF2ZXJhZ2UodGVtcEFycmF5Myk7XG4gICAgICAgICAgICB2YXIgc29ydFN0YW5kYXJkRGV2aWF0aW9uID0gVVRJTC5zdGFuZGFyZERldmlhdGlvbih0ZW1wQXJyYXkzKTtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCByTGVuID0gdGVtcEFycmF5My5sZW5ndGg7IHIgPCByTGVuOyByKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgelNjb3JlID0gZXZlblJvdW5kKCgodGVtcEFycmF5M1tyXSAtIHNvcnRBdmVyYWdlKSAvIHNvcnRTdGFuZGFyZERldmlhdGlvbiksIDMpO1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheTNhLnB1c2goelNjb3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBBcnJheTQucHVzaCh0ZW1wQXJyYXkzYSk7XG4gICAgICAgICAgICBzdW1tZWRXZWlnaHRlZFNvcnRzLnB1c2godGVtcEFycmF5NCk7XG4gICAgICAgIH1cbiAgICAgICAgUUFWLnNldFN0YXRlKFwic2lnU29ydHNBcnJheVwiLCBzaWdTb3J0c0FycmF5KTtcbiAgICAgICAgY2FsY3VsYXRlWlNjb3JlcyhzdW1tZWRXZWlnaHRlZFNvcnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVaU2NvcmVzKHN1bW1lZFdlaWdodGVkU29ydHMpIHtcbiAgICAgICAgLy8gY2hhbmdpbmcgZm9ybWF0IGZyb20gTUQgYXJyYXkgdG8gYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAgICAvLyBhZGQgaW4gc3RhdGVtZW50c1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IFFBVi5nZXRTdGF0ZShcInFhdkN1cnJlbnRTdGF0ZW1lbnRzXCIpO1xuICAgICAgICB2YXIgc2lnRmFjdG9yTnVtYmVyc0FycmF5ID0gUUFWLmdldFN0YXRlKFwic2lnRmFjdG9yTnVtYmVyc0FycmF5XCIpO1xuICAgICAgICAvLyBzbyB0aGF0IHRoZSBkaWZmIDIgZmFjdG9ycyBvdXRwdXQgaXMgY29ycmVjdFxuICAgICAgICBzaWdGYWN0b3JOdW1iZXJzQXJyYXkuc29ydCgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gc3VtbWVkV2VpZ2h0ZWRTb3J0cy5sZW5ndGg7XG4gICAgICAgIHZhciB6U2NvcmVBcnJheSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB6U2NvcmVUZW1wT2JqID0ge307XG4gICAgICAgICAgICB6U2NvcmVUZW1wT2JqLmZhY3RvciA9IHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtpXTtcbiAgICAgICAgICAgIHZhciB0ZW1wQXJyYXkxID0gW107XG4gICAgICAgICAgICB2YXIgelNjb3JlVGVtcEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1bW1lZFdlaWdodGVkU29ydHNbMF1bMl0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcE9iaiA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciB6U2NvcmUgPSBldmVuUm91bmQoKHN1bW1lZFdlaWdodGVkU29ydHNbaV1bMl1bal0pLCAzKTtcblxuICAgICAgICAgICAgICAgIHRlbXBPYmouZmFjdG9yID0gc2lnRmFjdG9yTnVtYmVyc0FycmF5W2ldO1xuICAgICAgICAgICAgICAgIHRlbXBPYmouc3RhdGVtZW50ID0gKGogKyAxKTtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqLnNvcnRTdGF0ZW1lbnQgPSBzdGF0ZW1lbnRzW2pdO1xuICAgICAgICAgICAgICAgIHRlbXBPYmouelNjb3JlID0gelNjb3JlO1xuXG4gICAgICAgICAgICAgICAgelNjb3JlVGVtcEFycmF5LnB1c2goelNjb3JlKTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxLnB1c2godGVtcE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB6U2NvcmVBcnJheS5wdXNoKHRlbXBBcnJheTEpO1xuICAgICAgICAgICAgelNjb3JlVGVtcE9ialtcIkZhY3RvclpzY29yZXNcIiArIHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtpXV0gPSB6U2NvcmVUZW1wQXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduRmFjdG9yU2NvcmVzKHpTY29yZUFycmF5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NpZ25GYWN0b3JTY29yZXMoelNjb3JlQXJyYXkpIHtcbiAgICAgICAgdmFyIHFhdlNvcnRUcmlhbmdsZVNoYXBlID0gUUFWLmdldFN0YXRlKFwicWF2U29ydFRyaWFuZ2xlU2hhcGVcIik7XG4gICAgICAgIHZhciBzb3J0ZWRaU2NvcmVBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpTY29yZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmFjdG9yTnVtYmVycyA9IHpTY29yZUFycmF5W2ldO1xuXG4gICAgICAgICAgICB2YXIgdGVtcDEgPSBfLmNsb25lRGVlcChmYWN0b3JOdW1iZXJzKTtcblxuICAgICAgICAgICAgdGVtcDEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGlmIChhLnpTY29yZSA9PT0gYi56U2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIuc3RhdGVtZW50IC0gYS5zdGF0ZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuelNjb3JlIC0gYi56U2NvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcWF2U29ydFRyaWFuZ2xlU2hhcGUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0ZW1wMVtqXS5zb3J0VmFsdWUgPSBxYXZTb3J0VHJpYW5nbGVTaGFwZVtqXTtcbiAgICAgICAgICAgICAgICB0ZW1wMVtqXS5zaWdWaXN1YWxpemF0aW9uID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXAxLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGF0ZW1lbnQgLSBiLnN0YXRlbWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc29ydGVkWlNjb3JlQXJyYXkucHVzaCh0ZW1wMSk7XG4gICAgICAgIH1cbiAgICAgICAgUUFWLnNldFN0YXRlKFwiYW5hbHlzaXNPdXRwdXRcIiwgc29ydGVkWlNjb3JlQXJyYXkpO1xuICAgIH1cblxufSh3aW5kb3cuUFJFTElNT1VUID0gd2luZG93LlBSRUxJTU9VVCB8fCB7fSwgUUFWKSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvUFJFTElNT1VULmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDYiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=')}});