!function(g){function I(n){if(C[n])return C[n].exports;var A=C[n]={i:n,l:!1,exports:{}};return g[n].call(A.exports,A,A.exports,I),A.l=!0,A.exports}var C={};I.m=g,I.c=C,I.i=function(g){return g},I.d=function(g,C,n){I.o(g,C)||Object.defineProperty(g,C,{configurable:!1,enumerable:!0,get:n})},I.n=function(g){var C=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(C,"a",C),C},I.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},I.p="",I(I.s=0)}([function(module,exports){eval('//Ken-Q Analysis\n//Copyright (C) 2016 Shawn Banasick\n//\n//    This program is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, either version 3 of the License, or\n//    (at your option) any later version.\n\n\n// JSlint declarations\n/* global performance, window, QAV, $, document, resources, evenRound, UTIL, _ */\n\n(function (CENTROID, QAV, undefined) {\n\n    // todo - fix parseInt by adding second value\n    // ******************************************************  controller\n    // ***** controller for factor extraction **************************\n    // *****************************************************************\n    // todo - refactor onclick handler from html\n    CENTROID.fireFactorExtraction = function () {\n        var t0 = performance.now(),\n            t1;\n        var factors = document.getElementById("factorSelect");\n        var selectedNumberFactors = factors.options[factors.selectedIndex].value;\n        var loopLength = parseInt(selectedNumberFactors);\n        var dataArray = QAV.getState("originalCorrelationValues");\n        var factorMatrix = [];\n        var factorDisplayNameArray = [];\n        var d3ChartFactorNames = [];\n        var factorName, d3FactorName, tempArray;\n        var factorMatrix1, numberSorts, num, eigen;\n        var eigenvalues = [];\n        var explainedVariance = [];\n        var respondentNames, totalVariance, table, language, facText;\n        var isRotatedFactorsTableUpdate;\n        QAV.setState("numberFactorsExtracted", loopLength);\n        QAV.numFactorsExtracted = loopLength;\n        var i, j, jLen, q, qLen;\n        var iLen = loopLength + 1;\n        var factorMatrixToFixed5, factorMatrixTransposed, varText, eigenText;\n        var expVar2, rotFacStateArrayPrep1, rotFacStateArrayPrep2;\n\n        // determine if is this is a rotation table re-draw or not\n        table = $(\'#factorRotationTable2 tr\').length; //\n        if (table > 0) {\n            isRotatedFactorsTableUpdate = "destroy";\n        } else {\n            isRotatedFactorsTableUpdate = "no";\n        }\n\n        language = QAV.getState("language");\n        facText = resources[language].translation.Factor;\n\n        // used for section 6 text labels\n        for (i = 1; i < iLen; i++) {\n            factorName = facText + " " + i;\n            d3FactorName = facText + " " + i;\n            // added for D3 because of unknown comma insertion in factorDispalyNameArray\n            d3ChartFactorNames.push(d3FactorName);\n            tempArray = CENTROID.calculateFactorLoadings(dataArray);\n            factorMatrix.push(tempArray[0]);\n            dataArray = tempArray[1];\n            factorDisplayNameArray.push(factorName);\n        }\n\n        QAV.setState("factorLabels", factorDisplayNameArray);\n        // QAV.factorLabels = factorDisplayNameArray;\n\n        // \n        factorMatrix1 = _.cloneDeep(factorMatrix, true);\n        var centroidFactors = _.cloneDeep(factorMatrix);\n\n        // send and save  to varimax rotation\n        // todo - change this name to clarify for PCA\n        QAV.setState("centroidFactors", centroidFactors);\n\n        // todo change to analysis global object setting\n        numberSorts = QAV.getState("qavTotalNumberSorts");\n        respondentNames = QAV.getState("qavRespondentNames");\n\n        // eigenvalue calculations\n        explainedVarianceAndEigens = CENTROID.calcEigenValues(factorMatrix1, numberSorts);\n        eigenvalues = explainedVarianceAndEigens[0];\n        explainedVariance = explainedVarianceAndEigens[1];\n\n        // shift data to fixed 5\n        factorMatrixToFixed5 = [];\n        _(factorMatrix).forEach(function (arrayFrag) {\n            var tableFormatFragment = _.map(arrayFrag, function (a) {\n                return (evenRound(a, 5));\n            });\n            factorMatrixToFixed5.push(tableFormatFragment);\n        }).value();\n\n\n        factorMatrixToFixed5.unshift(respondentNames);\n        factorMatrixTransposed = _.zip.apply(_, factorMatrixToFixed5);\n\n        // var language = QAV.getState("language");\n        varText = resources[language].translation["% explained variance"];\n        eigenText = resources[language].translation.Eigenvalues;\n\n\n        eigenvalues.unshift(eigenText);\n        explainedVariance.unshift(varText);\n\n        QAV.centroidEigenvalues = eigenvalues;\n\n        factorMatrixTransposed.push(eigenvalues);\n        factorMatrixTransposed.push(explainedVariance);\n        factorDisplayNameArray.unshift("");\n        factorMatrixTransposed.unshift(factorDisplayNameArray);\n\n\n        expVar2 = factorMatrixTransposed.pop();\n        QAV.setState("expVarCentroid", expVar2);\n\n        // add to QAV - used in results download cumulative commonalities section\n        QAV.setState("factorMatrixTransposed", factorMatrixTransposed);\n\n        t1 = performance.now();\n\n        console.log(\'%c Centroid factor extraction completed in  \' + (t1 - t0).toFixed(0) + \' milliseconds\', \'background: #FF5733; color: white\');\n\n\n        // todo - clean up this array prep mess - refactor to function\n        rotFacStateArrayPrep1 = _.cloneDeep(factorMatrixToFixed5);\n        rotFacStateArrayPrep1.shift();\n        rotFacStateArrayPrep2 = _.zip.apply(_, rotFacStateArrayPrep1);\n        QAV.centroidFactors = rotFacStateArrayPrep2;\n    };\n\n    CENTROID.calcEigenValues = function (factorMatrix1, numberSorts) {\n        // eigenvalue calculations\n        var explainedVariance = [];\n        var eigenvalues = [];\n        for (var j = 0, jLen = factorMatrix1.length; j < jLen; j++) {\n            num = factorMatrix1[j];\n            for (q = 0, qLen = num.length; q < qLen; q++) {\n                num[q] = evenRound((num[q] * num[q]), 8);\n            }\n            eigen = evenRound((_.reduce(num, function (sum, num2) {\n                return sum + num2;\n            })), 5);\n\n            eigenvalues.push(eigen);\n            totalVariance = evenRound((100 * (eigen / numberSorts)), 0);\n            explainedVariance.push(totalVariance);\n        }\n        return [eigenvalues, explainedVariance];\n    };\n\n\n    CENTROID.calculateFactorLoadings = function (dataArray) {\n        var reflectedArray = CENTROID.checkPositiveManifold(dataArray);\n        var reflectedArray1 = reflectedArray[0]; // reflected array\n        var reflectedArrayColumnTotals = reflectedArray[1]; // column totals\n        var reflectedRowCol = reflectedArray[2];\n        var factorLoads1 = CENTROID.calculateFactor(reflectedArray1, reflectedArrayColumnTotals);\n        var subtractArray = CENTROID.removeCorrelations(reflectedArray1, factorLoads1);\n        var undoPositiveManifold = CENTROID.undoReflection(subtractArray, factorLoads1, reflectedRowCol);\n        var factorSubtractedArray = undoPositiveManifold[0];\n        var factorFactorScores = undoPositiveManifold[1];\n        var results = [factorFactorScores, factorSubtractedArray];\n        return results;\n    }; // end function fireCalculateFactors\n\n    CENTROID.drawExtractedFactorsTable = function () {\n        var centroidFactors = QAV.getState("centroidFactors");\n        var i, iLen, j, k, names;\n        var temp1, loopLen, targets, slicedTargets, headers;\n        var language, facText, respondText, appendText;\n        var configObj = {};\n\n        names = QAV.getState("respondentNames") || [];\n\n        if (names[0] === "") {\n            names.shift();\n        }\n\n        for (i = 0, iLen = centroidFactors.length; i < iLen; i++) {\n            j = i + 1;\n            centroidFactors[i].unshift(j, names[i]);\n        }\n\n        language = QAV.getState("language");\n        facText = resources[language].translation.Factor;\n        respondText = resources[language].translation.Respondent;\n        appendText = resources[language].translation["Centroid Factors Extracted"];\n\n        headers = [{\n            title: "Num."\n        }, {\n            title: respondText\n        }];\n\n        // make headers dynamic\n        loopLen = (centroidFactors[0].length) - 2;\n        for (k = 0; k < loopLen; k++) {\n            temp1 = {};\n            temp1.title = facText + " " + (k + 1);\n            headers.push(temp1);\n        }\n\n        // make targets dynamic\n        targets = [2, 3, 4, 5, 6, 7, 8, 9];\n        slicedTargets = targets.slice(0, loopLen);\n\n        configObj.domElement = "#factorRotationTable1";\n        configObj.fixed = false;\n        configObj.data = centroidFactors;\n        configObj.headers = headers;\n        configObj.colDefs = [{\n                targets: [0, 1],\n                className: \'dt-head-center dt-body-center dt-body-name\'\n            },\n            {\n                targets: slicedTargets,\n                className: \'dt-head-center dt-body-right\'\n            },\n            {\n                targets: \'_all\',\n                "createdCell": function (td, cellData) { // , rowData, row, col\n                    if (cellData < 0) {\n                        $(td).css(\'color\', \'red\');\n                    }\n                }\n            }\n        ];\n\n        UTIL.drawDatatable(configObj);\n\n        $("#rotationHistoryList").append(\'<li>\' + QAV.numFactorsExtracted + appendText + \'</li>\');ã€€\n\n        CENTROID.createFooterTable(headers, slicedTargets);\n\n    };\n\n    CENTROID.createFooterTable = function (headers, slicedTargets) {\n        var eigenValues, percentExplainedVariance, loopLen1, m, headers2;\n        var data = [];\n        var tempArray = [];\n        var tempObj = {};\n        var value = 0;\n        var language = QAV.getState("language");\n        var cumVarText = resources[language].translation["Cum % Expln Var"];\n        var tempObj2 = tempObj;\n        var configObj = {};\n\n        eigenValues = QAV.getState("centroidEigenvalues");\n        eigenValues.unshift("");\n        percentExplainedVariance = QAV.getState("expVarCentroid");\n        percentExplainedVariance.unshift("");\n        loopLen1 = percentExplainedVariance.length;\n\n        for (m = 2; m < loopLen1; m++) {\n            value = value + percentExplainedVariance[m];\n            tempArray.push(value);\n        }\n\n        tempArray.unshift("", cumVarText);\n\n        data.push(eigenValues, percentExplainedVariance, tempArray);\n\n        headers2 = headers.slice(2, headers.length);\n        tempObj.title = "";\n\n        headers2.unshift(tempObj, tempObj2);\n\n        configObj.domElement = "#factorRotationTable1Footer";\n        configObj.fixed = false;\n        configObj.data = data;\n        configObj.headers = headers2;\n        configObj.ordering = false;\n        configObj.colDefs = [{\n                targets: [0, 1],\n                className: \'dt-head-center dt-body-center dt-body-name\'\n            },\n            {\n                targets: slicedTargets,\n                className: \'dt-head-center dt-body-right\'\n            },\n            {\n                targets: \'_all\',\n                "createdCell": function (td, cellData) { // , rowData, row, col\n                    if (cellData < 0) {\n                        $(td).css(\'color\', \'red\');\n                    }\n                }\n            }\n        ];\n        UTIL.drawDatatable(configObj);\n        return configObj;\n    };\n\n    // ***********************************************************************   model\n    // ***** Calculate Factors *******************************************************\n    // *******************************************************************************\n    CENTROID.calculateFactor = function (reflectedArray, columnTotals) {\n        console.time("total calculation time ");\n        var totalsSums, totalsSumsSqrt, factorLoad1, factorLoad1Sqrd, diffDiagonalEstimateandFactorLoad;\n        var colTotalsAndMeanSum = [];\n\n        for (var i = 0, iLen = columnTotals.length; i < iLen; i++) {\n            colTotalsAndMeanSum.push(evenRound((columnTotals[i] + 0.5), 8)); // 0.5 as used in PQMethod\n        }\n\n        totalsSums = _.reduce(colTotalsAndMeanSum, function (sum, num) {\n            return sum + num;\n        });\n\n        totalsSumsSqrt = evenRound((Math.sqrt(totalsSums)), 8);\n\n        factorLoad1 = _.map(colTotalsAndMeanSum, function (num) {\n            return evenRound((num / totalsSumsSqrt), 8);\n        });\n\n        factorLoad1Sqrd = _.map(factorLoad1, function (num) {\n            return evenRound((num * num), 8);\n        }); // comparison 2\n\n        diffDiagonalEstimateandFactorLoad = [];\n        for (var j = 0, jLen = factorLoad1Sqrd.length; j < jLen; j++) {\n            diffDiagonalEstimateandFactorLoad.push(Math.abs(evenRound((factorLoad1Sqrd[j] - 0.5), 8)));\n        }\n\n        var maxDiff = _.max(diffDiagonalEstimateandFactorLoad);\n\n        function totalSumsFunction(newDiagonalEstimate) {\n            var totalsSums = _.reduce(newDiagonalEstimate, function (sum, num) {\n                return evenRound((sum + num), 8);\n            });\n            return totalsSums;\n        }\n\n        function factorLoad1Function(newDiagonalEstimate) {\n            factorLoad1 = _.map(newDiagonalEstimate, function (num) {\n                return evenRound((num / totalsSumsSqrt), 8);\n            }); // Math.round10\n            return factorLoad1;\n        }\n\n        function factorLoad1SqrdFunction(factorLoad1) {\n            factorLoad1Sqrd = _.map(factorLoad1, function (num) {\n                return evenRound((num * num), 8);\n            });\n            return factorLoad1Sqrd;\n        }\n\n        if (maxDiff > 0.001) {\n\n            do {\n\n                var previousFactorLoadEstimate = factorLoad1Sqrd;\n\n                var newDiagonalEstimate = [];\n                for (var k = 0, kLen = columnTotals.length; k < kLen; k++) {\n                    newDiagonalEstimate.push(evenRound((columnTotals[k] + previousFactorLoadEstimate[k]), 8));\n                }\n\n                totalsSums = totalSumsFunction(newDiagonalEstimate);\n\n                totalsSumsSqrt = evenRound((Math.sqrt(totalsSums)), 8);\n\n                factorLoad1 = factorLoad1Function(newDiagonalEstimate);\n\n                factorLoad1Sqrd = factorLoad1SqrdFunction(factorLoad1);\n\n                diffDiagonalEstimateandFactorLoad = [];\n                for (var m = 0, mLen = previousFactorLoadEstimate.length; m < mLen; m++) {\n                    diffDiagonalEstimateandFactorLoad.push(Math.abs(evenRound((previousFactorLoadEstimate[m] - factorLoad1Sqrd[m]), 8)));\n                }\n\n                maxDiff = _.max(diffDiagonalEstimateandFactorLoad);\n\n            } while (maxDiff > 0.001);\n\n            console.timeEnd("total calculation time ");\n            return factorLoad1;\n        } else {\n            return factorLoad1; // todo - straighten out this code\n        }\n    };\n\n    // **************************************************************   model\n    // ***** remove factor  correlations************************************\n    // *********************************************************************\n    CENTROID.removeCorrelations = function (array, factorLoadings) {\n        var factorCorrelations = [];\n\n        function helper1(factorLoadings) {\n            _(factorLoadings).forEach(function (num) {\n                var temp = num * factorLoadings[i];\n                newArrayFrag.push(evenRound((temp), 8));\n            }).value();\n            return newArrayFrag;\n        }\n        for (var i = 0, iLen = factorLoadings.length; i < iLen; i++) {\n            var newArrayFrag = [];\n            newArrayFrag = helper1(factorLoadings);\n            factorCorrelations.push(newArrayFrag);\n        }\n        var residualCorrelationsPrep = [];\n        for (var j = 0, jLen = factorLoadings.length; j < jLen; j++) {\n            var subtractionFrag = [];\n            for (var k = 0, kLen = factorLoadings.length; k < kLen; k++) {\n                subtractionFrag.push(evenRound((array[j][k] - factorCorrelations[j][k]), 8));\n            }\n            residualCorrelationsPrep.push(subtractionFrag);\n        }\n        for (var p = 0, pLen = factorLoadings.length; p < pLen; p++) {\n            var m = p;\n            residualCorrelationsPrep[p][m] = 1;\n        }\n        return residualCorrelationsPrep;\n    };\n\n    // *****************************************************************   model\n    // *****  undo Array Reflection  *******************************************\n    // *************************************************************************\n    CENTROID.undoReflection = function (subtractedArray, factorLoadings, reflectedRowCol) {\n        _(reflectedRowCol).forEach(function (rowcolnumber) {\n            for (var i = 0; i < subtractedArray.length; i++) {\n                subtractedArray[i][rowcolnumber] = subtractedArray[i][rowcolnumber] * -1;\n            }\n            for (var j = 0; j < subtractedArray[rowcolnumber].length; j++) {\n                subtractedArray[rowcolnumber][j] = subtractedArray[rowcolnumber][j] * -1;\n            }\n            factorLoadings[rowcolnumber] = factorLoadings[rowcolnumber] * -1;\n        }).value();\n        var factorResults = [subtractedArray, factorLoadings];\n        return factorResults;\n    };\n\n    // ***************************************************************   model\n    // ***** check for positive manifold *************************************\n    // ***********************************************************************\n\n    // todo - check this function - seems a bit wanky  - is pos shift check needed\n\n    CENTROID.checkPositiveManifold = function (dataArray) {\n        var columnSums = CENTROID.calculateColumnSums(dataArray);\n        var findMinColumnSum = CENTROID.calculateMinValueAndIndex(columnSums);\n        var minColumnSum = findMinColumnSum[0];\n        var reflectedArrayData;\n\n        if (minColumnSum < 0) {\n            reflectedArrayData = CENTROID.calculatePositiveManifold(dataArray, minColumnSum);\n            return reflectedArrayData;\n        } else {\n            reflectedArrayData = [dataArray, columnSums];\n            return reflectedArrayData;\n        }\n    };\n\n    // ***************************************************************   model\n    // ***** calculate positive manifold ************************************\n    // **********************************************************************\n    CENTROID.calculatePositiveManifold = function (manifoldArray, minColumnSum) {\n        // todo limit to 200-300 iterations? - see qmethod source code\n        // todo - check this also - is it a bit wanky?\n        var reflectedRowCol = [];\n        var columnSums, findMinColumnSum, minIndex, positiveManifoldData;\n        var m, p, pLen;\n        var mLoopLen = manifoldArray.length;\n\n        while (minColumnSum < 0) {\n            columnSums = CENTROID.calculateColumnSums(manifoldArray);\n            findMinColumnSum = CENTROID.calculateMinValueAndIndex(columnSums);\n            minColumnSum = findMinColumnSum[0];\n            minIndex = findMinColumnSum[1];\n            if (minColumnSum < 0) {\n                for (m = 0; m < mLoopLen; m++) {\n                    manifoldArray[m][minIndex] = manifoldArray[m][minIndex] * -1;\n                }\n                for (p = 0, pLen = manifoldArray[minIndex].length; p < pLen; p++) { // single row\n                    manifoldArray[minIndex][p] = manifoldArray[minIndex][p] * -1; // do something\n                }\n                reflectedRowCol.push(minIndex);\n            } else {\n                positiveManifoldData = [manifoldArray, columnSums, reflectedRowCol];\n                return positiveManifoldData;\n            }\n        }\n    };\n\n    // ******************************************************************   model\n    // ***** Calculate Column Sums **********************************************\n    // **************************************************************************\n    CENTROID.calculateColumnSums = function (sumArray) {\n        var sum, sum1;\n        var columnTotals = [];\n        var j, i;\n        var loopLen = sumArray.length;\n\n        for (j = 0; j < loopLen; j++) {\n            sum = 0;\n            for (i = 0; i < loopLen; i++) {\n                sum += sumArray[i][j];\n            }\n            sum = sum - 1;\n            sum1 = evenRound((sum), 8);\n            columnTotals.push(sum1);\n        }\n        return columnTotals;\n    };\n\n    // **************************************************************   model\n    // ***** calculate Minimum Value and Array Index Value ******************\n    // **********************************************************************\n    CENTROID.calculateMinValueAndIndex = function (columnTotals) {\n        var minIndex = 0;\n        var min = columnTotals[0];\n        var k, minValues;\n        var loopLen = columnTotals.length;\n\n        for (k = 1; k < loopLen; k++) {\n            if (columnTotals[k] < min) {\n                minIndex = k;\n                min = columnTotals[k];\n            }\n        }\n        minValues = [min, minIndex];\n        return minValues;\n    };\n\n}(window.CENTROID = window.CENTROID || {}, QAV));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9DRU5UUk9JRC5qcz9hN2UwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vS2VuLVEgQW5hbHlzaXNcbi8vQ29weXJpZ2h0IChDKSAyMDE2IFNoYXduIEJhbmFzaWNrXG4vL1xuLy8gICAgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuLy8gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuXG4vLyBKU2xpbnQgZGVjbGFyYXRpb25zXG4vKiBnbG9iYWwgcGVyZm9ybWFuY2UsIHdpbmRvdywgUUFWLCAkLCBkb2N1bWVudCwgcmVzb3VyY2VzLCBldmVuUm91bmQsIFVUSUwsIF8gKi9cblxuKGZ1bmN0aW9uIChDRU5UUk9JRCwgUUFWLCB1bmRlZmluZWQpIHtcblxuICAgIC8vIHRvZG8gLSBmaXggcGFyc2VJbnQgYnkgYWRkaW5nIHNlY29uZCB2YWx1ZVxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgY29udHJvbGxlclxuICAgIC8vICoqKioqIGNvbnRyb2xsZXIgZm9yIGZhY3RvciBleHRyYWN0aW9uICoqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyB0b2RvIC0gcmVmYWN0b3Igb25jbGljayBoYW5kbGVyIGZyb20gaHRtbFxuICAgIENFTlRST0lELmZpcmVGYWN0b3JFeHRyYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdDAgPSBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgIHQxO1xuICAgICAgICB2YXIgZmFjdG9ycyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmFjdG9yU2VsZWN0XCIpO1xuICAgICAgICB2YXIgc2VsZWN0ZWROdW1iZXJGYWN0b3JzID0gZmFjdG9ycy5vcHRpb25zW2ZhY3RvcnMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICAgIHZhciBsb29wTGVuZ3RoID0gcGFyc2VJbnQoc2VsZWN0ZWROdW1iZXJGYWN0b3JzKTtcbiAgICAgICAgdmFyIGRhdGFBcnJheSA9IFFBVi5nZXRTdGF0ZShcIm9yaWdpbmFsQ29ycmVsYXRpb25WYWx1ZXNcIik7XG4gICAgICAgIHZhciBmYWN0b3JNYXRyaXggPSBbXTtcbiAgICAgICAgdmFyIGZhY3RvckRpc3BsYXlOYW1lQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGQzQ2hhcnRGYWN0b3JOYW1lcyA9IFtdO1xuICAgICAgICB2YXIgZmFjdG9yTmFtZSwgZDNGYWN0b3JOYW1lLCB0ZW1wQXJyYXk7XG4gICAgICAgIHZhciBmYWN0b3JNYXRyaXgxLCBudW1iZXJTb3J0cywgbnVtLCBlaWdlbjtcbiAgICAgICAgdmFyIGVpZ2VudmFsdWVzID0gW107XG4gICAgICAgIHZhciBleHBsYWluZWRWYXJpYW5jZSA9IFtdO1xuICAgICAgICB2YXIgcmVzcG9uZGVudE5hbWVzLCB0b3RhbFZhcmlhbmNlLCB0YWJsZSwgbGFuZ3VhZ2UsIGZhY1RleHQ7XG4gICAgICAgIHZhciBpc1JvdGF0ZWRGYWN0b3JzVGFibGVVcGRhdGU7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcIm51bWJlckZhY3RvcnNFeHRyYWN0ZWRcIiwgbG9vcExlbmd0aCk7XG4gICAgICAgIFFBVi5udW1GYWN0b3JzRXh0cmFjdGVkID0gbG9vcExlbmd0aDtcbiAgICAgICAgdmFyIGksIGosIGpMZW4sIHEsIHFMZW47XG4gICAgICAgIHZhciBpTGVuID0gbG9vcExlbmd0aCArIDE7XG4gICAgICAgIHZhciBmYWN0b3JNYXRyaXhUb0ZpeGVkNSwgZmFjdG9yTWF0cml4VHJhbnNwb3NlZCwgdmFyVGV4dCwgZWlnZW5UZXh0O1xuICAgICAgICB2YXIgZXhwVmFyMiwgcm90RmFjU3RhdGVBcnJheVByZXAxLCByb3RGYWNTdGF0ZUFycmF5UHJlcDI7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIGlzIHRoaXMgaXMgYSByb3RhdGlvbiB0YWJsZSByZS1kcmF3IG9yIG5vdFxuICAgICAgICB0YWJsZSA9ICQoJyNmYWN0b3JSb3RhdGlvblRhYmxlMiB0cicpLmxlbmd0aDsgLy9cbiAgICAgICAgaWYgKHRhYmxlID4gMCkge1xuICAgICAgICAgICAgaXNSb3RhdGVkRmFjdG9yc1RhYmxlVXBkYXRlID0gXCJkZXN0cm95XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc1JvdGF0ZWRGYWN0b3JzVGFibGVVcGRhdGUgPSBcIm5vXCI7XG4gICAgICAgIH1cblxuICAgICAgICBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICBmYWNUZXh0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5GYWN0b3I7XG5cbiAgICAgICAgLy8gdXNlZCBmb3Igc2VjdGlvbiA2IHRleHQgbGFiZWxzXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZhY3Rvck5hbWUgPSBmYWNUZXh0ICsgXCIgXCIgKyBpO1xuICAgICAgICAgICAgZDNGYWN0b3JOYW1lID0gZmFjVGV4dCArIFwiIFwiICsgaTtcbiAgICAgICAgICAgIC8vIGFkZGVkIGZvciBEMyBiZWNhdXNlIG9mIHVua25vd24gY29tbWEgaW5zZXJ0aW9uIGluIGZhY3RvckRpc3BhbHlOYW1lQXJyYXlcbiAgICAgICAgICAgIGQzQ2hhcnRGYWN0b3JOYW1lcy5wdXNoKGQzRmFjdG9yTmFtZSk7XG4gICAgICAgICAgICB0ZW1wQXJyYXkgPSBDRU5UUk9JRC5jYWxjdWxhdGVGYWN0b3JMb2FkaW5ncyhkYXRhQXJyYXkpO1xuICAgICAgICAgICAgZmFjdG9yTWF0cml4LnB1c2godGVtcEFycmF5WzBdKTtcbiAgICAgICAgICAgIGRhdGFBcnJheSA9IHRlbXBBcnJheVsxXTtcbiAgICAgICAgICAgIGZhY3RvckRpc3BsYXlOYW1lQXJyYXkucHVzaChmYWN0b3JOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFFBVi5zZXRTdGF0ZShcImZhY3RvckxhYmVsc1wiLCBmYWN0b3JEaXNwbGF5TmFtZUFycmF5KTtcbiAgICAgICAgLy8gUUFWLmZhY3RvckxhYmVscyA9IGZhY3RvckRpc3BsYXlOYW1lQXJyYXk7XG5cbiAgICAgICAgLy8gXG4gICAgICAgIGZhY3Rvck1hdHJpeDEgPSBfLmNsb25lRGVlcChmYWN0b3JNYXRyaXgsIHRydWUpO1xuICAgICAgICB2YXIgY2VudHJvaWRGYWN0b3JzID0gXy5jbG9uZURlZXAoZmFjdG9yTWF0cml4KTtcblxuICAgICAgICAvLyBzZW5kIGFuZCBzYXZlICB0byB2YXJpbWF4IHJvdGF0aW9uXG4gICAgICAgIC8vIHRvZG8gLSBjaGFuZ2UgdGhpcyBuYW1lIHRvIGNsYXJpZnkgZm9yIFBDQVxuICAgICAgICBRQVYuc2V0U3RhdGUoXCJjZW50cm9pZEZhY3RvcnNcIiwgY2VudHJvaWRGYWN0b3JzKTtcblxuICAgICAgICAvLyB0b2RvIGNoYW5nZSB0byBhbmFseXNpcyBnbG9iYWwgb2JqZWN0IHNldHRpbmdcbiAgICAgICAgbnVtYmVyU29ydHMgPSBRQVYuZ2V0U3RhdGUoXCJxYXZUb3RhbE51bWJlclNvcnRzXCIpO1xuICAgICAgICByZXNwb25kZW50TmFtZXMgPSBRQVYuZ2V0U3RhdGUoXCJxYXZSZXNwb25kZW50TmFtZXNcIik7XG5cbiAgICAgICAgLy8gZWlnZW52YWx1ZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgZXhwbGFpbmVkVmFyaWFuY2VBbmRFaWdlbnMgPSBDRU5UUk9JRC5jYWxjRWlnZW5WYWx1ZXMoZmFjdG9yTWF0cml4MSwgbnVtYmVyU29ydHMpO1xuICAgICAgICBlaWdlbnZhbHVlcyA9IGV4cGxhaW5lZFZhcmlhbmNlQW5kRWlnZW5zWzBdO1xuICAgICAgICBleHBsYWluZWRWYXJpYW5jZSA9IGV4cGxhaW5lZFZhcmlhbmNlQW5kRWlnZW5zWzFdO1xuXG4gICAgICAgIC8vIHNoaWZ0IGRhdGEgdG8gZml4ZWQgNVxuICAgICAgICBmYWN0b3JNYXRyaXhUb0ZpeGVkNSA9IFtdO1xuICAgICAgICBfKGZhY3Rvck1hdHJpeCkuZm9yRWFjaChmdW5jdGlvbiAoYXJyYXlGcmFnKSB7XG4gICAgICAgICAgICB2YXIgdGFibGVGb3JtYXRGcmFnbWVudCA9IF8ubWFwKGFycmF5RnJhZywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGV2ZW5Sb3VuZChhLCA1KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZhY3Rvck1hdHJpeFRvRml4ZWQ1LnB1c2godGFibGVGb3JtYXRGcmFnbWVudCk7XG4gICAgICAgIH0pLnZhbHVlKCk7XG5cblxuICAgICAgICBmYWN0b3JNYXRyaXhUb0ZpeGVkNS51bnNoaWZ0KHJlc3BvbmRlbnROYW1lcyk7XG4gICAgICAgIGZhY3Rvck1hdHJpeFRyYW5zcG9zZWQgPSBfLnppcC5hcHBseShfLCBmYWN0b3JNYXRyaXhUb0ZpeGVkNSk7XG5cbiAgICAgICAgLy8gdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhclRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiJSBleHBsYWluZWQgdmFyaWFuY2VcIl07XG4gICAgICAgIGVpZ2VuVGV4dCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uRWlnZW52YWx1ZXM7XG5cblxuICAgICAgICBlaWdlbnZhbHVlcy51bnNoaWZ0KGVpZ2VuVGV4dCk7XG4gICAgICAgIGV4cGxhaW5lZFZhcmlhbmNlLnVuc2hpZnQodmFyVGV4dCk7XG5cbiAgICAgICAgUUFWLmNlbnRyb2lkRWlnZW52YWx1ZXMgPSBlaWdlbnZhbHVlcztcblxuICAgICAgICBmYWN0b3JNYXRyaXhUcmFuc3Bvc2VkLnB1c2goZWlnZW52YWx1ZXMpO1xuICAgICAgICBmYWN0b3JNYXRyaXhUcmFuc3Bvc2VkLnB1c2goZXhwbGFpbmVkVmFyaWFuY2UpO1xuICAgICAgICBmYWN0b3JEaXNwbGF5TmFtZUFycmF5LnVuc2hpZnQoXCJcIik7XG4gICAgICAgIGZhY3Rvck1hdHJpeFRyYW5zcG9zZWQudW5zaGlmdChmYWN0b3JEaXNwbGF5TmFtZUFycmF5KTtcblxuXG4gICAgICAgIGV4cFZhcjIgPSBmYWN0b3JNYXRyaXhUcmFuc3Bvc2VkLnBvcCgpO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJleHBWYXJDZW50cm9pZFwiLCBleHBWYXIyKTtcblxuICAgICAgICAvLyBhZGQgdG8gUUFWIC0gdXNlZCBpbiByZXN1bHRzIGRvd25sb2FkIGN1bXVsYXRpdmUgY29tbW9uYWxpdGllcyBzZWN0aW9uXG4gICAgICAgIFFBVi5zZXRTdGF0ZShcImZhY3Rvck1hdHJpeFRyYW5zcG9zZWRcIiwgZmFjdG9yTWF0cml4VHJhbnNwb3NlZCk7XG5cbiAgICAgICAgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnJWMgQ2VudHJvaWQgZmFjdG9yIGV4dHJhY3Rpb24gY29tcGxldGVkIGluICAnICsgKHQxIC0gdDApLnRvRml4ZWQoMCkgKyAnIG1pbGxpc2Vjb25kcycsICdiYWNrZ3JvdW5kOiAjRkY1NzMzOyBjb2xvcjogd2hpdGUnKTtcblxuXG4gICAgICAgIC8vIHRvZG8gLSBjbGVhbiB1cCB0aGlzIGFycmF5IHByZXAgbWVzcyAtIHJlZmFjdG9yIHRvIGZ1bmN0aW9uXG4gICAgICAgIHJvdEZhY1N0YXRlQXJyYXlQcmVwMSA9IF8uY2xvbmVEZWVwKGZhY3Rvck1hdHJpeFRvRml4ZWQ1KTtcbiAgICAgICAgcm90RmFjU3RhdGVBcnJheVByZXAxLnNoaWZ0KCk7XG4gICAgICAgIHJvdEZhY1N0YXRlQXJyYXlQcmVwMiA9IF8uemlwLmFwcGx5KF8sIHJvdEZhY1N0YXRlQXJyYXlQcmVwMSk7XG4gICAgICAgIFFBVi5jZW50cm9pZEZhY3RvcnMgPSByb3RGYWNTdGF0ZUFycmF5UHJlcDI7XG4gICAgfTtcblxuICAgIENFTlRST0lELmNhbGNFaWdlblZhbHVlcyA9IGZ1bmN0aW9uIChmYWN0b3JNYXRyaXgxLCBudW1iZXJTb3J0cykge1xuICAgICAgICAvLyBlaWdlbnZhbHVlIGNhbGN1bGF0aW9uc1xuICAgICAgICB2YXIgZXhwbGFpbmVkVmFyaWFuY2UgPSBbXTtcbiAgICAgICAgdmFyIGVpZ2VudmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gZmFjdG9yTWF0cml4MS5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICAgIG51bSA9IGZhY3Rvck1hdHJpeDFbal07XG4gICAgICAgICAgICBmb3IgKHEgPSAwLCBxTGVuID0gbnVtLmxlbmd0aDsgcSA8IHFMZW47IHErKykge1xuICAgICAgICAgICAgICAgIG51bVtxXSA9IGV2ZW5Sb3VuZCgobnVtW3FdICogbnVtW3FdKSwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlaWdlbiA9IGV2ZW5Sb3VuZCgoXy5yZWR1Y2UobnVtLCBmdW5jdGlvbiAoc3VtLCBudW0yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIG51bTI7XG4gICAgICAgICAgICB9KSksIDUpO1xuXG4gICAgICAgICAgICBlaWdlbnZhbHVlcy5wdXNoKGVpZ2VuKTtcbiAgICAgICAgICAgIHRvdGFsVmFyaWFuY2UgPSBldmVuUm91bmQoKDEwMCAqIChlaWdlbiAvIG51bWJlclNvcnRzKSksIDApO1xuICAgICAgICAgICAgZXhwbGFpbmVkVmFyaWFuY2UucHVzaCh0b3RhbFZhcmlhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2VpZ2VudmFsdWVzLCBleHBsYWluZWRWYXJpYW5jZV07XG4gICAgfTtcblxuXG4gICAgQ0VOVFJPSUQuY2FsY3VsYXRlRmFjdG9yTG9hZGluZ3MgPSBmdW5jdGlvbiAoZGF0YUFycmF5KSB7XG4gICAgICAgIHZhciByZWZsZWN0ZWRBcnJheSA9IENFTlRST0lELmNoZWNrUG9zaXRpdmVNYW5pZm9sZChkYXRhQXJyYXkpO1xuICAgICAgICB2YXIgcmVmbGVjdGVkQXJyYXkxID0gcmVmbGVjdGVkQXJyYXlbMF07IC8vIHJlZmxlY3RlZCBhcnJheVxuICAgICAgICB2YXIgcmVmbGVjdGVkQXJyYXlDb2x1bW5Ub3RhbHMgPSByZWZsZWN0ZWRBcnJheVsxXTsgLy8gY29sdW1uIHRvdGFsc1xuICAgICAgICB2YXIgcmVmbGVjdGVkUm93Q29sID0gcmVmbGVjdGVkQXJyYXlbMl07XG4gICAgICAgIHZhciBmYWN0b3JMb2FkczEgPSBDRU5UUk9JRC5jYWxjdWxhdGVGYWN0b3IocmVmbGVjdGVkQXJyYXkxLCByZWZsZWN0ZWRBcnJheUNvbHVtblRvdGFscyk7XG4gICAgICAgIHZhciBzdWJ0cmFjdEFycmF5ID0gQ0VOVFJPSUQucmVtb3ZlQ29ycmVsYXRpb25zKHJlZmxlY3RlZEFycmF5MSwgZmFjdG9yTG9hZHMxKTtcbiAgICAgICAgdmFyIHVuZG9Qb3NpdGl2ZU1hbmlmb2xkID0gQ0VOVFJPSUQudW5kb1JlZmxlY3Rpb24oc3VidHJhY3RBcnJheSwgZmFjdG9yTG9hZHMxLCByZWZsZWN0ZWRSb3dDb2wpO1xuICAgICAgICB2YXIgZmFjdG9yU3VidHJhY3RlZEFycmF5ID0gdW5kb1Bvc2l0aXZlTWFuaWZvbGRbMF07XG4gICAgICAgIHZhciBmYWN0b3JGYWN0b3JTY29yZXMgPSB1bmRvUG9zaXRpdmVNYW5pZm9sZFsxXTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbZmFjdG9yRmFjdG9yU2NvcmVzLCBmYWN0b3JTdWJ0cmFjdGVkQXJyYXldO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9OyAvLyBlbmQgZnVuY3Rpb24gZmlyZUNhbGN1bGF0ZUZhY3RvcnNcblxuICAgIENFTlRST0lELmRyYXdFeHRyYWN0ZWRGYWN0b3JzVGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZW50cm9pZEZhY3RvcnMgPSBRQVYuZ2V0U3RhdGUoXCJjZW50cm9pZEZhY3RvcnNcIik7XG4gICAgICAgIHZhciBpLCBpTGVuLCBqLCBrLCBuYW1lcztcbiAgICAgICAgdmFyIHRlbXAxLCBsb29wTGVuLCB0YXJnZXRzLCBzbGljZWRUYXJnZXRzLCBoZWFkZXJzO1xuICAgICAgICB2YXIgbGFuZ3VhZ2UsIGZhY1RleHQsIHJlc3BvbmRUZXh0LCBhcHBlbmRUZXh0O1xuICAgICAgICB2YXIgY29uZmlnT2JqID0ge307XG5cbiAgICAgICAgbmFtZXMgPSBRQVYuZ2V0U3RhdGUoXCJyZXNwb25kZW50TmFtZXNcIikgfHwgW107XG5cbiAgICAgICAgaWYgKG5hbWVzWzBdID09PSBcIlwiKSB7XG4gICAgICAgICAgICBuYW1lcy5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IGNlbnRyb2lkRmFjdG9ycy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgICAgIGNlbnRyb2lkRmFjdG9yc1tpXS51bnNoaWZ0KGosIG5hbWVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIGZhY1RleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLkZhY3RvcjtcbiAgICAgICAgcmVzcG9uZFRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLlJlc3BvbmRlbnQ7XG4gICAgICAgIGFwcGVuZFRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiQ2VudHJvaWQgRmFjdG9ycyBFeHRyYWN0ZWRcIl07XG5cbiAgICAgICAgaGVhZGVycyA9IFt7XG4gICAgICAgICAgICB0aXRsZTogXCJOdW0uXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdGl0bGU6IHJlc3BvbmRUZXh0XG4gICAgICAgIH1dO1xuXG4gICAgICAgIC8vIG1ha2UgaGVhZGVycyBkeW5hbWljXG4gICAgICAgIGxvb3BMZW4gPSAoY2VudHJvaWRGYWN0b3JzWzBdLmxlbmd0aCkgLSAyO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbG9vcExlbjsgaysrKSB7XG4gICAgICAgICAgICB0ZW1wMSA9IHt9O1xuICAgICAgICAgICAgdGVtcDEudGl0bGUgPSBmYWNUZXh0ICsgXCIgXCIgKyAoayArIDEpO1xuICAgICAgICAgICAgaGVhZGVycy5wdXNoKHRlbXAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2UgdGFyZ2V0cyBkeW5hbWljXG4gICAgICAgIHRhcmdldHMgPSBbMiwgMywgNCwgNSwgNiwgNywgOCwgOV07XG4gICAgICAgIHNsaWNlZFRhcmdldHMgPSB0YXJnZXRzLnNsaWNlKDAsIGxvb3BMZW4pO1xuXG4gICAgICAgIGNvbmZpZ09iai5kb21FbGVtZW50ID0gXCIjZmFjdG9yUm90YXRpb25UYWJsZTFcIjtcbiAgICAgICAgY29uZmlnT2JqLmZpeGVkID0gZmFsc2U7XG4gICAgICAgIGNvbmZpZ09iai5kYXRhID0gY2VudHJvaWRGYWN0b3JzO1xuICAgICAgICBjb25maWdPYmouaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIGNvbmZpZ09iai5jb2xEZWZzID0gW3tcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiBbMCwgMV0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1jZW50ZXIgZHQtYm9keS1uYW1lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiBzbGljZWRUYXJnZXRzLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2R0LWhlYWQtY2VudGVyIGR0LWJvZHktcmlnaHQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldHM6ICdfYWxsJyxcbiAgICAgICAgICAgICAgICBcImNyZWF0ZWRDZWxsXCI6IGZ1bmN0aW9uICh0ZCwgY2VsbERhdGEpIHsgLy8gLCByb3dEYXRhLCByb3csIGNvbFxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbERhdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRkKS5jc3MoJ2NvbG9yJywgJ3JlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuXG4gICAgICAgIFVUSUwuZHJhd0RhdGF0YWJsZShjb25maWdPYmopO1xuXG4gICAgICAgICQoXCIjcm90YXRpb25IaXN0b3J5TGlzdFwiKS5hcHBlbmQoJzxsaT4nICsgUUFWLm51bUZhY3RvcnNFeHRyYWN0ZWQgKyBhcHBlbmRUZXh0ICsgJzwvbGk+Jyk744CAXG5cbiAgICAgICAgQ0VOVFJPSUQuY3JlYXRlRm9vdGVyVGFibGUoaGVhZGVycywgc2xpY2VkVGFyZ2V0cyk7XG5cbiAgICB9O1xuXG4gICAgQ0VOVFJPSUQuY3JlYXRlRm9vdGVyVGFibGUgPSBmdW5jdGlvbiAoaGVhZGVycywgc2xpY2VkVGFyZ2V0cykge1xuICAgICAgICB2YXIgZWlnZW5WYWx1ZXMsIHBlcmNlbnRFeHBsYWluZWRWYXJpYW5jZSwgbG9vcExlbjEsIG0sIGhlYWRlcnMyO1xuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICB2YXIgdGVtcEFycmF5ID0gW107XG4gICAgICAgIHZhciB0ZW1wT2JqID0ge307XG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICB2YXIgY3VtVmFyVGV4dCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJDdW0gJSBFeHBsbiBWYXJcIl07XG4gICAgICAgIHZhciB0ZW1wT2JqMiA9IHRlbXBPYmo7XG4gICAgICAgIHZhciBjb25maWdPYmogPSB7fTtcblxuICAgICAgICBlaWdlblZhbHVlcyA9IFFBVi5nZXRTdGF0ZShcImNlbnRyb2lkRWlnZW52YWx1ZXNcIik7XG4gICAgICAgIGVpZ2VuVmFsdWVzLnVuc2hpZnQoXCJcIik7XG4gICAgICAgIHBlcmNlbnRFeHBsYWluZWRWYXJpYW5jZSA9IFFBVi5nZXRTdGF0ZShcImV4cFZhckNlbnRyb2lkXCIpO1xuICAgICAgICBwZXJjZW50RXhwbGFpbmVkVmFyaWFuY2UudW5zaGlmdChcIlwiKTtcbiAgICAgICAgbG9vcExlbjEgPSBwZXJjZW50RXhwbGFpbmVkVmFyaWFuY2UubGVuZ3RoO1xuXG4gICAgICAgIGZvciAobSA9IDI7IG0gPCBsb29wTGVuMTsgbSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgcGVyY2VudEV4cGxhaW5lZFZhcmlhbmNlW21dO1xuICAgICAgICAgICAgdGVtcEFycmF5LnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcEFycmF5LnVuc2hpZnQoXCJcIiwgY3VtVmFyVGV4dCk7XG5cbiAgICAgICAgZGF0YS5wdXNoKGVpZ2VuVmFsdWVzLCBwZXJjZW50RXhwbGFpbmVkVmFyaWFuY2UsIHRlbXBBcnJheSk7XG5cbiAgICAgICAgaGVhZGVyczIgPSBoZWFkZXJzLnNsaWNlKDIsIGhlYWRlcnMubGVuZ3RoKTtcbiAgICAgICAgdGVtcE9iai50aXRsZSA9IFwiXCI7XG5cbiAgICAgICAgaGVhZGVyczIudW5zaGlmdCh0ZW1wT2JqLCB0ZW1wT2JqMik7XG5cbiAgICAgICAgY29uZmlnT2JqLmRvbUVsZW1lbnQgPSBcIiNmYWN0b3JSb3RhdGlvblRhYmxlMUZvb3RlclwiO1xuICAgICAgICBjb25maWdPYmouZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uZmlnT2JqLmRhdGEgPSBkYXRhO1xuICAgICAgICBjb25maWdPYmouaGVhZGVycyA9IGhlYWRlcnMyO1xuICAgICAgICBjb25maWdPYmoub3JkZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uZmlnT2JqLmNvbERlZnMgPSBbe1xuICAgICAgICAgICAgICAgIHRhcmdldHM6IFswLCAxXSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdkdC1oZWFkLWNlbnRlciBkdC1ib2R5LWNlbnRlciBkdC1ib2R5LW5hbWUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldHM6IHNsaWNlZFRhcmdldHMsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1yaWdodCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0czogJ19hbGwnLFxuICAgICAgICAgICAgICAgIFwiY3JlYXRlZENlbGxcIjogZnVuY3Rpb24gKHRkLCBjZWxsRGF0YSkgeyAvLyAsIHJvd0RhdGEsIHJvdywgY29sXG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsRGF0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGQpLmNzcygnY29sb3InLCAncmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICAgIFVUSUwuZHJhd0RhdGF0YWJsZShjb25maWdPYmopO1xuICAgICAgICByZXR1cm4gY29uZmlnT2JqO1xuICAgIH07XG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgIG1vZGVsXG4gICAgLy8gKioqKiogQ2FsY3VsYXRlIEZhY3RvcnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBDRU5UUk9JRC5jYWxjdWxhdGVGYWN0b3IgPSBmdW5jdGlvbiAocmVmbGVjdGVkQXJyYXksIGNvbHVtblRvdGFscykge1xuICAgICAgICBjb25zb2xlLnRpbWUoXCJ0b3RhbCBjYWxjdWxhdGlvbiB0aW1lIFwiKTtcbiAgICAgICAgdmFyIHRvdGFsc1N1bXMsIHRvdGFsc1N1bXNTcXJ0LCBmYWN0b3JMb2FkMSwgZmFjdG9yTG9hZDFTcXJkLCBkaWZmRGlhZ29uYWxFc3RpbWF0ZWFuZEZhY3RvckxvYWQ7XG4gICAgICAgIHZhciBjb2xUb3RhbHNBbmRNZWFuU3VtID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBjb2x1bW5Ub3RhbHMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb2xUb3RhbHNBbmRNZWFuU3VtLnB1c2goZXZlblJvdW5kKChjb2x1bW5Ub3RhbHNbaV0gKyAwLjUpLCA4KSk7IC8vIDAuNSBhcyB1c2VkIGluIFBRTWV0aG9kXG4gICAgICAgIH1cblxuICAgICAgICB0b3RhbHNTdW1zID0gXy5yZWR1Y2UoY29sVG90YWxzQW5kTWVhblN1bSwgZnVuY3Rpb24gKHN1bSwgbnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VtICsgbnVtO1xuICAgICAgICB9KTtcblxuICAgICAgICB0b3RhbHNTdW1zU3FydCA9IGV2ZW5Sb3VuZCgoTWF0aC5zcXJ0KHRvdGFsc1N1bXMpKSwgOCk7XG5cbiAgICAgICAgZmFjdG9yTG9hZDEgPSBfLm1hcChjb2xUb3RhbHNBbmRNZWFuU3VtLCBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlblJvdW5kKChudW0gLyB0b3RhbHNTdW1zU3FydCksIDgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmYWN0b3JMb2FkMVNxcmQgPSBfLm1hcChmYWN0b3JMb2FkMSwgZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW5Sb3VuZCgobnVtICogbnVtKSwgOCk7XG4gICAgICAgIH0pOyAvLyBjb21wYXJpc29uIDJcblxuICAgICAgICBkaWZmRGlhZ29uYWxFc3RpbWF0ZWFuZEZhY3RvckxvYWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSBmYWN0b3JMb2FkMVNxcmQubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgICBkaWZmRGlhZ29uYWxFc3RpbWF0ZWFuZEZhY3RvckxvYWQucHVzaChNYXRoLmFicyhldmVuUm91bmQoKGZhY3RvckxvYWQxU3FyZFtqXSAtIDAuNSksIDgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF4RGlmZiA9IF8ubWF4KGRpZmZEaWFnb25hbEVzdGltYXRlYW5kRmFjdG9yTG9hZCk7XG5cbiAgICAgICAgZnVuY3Rpb24gdG90YWxTdW1zRnVuY3Rpb24obmV3RGlhZ29uYWxFc3RpbWF0ZSkge1xuICAgICAgICAgICAgdmFyIHRvdGFsc1N1bXMgPSBfLnJlZHVjZShuZXdEaWFnb25hbEVzdGltYXRlLCBmdW5jdGlvbiAoc3VtLCBudW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlblJvdW5kKChzdW0gKyBudW0pLCA4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsc1N1bXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmYWN0b3JMb2FkMUZ1bmN0aW9uKG5ld0RpYWdvbmFsRXN0aW1hdGUpIHtcbiAgICAgICAgICAgIGZhY3RvckxvYWQxID0gXy5tYXAobmV3RGlhZ29uYWxFc3RpbWF0ZSwgZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVuUm91bmQoKG51bSAvIHRvdGFsc1N1bXNTcXJ0KSwgOCk7XG4gICAgICAgICAgICB9KTsgLy8gTWF0aC5yb3VuZDEwXG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yTG9hZDE7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmYWN0b3JMb2FkMVNxcmRGdW5jdGlvbihmYWN0b3JMb2FkMSkge1xuICAgICAgICAgICAgZmFjdG9yTG9hZDFTcXJkID0gXy5tYXAoZmFjdG9yTG9hZDEsIGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlblJvdW5kKChudW0gKiBudW0pLCA4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvckxvYWQxU3FyZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhEaWZmID4gMC4wMDEpIHtcblxuICAgICAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzRmFjdG9yTG9hZEVzdGltYXRlID0gZmFjdG9yTG9hZDFTcXJkO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5ld0RpYWdvbmFsRXN0aW1hdGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga0xlbiA9IGNvbHVtblRvdGFscy5sZW5ndGg7IGsgPCBrTGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGlhZ29uYWxFc3RpbWF0ZS5wdXNoKGV2ZW5Sb3VuZCgoY29sdW1uVG90YWxzW2tdICsgcHJldmlvdXNGYWN0b3JMb2FkRXN0aW1hdGVba10pLCA4KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG90YWxzU3VtcyA9IHRvdGFsU3Vtc0Z1bmN0aW9uKG5ld0RpYWdvbmFsRXN0aW1hdGUpO1xuXG4gICAgICAgICAgICAgICAgdG90YWxzU3Vtc1NxcnQgPSBldmVuUm91bmQoKE1hdGguc3FydCh0b3RhbHNTdW1zKSksIDgpO1xuXG4gICAgICAgICAgICAgICAgZmFjdG9yTG9hZDEgPSBmYWN0b3JMb2FkMUZ1bmN0aW9uKG5ld0RpYWdvbmFsRXN0aW1hdGUpO1xuXG4gICAgICAgICAgICAgICAgZmFjdG9yTG9hZDFTcXJkID0gZmFjdG9yTG9hZDFTcXJkRnVuY3Rpb24oZmFjdG9yTG9hZDEpO1xuXG4gICAgICAgICAgICAgICAgZGlmZkRpYWdvbmFsRXN0aW1hdGVhbmRGYWN0b3JMb2FkID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDAsIG1MZW4gPSBwcmV2aW91c0ZhY3RvckxvYWRFc3RpbWF0ZS5sZW5ndGg7IG0gPCBtTGVuOyBtKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZkRpYWdvbmFsRXN0aW1hdGVhbmRGYWN0b3JMb2FkLnB1c2goTWF0aC5hYnMoZXZlblJvdW5kKChwcmV2aW91c0ZhY3RvckxvYWRFc3RpbWF0ZVttXSAtIGZhY3RvckxvYWQxU3FyZFttXSksIDgpKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWF4RGlmZiA9IF8ubWF4KGRpZmZEaWFnb25hbEVzdGltYXRlYW5kRmFjdG9yTG9hZCk7XG5cbiAgICAgICAgICAgIH0gd2hpbGUgKG1heERpZmYgPiAwLjAwMSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUudGltZUVuZChcInRvdGFsIGNhbGN1bGF0aW9uIHRpbWUgXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvckxvYWQxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvckxvYWQxOyAvLyB0b2RvIC0gc3RyYWlnaHRlbiBvdXQgdGhpcyBjb2RlXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogICBtb2RlbFxuICAgIC8vICoqKioqIHJlbW92ZSBmYWN0b3IgIGNvcnJlbGF0aW9ucyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIENFTlRST0lELnJlbW92ZUNvcnJlbGF0aW9ucyA9IGZ1bmN0aW9uIChhcnJheSwgZmFjdG9yTG9hZGluZ3MpIHtcbiAgICAgICAgdmFyIGZhY3RvckNvcnJlbGF0aW9ucyA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhlbHBlcjEoZmFjdG9yTG9hZGluZ3MpIHtcbiAgICAgICAgICAgIF8oZmFjdG9yTG9hZGluZ3MpLmZvckVhY2goZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gbnVtICogZmFjdG9yTG9hZGluZ3NbaV07XG4gICAgICAgICAgICAgICAgbmV3QXJyYXlGcmFnLnB1c2goZXZlblJvdW5kKCh0ZW1wKSwgOCkpO1xuICAgICAgICAgICAgfSkudmFsdWUoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdBcnJheUZyYWc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBmYWN0b3JMb2FkaW5ncy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdBcnJheUZyYWcgPSBbXTtcbiAgICAgICAgICAgIG5ld0FycmF5RnJhZyA9IGhlbHBlcjEoZmFjdG9yTG9hZGluZ3MpO1xuICAgICAgICAgICAgZmFjdG9yQ29ycmVsYXRpb25zLnB1c2gobmV3QXJyYXlGcmFnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzaWR1YWxDb3JyZWxhdGlvbnNQcmVwID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gZmFjdG9yTG9hZGluZ3MubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgc3VidHJhY3Rpb25GcmFnID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga0xlbiA9IGZhY3RvckxvYWRpbmdzLmxlbmd0aDsgayA8IGtMZW47IGsrKykge1xuICAgICAgICAgICAgICAgIHN1YnRyYWN0aW9uRnJhZy5wdXNoKGV2ZW5Sb3VuZCgoYXJyYXlbal1ba10gLSBmYWN0b3JDb3JyZWxhdGlvbnNbal1ba10pLCA4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNpZHVhbENvcnJlbGF0aW9uc1ByZXAucHVzaChzdWJ0cmFjdGlvbkZyYWcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHAgPSAwLCBwTGVuID0gZmFjdG9yTG9hZGluZ3MubGVuZ3RoOyBwIDwgcExlbjsgcCsrKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHA7XG4gICAgICAgICAgICByZXNpZHVhbENvcnJlbGF0aW9uc1ByZXBbcF1bbV0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNpZHVhbENvcnJlbGF0aW9uc1ByZXA7XG4gICAgfTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICAgbW9kZWxcbiAgICAvLyAqKioqKiAgdW5kbyBBcnJheSBSZWZsZWN0aW9uICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIENFTlRST0lELnVuZG9SZWZsZWN0aW9uID0gZnVuY3Rpb24gKHN1YnRyYWN0ZWRBcnJheSwgZmFjdG9yTG9hZGluZ3MsIHJlZmxlY3RlZFJvd0NvbCkge1xuICAgICAgICBfKHJlZmxlY3RlZFJvd0NvbCkuZm9yRWFjaChmdW5jdGlvbiAocm93Y29sbnVtYmVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRyYWN0ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1YnRyYWN0ZWRBcnJheVtpXVtyb3djb2xudW1iZXJdID0gc3VidHJhY3RlZEFycmF5W2ldW3Jvd2NvbG51bWJlcl0gKiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3VidHJhY3RlZEFycmF5W3Jvd2NvbG51bWJlcl0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBzdWJ0cmFjdGVkQXJyYXlbcm93Y29sbnVtYmVyXVtqXSA9IHN1YnRyYWN0ZWRBcnJheVtyb3djb2xudW1iZXJdW2pdICogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmYWN0b3JMb2FkaW5nc1tyb3djb2xudW1iZXJdID0gZmFjdG9yTG9hZGluZ3Nbcm93Y29sbnVtYmVyXSAqIC0xO1xuICAgICAgICB9KS52YWx1ZSgpO1xuICAgICAgICB2YXIgZmFjdG9yUmVzdWx0cyA9IFtzdWJ0cmFjdGVkQXJyYXksIGZhY3RvckxvYWRpbmdzXTtcbiAgICAgICAgcmV0dXJuIGZhY3RvclJlc3VsdHM7XG4gICAgfTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgIG1vZGVsXG4gICAgLy8gKioqKiogY2hlY2sgZm9yIHBvc2l0aXZlIG1hbmlmb2xkICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLy8gdG9kbyAtIGNoZWNrIHRoaXMgZnVuY3Rpb24gLSBzZWVtcyBhIGJpdCB3YW5reSAgLSBpcyBwb3Mgc2hpZnQgY2hlY2sgbmVlZGVkXG5cbiAgICBDRU5UUk9JRC5jaGVja1Bvc2l0aXZlTWFuaWZvbGQgPSBmdW5jdGlvbiAoZGF0YUFycmF5KSB7XG4gICAgICAgIHZhciBjb2x1bW5TdW1zID0gQ0VOVFJPSUQuY2FsY3VsYXRlQ29sdW1uU3VtcyhkYXRhQXJyYXkpO1xuICAgICAgICB2YXIgZmluZE1pbkNvbHVtblN1bSA9IENFTlRST0lELmNhbGN1bGF0ZU1pblZhbHVlQW5kSW5kZXgoY29sdW1uU3Vtcyk7XG4gICAgICAgIHZhciBtaW5Db2x1bW5TdW0gPSBmaW5kTWluQ29sdW1uU3VtWzBdO1xuICAgICAgICB2YXIgcmVmbGVjdGVkQXJyYXlEYXRhO1xuXG4gICAgICAgIGlmIChtaW5Db2x1bW5TdW0gPCAwKSB7XG4gICAgICAgICAgICByZWZsZWN0ZWRBcnJheURhdGEgPSBDRU5UUk9JRC5jYWxjdWxhdGVQb3NpdGl2ZU1hbmlmb2xkKGRhdGFBcnJheSwgbWluQ29sdW1uU3VtKTtcbiAgICAgICAgICAgIHJldHVybiByZWZsZWN0ZWRBcnJheURhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWZsZWN0ZWRBcnJheURhdGEgPSBbZGF0YUFycmF5LCBjb2x1bW5TdW1zXTtcbiAgICAgICAgICAgIHJldHVybiByZWZsZWN0ZWRBcnJheURhdGE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICAgbW9kZWxcbiAgICAvLyAqKioqKiBjYWxjdWxhdGUgcG9zaXRpdmUgbWFuaWZvbGQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIENFTlRST0lELmNhbGN1bGF0ZVBvc2l0aXZlTWFuaWZvbGQgPSBmdW5jdGlvbiAobWFuaWZvbGRBcnJheSwgbWluQ29sdW1uU3VtKSB7XG4gICAgICAgIC8vIHRvZG8gbGltaXQgdG8gMjAwLTMwMCBpdGVyYXRpb25zPyAtIHNlZSBxbWV0aG9kIHNvdXJjZSBjb2RlXG4gICAgICAgIC8vIHRvZG8gLSBjaGVjayB0aGlzIGFsc28gLSBpcyBpdCBhIGJpdCB3YW5reT9cbiAgICAgICAgdmFyIHJlZmxlY3RlZFJvd0NvbCA9IFtdO1xuICAgICAgICB2YXIgY29sdW1uU3VtcywgZmluZE1pbkNvbHVtblN1bSwgbWluSW5kZXgsIHBvc2l0aXZlTWFuaWZvbGREYXRhO1xuICAgICAgICB2YXIgbSwgcCwgcExlbjtcbiAgICAgICAgdmFyIG1Mb29wTGVuID0gbWFuaWZvbGRBcnJheS5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKG1pbkNvbHVtblN1bSA8IDApIHtcbiAgICAgICAgICAgIGNvbHVtblN1bXMgPSBDRU5UUk9JRC5jYWxjdWxhdGVDb2x1bW5TdW1zKG1hbmlmb2xkQXJyYXkpO1xuICAgICAgICAgICAgZmluZE1pbkNvbHVtblN1bSA9IENFTlRST0lELmNhbGN1bGF0ZU1pblZhbHVlQW5kSW5kZXgoY29sdW1uU3Vtcyk7XG4gICAgICAgICAgICBtaW5Db2x1bW5TdW0gPSBmaW5kTWluQ29sdW1uU3VtWzBdO1xuICAgICAgICAgICAgbWluSW5kZXggPSBmaW5kTWluQ29sdW1uU3VtWzFdO1xuICAgICAgICAgICAgaWYgKG1pbkNvbHVtblN1bSA8IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDwgbUxvb3BMZW47IG0rKykge1xuICAgICAgICAgICAgICAgICAgICBtYW5pZm9sZEFycmF5W21dW21pbkluZGV4XSA9IG1hbmlmb2xkQXJyYXlbbV1bbWluSW5kZXhdICogLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAocCA9IDAsIHBMZW4gPSBtYW5pZm9sZEFycmF5W21pbkluZGV4XS5sZW5ndGg7IHAgPCBwTGVuOyBwKyspIHsgLy8gc2luZ2xlIHJvd1xuICAgICAgICAgICAgICAgICAgICBtYW5pZm9sZEFycmF5W21pbkluZGV4XVtwXSA9IG1hbmlmb2xkQXJyYXlbbWluSW5kZXhdW3BdICogLTE7IC8vIGRvIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWZsZWN0ZWRSb3dDb2wucHVzaChtaW5JbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc2l0aXZlTWFuaWZvbGREYXRhID0gW21hbmlmb2xkQXJyYXksIGNvbHVtblN1bXMsIHJlZmxlY3RlZFJvd0NvbF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aXZlTWFuaWZvbGREYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgIG1vZGVsXG4gICAgLy8gKioqKiogQ2FsY3VsYXRlIENvbHVtbiBTdW1zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIENFTlRST0lELmNhbGN1bGF0ZUNvbHVtblN1bXMgPSBmdW5jdGlvbiAoc3VtQXJyYXkpIHtcbiAgICAgICAgdmFyIHN1bSwgc3VtMTtcbiAgICAgICAgdmFyIGNvbHVtblRvdGFscyA9IFtdO1xuICAgICAgICB2YXIgaiwgaTtcbiAgICAgICAgdmFyIGxvb3BMZW4gPSBzdW1BcnJheS5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxvb3BMZW47IGorKykge1xuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsb29wTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gc3VtQXJyYXlbaV1bal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gPSBzdW0gLSAxO1xuICAgICAgICAgICAgc3VtMSA9IGV2ZW5Sb3VuZCgoc3VtKSwgOCk7XG4gICAgICAgICAgICBjb2x1bW5Ub3RhbHMucHVzaChzdW0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uVG90YWxzO1xuICAgIH07XG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgIG1vZGVsXG4gICAgLy8gKioqKiogY2FsY3VsYXRlIE1pbmltdW0gVmFsdWUgYW5kIEFycmF5IEluZGV4IFZhbHVlICoqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBDRU5UUk9JRC5jYWxjdWxhdGVNaW5WYWx1ZUFuZEluZGV4ID0gZnVuY3Rpb24gKGNvbHVtblRvdGFscykge1xuICAgICAgICB2YXIgbWluSW5kZXggPSAwO1xuICAgICAgICB2YXIgbWluID0gY29sdW1uVG90YWxzWzBdO1xuICAgICAgICB2YXIgaywgbWluVmFsdWVzO1xuICAgICAgICB2YXIgbG9vcExlbiA9IGNvbHVtblRvdGFscy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChrID0gMTsgayA8IGxvb3BMZW47IGsrKykge1xuICAgICAgICAgICAgaWYgKGNvbHVtblRvdGFsc1trXSA8IG1pbikge1xuICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gaztcbiAgICAgICAgICAgICAgICBtaW4gPSBjb2x1bW5Ub3RhbHNba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWluVmFsdWVzID0gW21pbiwgbWluSW5kZXhdO1xuICAgICAgICByZXR1cm4gbWluVmFsdWVzO1xuICAgIH07XG5cbn0od2luZG93LkNFTlRST0lEID0gd2luZG93LkNFTlRST0lEIHx8IHt9LCBRQVYpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9DRU5UUk9JRC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDE3Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9')}]);