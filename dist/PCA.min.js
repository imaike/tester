!function(g){function I(A){if(C[A])return C[A].exports;var n=C[A]={i:A,l:!1,exports:{}};return g[A].call(n.exports,n,n.exports,I),n.l=!0,n.exports}var C={};I.m=g,I.c=C,I.i=function(g){return g},I.d=function(g,C,A){I.o(g,C)||Object.defineProperty(g,C,{configurable:!1,enumerable:!0,get:A})},I.n=function(g){var C=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(C,"a",C),C},I.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},I.p="",I(I.s=10)}({10:function(module,exports){eval('//Ken-Q Analysis\n//Copyright (C) 2016 Shawn Banasick\n//\n//    This program is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, either version 3 of the License, or\n//    (at your option) any later version.\n\n\n// JSlint declarations\n/* global numeric, window, QAV, $, document, JQuery, evenRound, UTIL, localStorage, _ */\n\n(function (PCA, QAV, undefined) {\n    \'use strict\';\n\n    PCA.doPrincipalComponents = function (X) {\n        var numberOfSorts, temp4, temp5, pcaFactorsToExtractArray, numberFactorsExtracted;\n        var numberofPrincipalComps, m;\n        var factorLabels = [];\n        var eigenVecs, eigenValuesSorted, eigenValuesAsPercents, eigenValuesCumulPercentArray;\n        var dataArray, dataArray2;\n\n        // to differentiate output functions\n        QAV.setState("typeOfFactor", "PCA");\n\n        numberOfSorts = QAV.getState("totalNumberSorts");\n\n        // determine the max number of factors to extract\n        temp4 = QAV.getState("originalSortSize");\n        temp5 = QAV.getState("totalNumberSorts");\n        pcaFactorsToExtractArray = [8, temp4, temp5];\n        numberFactorsExtracted = _.min(pcaFactorsToExtractArray);\n\n\n        numberofPrincipalComps = numberFactorsExtracted;\n        QAV.setState("numberFactorsExtracted", numberFactorsExtracted);\n        //  QAV.pcaNumberFactorsExtracted = numberFactorsExtracted;\n        QAV.setState("pcaNumberFactorsExtracted", numberFactorsExtracted);\n        UTIL.addFactorSelectCheckboxesRotation(numberFactorsExtracted);\n\n        // labels according to factors extacted (above)\n        for (m = 0; m < numberFactorsExtracted; m++) {\n            factorLabels.push("Factor " + (m + 1));\n        }\n        QAV.setState("factorLabels", factorLabels);\n\n        var isOnline = UTIL.checkIfOnline();\n\n        // use web worker if available and not running from local file\n        if (window.Worker && isOnline) {\n            $("#factorExtractionSpinnerText").css(\'visibility\', \'visible\');\n            $("#factorExtractionSpinnerDiv").addClass(\'calcSpinner\');\n            var workerMessageArray = [numberOfSorts, numberofPrincipalComps, X];\n            var myWorker = new Worker(\'wrkrs/workerPCA.js\');\n            myWorker.postMessage(workerMessageArray);\n            myWorker.onmessage = function (e) {\n                eigenVecs = e.data[0];\n                eigenValuesSorted = e.data[1];\n                eigenValuesAsPercents = e.data[2];\n                eigenValuesCumulPercentArray = e.data[3];\n\n                QAV.setState("centroidFactors", eigenVecs);\n                QAV.setState("eigenValuesSorted", eigenValuesSorted);\n                QAV.setState("eigenValuesAsPercents", eigenValuesAsPercents);\n                QAV.setState("eigenValuesCumulPercentArray", eigenValuesCumulPercentArray);\n                QAV.setState("eigenVecs", eigenVecs);\n\n                var language = QAV.getState("language");\n                var appendText = resources[language].translation["8 Principal Components Extracted"];\n                $("#rotationHistoryList").append(\'<li>\' + appendText + \'</button></li>\');\n\n                // hide spinner and change button display state\n                $("#factorExtractionSpinnerText").css(\'visibility\', \'hidden\');\n                $("#factorExtractionSpinnerDiv").removeClass(\'calcSpinner\');\n                VIEW.changePcaExtractionButtonDisplay();\n\n                // display components\n                PCA.drawExtractedFactorsTable();\n\n                // get data for scree plot\n                dataArray2 = eigenValuesSorted;\n                dataArray = dataArray2.slice(0, 8);\n\n                UTIL.drawScreePlot(dataArray);\n\n                $("#section4 > input").show();\n\n                return [eigenValuesSorted, eigenValuesAsPercents, eigenValuesCumulPercentArray, eigenVecs];\n            };\n        } else {\n            // if web workers not available\n            var svd, eigens;\n            var getEigenCumulPercentArray, doEigenVecsCalcs;\n            var inflectionArray;\n\n            // // svd = matrix of all principle components as column vectors          \n            svd = PCA.calcSvd(X);\n\n            // eigens = eigenvalues for data X \n            eigens = PCA.calcEigens(X);\n\n            // sort eigenValues from numeric\n            eigenValuesSorted = PCA.sortEigenValues(eigens.lambda.x);\n\n            // convert to percents and push to array\n            getEigenCumulPercentArray = PCA.calcEigenCumulPercentArray(eigenValuesSorted, numberOfSorts);\n\n            eigenValuesAsPercents = getEigenCumulPercentArray[0];\n            eigenValuesCumulPercentArray = getEigenCumulPercentArray[1];\n\n            doEigenVecsCalcs = PCA.calcEigenVectors(numberOfSorts, numberofPrincipalComps, eigenValuesSorted, svd);\n\n            eigenVecs = doEigenVecsCalcs[0];\n            inflectionArray = doEigenVecsCalcs[1];\n\n            eigenVecs = PCA.inflectPrincipalComponents(eigenVecs, inflectionArray);\n\n            QAV.setState("centroidFactors", eigenVecs);\n            QAV.setState("eigenValuesSorted", eigenValuesSorted);\n            QAV.setState("eigenValuesAsPercents", eigenValuesAsPercents);\n            QAV.setState("eigenValuesCumulPercentArray", eigenValuesCumulPercentArray);\n            QAV.setState("eigenVecs", eigenVecs);\n\n            var language = QAV.getState("language");\n            var appendText = resources[language].translation["8 Principal Components Extracted"];\n            $("#rotationHistoryList").append(\'<li>\' + appendText + \'</button></li>\');\n\n            // hide spinner and change button display state\n            VIEW.changePcaExtractionButtonDisplay();\n            PCA.drawExtractedFactorsTable();\n\n            // get data for scree plot\n            dataArray2 = eigenValuesSorted;\n            dataArray = dataArray2.slice(0, 8);\n\n            UTIL.drawScreePlot(dataArray);\n\n            $("#section4 > input").show();\n\n            return [eigenValuesSorted, eigenValuesAsPercents, eigenValuesCumulPercentArray, eigenVecs];\n        }\n    }; // END OF DO PCA FUNCTION\n\n\n\n    PCA.inflectPrincipalComponents = function (eigenVecs, inflectionArray) {\n        // check and inflect components if necessary\n        for (var s = 0; s < eigenVecs[0].length; s++) {\n            if (inflectionArray[s] < 0.0) {\n                for (var t = 0; t < eigenVecs.length; t++) {\n                    eigenVecs[t][s] = -eigenVecs[t][s];\n                }\n            }\n        }\n        return eigenVecs;\n    };\n\n    PCA.calcEigenVectors = function (numberOfSorts, numberofPrincipalComps, eigenValuesSorted, svd) {\n        var inflectionArray = [];\n        var temp1, critInflectionValue, temp3, temp4;\n        // setup empty array\n        var eigenVecs = [];\n        for (var p = 0; p < numberOfSorts; p++) {\n            eigenVecs.push([]);\n        }\n        // loop through each component    \n        for (var i = 0, iLen = numberofPrincipalComps; i < iLen; i++) {\n            temp1 = Math.sqrt(eigenValuesSorted[i]);\n            critInflectionValue = 0;\n\n            // loop through each QSort to get loading and also calc CRIT\n            for (var j = 0, jLen = svd.length; j < jLen; j++) {\n                temp3 = evenRound((svd[j][i] * temp1), 8);\n                eigenVecs[j][i] = temp3;\n                // set up data for influection test\n                temp4 = evenRound((temp3 * Math.abs(temp3)), 8);\n                critInflectionValue = critInflectionValue + temp4;\n            }\n            inflectionArray.push(evenRound(critInflectionValue, 8));\n        }\n        return [eigenVecs, inflectionArray];\n    };\n\n\n    PCA.calcEigenCumulPercentArray = function (eigenValuesSorted, numberOfSorts) {\n        var percentNumber = 100 / numberOfSorts;\n        var eigenValuesAsPercents = [];\n        var eigenValuesPercent;\n        var eigenValuesCumulPercentArray = [];\n        var eigenValueCumulPercentAccum = 0;\n\n        for (var k = 0, kLen = eigenValuesSorted.length; k < kLen; k++) {\n            eigenValuesSorted[k] = evenRound((eigenValuesSorted[k]), 8);\n            eigenValuesPercent = evenRound((eigenValuesSorted[k] * percentNumber), 0);\n            eigenValuesAsPercents.push(eigenValuesPercent);\n            eigenValueCumulPercentAccum = eigenValueCumulPercentAccum + eigenValuesPercent;\n            eigenValuesCumulPercentArray.push(eigenValueCumulPercentAccum);\n        }\n        return [eigenValuesAsPercents, eigenValuesCumulPercentArray];\n    };\n\n\n    PCA.sortEigenValues = function (values) {\n        // sort eigenValues from numeric\n        // eigenValuesSorted = eigens.lambda.x;\n        values.sort(function (a, b) {\n            return (b - a);\n        });\n        return values;\n    };\n\n\n    PCA.calcSvd = function (X) {\n        // svd = matrix of all principle components as column vectors          \n        var m, sigma, svd;\n        m = X.length;\n        sigma = numeric.div(numeric.dot(numeric.transpose(X), X), m);\n        svd = numeric.svd(sigma).U;\n        return svd;\n    };\n\n    PCA.calcEigens = function (X) {\n        // eigens = eigenvalues for data X \n        var eigens = numeric.eig(X);\n        return eigens;\n    };\n\n    PCA.drawExtractedFactorsTable = function () {\n        var eigenVecs = QAV.getState("eigenVecs");\n        var i, j, names, pcaHeaders, headersLength, pcaTableHeaders, pcaTargets, pcaTableTargets;\n\n        names = QAV.getState("respondentNames");\n        for (i = 0; i < eigenVecs.length; i++) {\n            j = i + 1;\n            eigenVecs[i].unshift(j, names[j]);\n        }\n\n        var language = QAV.getState("language");\n        var facText = resources[language].translation.Factor;\n        var respondText = resources[language].translation.Respondent;\n\n        pcaHeaders = [{\n                title: "Number"\n            }, {\n                title: respondText\n            },\n            {\n                title: facText + " 1"\n            },\n            {\n                title: facText + " 2"\n            },\n            {\n                title: facText + " 3"\n            },\n            {\n                title: facText + " 4"\n            },\n            {\n                title: facText + " 5"\n            },\n            {\n                title: facText + " 6"\n            },\n            {\n                title: facText + " 7"\n            },\n            {\n                title: facText + " 8"\n            }\n        ];\n\n        pcaTargets = [2, 3, 4, 5, 6, 7, 8, 9];\n\n\n        headersLength = QAV.pcaNumberFactorsExtracted + 2;\n        pcaTableHeaders = pcaHeaders.slice(0, headersLength);\n        pcaTableTargets = pcaTargets.slice(0, QAV.pcaNumberFactorsExtracted);\n\n        QAV.pcaTableHeaders = pcaTableHeaders;\n        QAV.pcaTableTargets = pcaTableTargets;\n\n        var configObj = {};\n        configObj.domElement = "#factorRotationTable1";\n        configObj.fixed = false;\n        configObj.data = eigenVecs;\n        configObj.headers = pcaTableHeaders;\n        configObj.colDefs = [{\n                targets: [0, 1],\n                className: \'dt-head-center dt-body-center dt-body-name\'\n            },\n            {\n                targets: pcaTableTargets,\n                className: \'dt-head-center dt-body-right\'\n            },\n            {\n                targets: \'_all\',\n                "createdCell": function (td, cellData, rowData, row, col) {\n                    if (cellData < 0) {\n                        $(td).css(\'color\', \'red\');\n                    }\n                }\n            }\n        ];\n\n        UTIL.drawDatatable(configObj);\n        PCA.createFooter();\n\n    };\n\n    PCA.createFooter = function () {\n        // create footer\n        var footer, temp, temp2, temp3, tableArray, array, array2, array3, tr, th;\n        var pcaFooterTableHeaders;\n\n        var language = QAV.getState("language");\n        var cumVarText = resources[language].translation["Cum % Expln Var"];\n        var varText = resources[language].translation["% explained variance"];\n        var eigenText = resources[language].translation.Eigenvalues;\n\n\n        temp = QAV.getState("eigenValuesSorted");\n        temp.unshift("", eigenText);\n        array = temp.slice(0, 10);\n\n        temp2 = QAV.getState("eigenValuesAsPercents");\n        temp2.unshift("", varText);\n        array2 = temp2.slice(0, 10);\n\n        temp3 = QAV.getState("eigenValuesCumulPercentArray");\n        temp3.unshift("", cumVarText);\n        array3 = temp3.slice(0, 10);\n\n\n        tableArray = [];\n        tableArray.push(array, array2, array3);\n\n        pcaFooterTableHeaders = QAV.getState("pcaTableHeaders");\n        pcaFooterTableHeaders[0].title = "";\n        pcaFooterTableHeaders[0].sTitle = "";\n        pcaFooterTableHeaders[1].title = "";\n        pcaFooterTableHeaders[1].sTitle = "";\n\n\n        var configObj = {};\n        configObj.domElement = "#factorRotationTable1Footer";\n        configObj.fixed = false;\n        configObj.data = tableArray;\n        configObj.ordering = false;\n        configObj.headers = pcaFooterTableHeaders;\n        configObj.colDefs = [{\n                targets: [0, 1],\n                className: \'dt-head-center dt-body-center dt-body-name\'\n            },\n            {\n                targets: _.clone(QAV.pcaTableTargets),\n                className: \'dt-head-center dt-body-right\'\n            },\n            {\n                targets: \'_all\',\n                "createdCell": function (td, cellData, rowData, row, col) {\n                    if (cellData < 0) {\n                        $(td).css(\'color\', \'red\');\n                    }\n                }\n            }\n        ];\n\n        UTIL.drawDatatable(configObj);\n\n    };\n\n}(window.PCA = window.PCA || {}, QAV));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUENBLmpzPzU4OWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy9LZW4tUSBBbmFseXNpc1xuLy9Db3B5cmlnaHQgKEMpIDIwMTYgU2hhd24gQmFuYXNpY2tcbi8vXG4vLyAgICBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG5cbi8vIEpTbGludCBkZWNsYXJhdGlvbnNcbi8qIGdsb2JhbCBudW1lcmljLCB3aW5kb3csIFFBViwgJCwgZG9jdW1lbnQsIEpRdWVyeSwgZXZlblJvdW5kLCBVVElMLCBsb2NhbFN0b3JhZ2UsIF8gKi9cblxuKGZ1bmN0aW9uIChQQ0EsIFFBViwgdW5kZWZpbmVkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgUENBLmRvUHJpbmNpcGFsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChYKSB7XG4gICAgICAgIHZhciBudW1iZXJPZlNvcnRzLCB0ZW1wNCwgdGVtcDUsIHBjYUZhY3RvcnNUb0V4dHJhY3RBcnJheSwgbnVtYmVyRmFjdG9yc0V4dHJhY3RlZDtcbiAgICAgICAgdmFyIG51bWJlcm9mUHJpbmNpcGFsQ29tcHMsIG07XG4gICAgICAgIHZhciBmYWN0b3JMYWJlbHMgPSBbXTtcbiAgICAgICAgdmFyIGVpZ2VuVmVjcywgZWlnZW5WYWx1ZXNTb3J0ZWQsIGVpZ2VuVmFsdWVzQXNQZXJjZW50cywgZWlnZW5WYWx1ZXNDdW11bFBlcmNlbnRBcnJheTtcbiAgICAgICAgdmFyIGRhdGFBcnJheSwgZGF0YUFycmF5MjtcblxuICAgICAgICAvLyB0byBkaWZmZXJlbnRpYXRlIG91dHB1dCBmdW5jdGlvbnNcbiAgICAgICAgUUFWLnNldFN0YXRlKFwidHlwZU9mRmFjdG9yXCIsIFwiUENBXCIpO1xuXG4gICAgICAgIG51bWJlck9mU29ydHMgPSBRQVYuZ2V0U3RhdGUoXCJ0b3RhbE51bWJlclNvcnRzXCIpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgbWF4IG51bWJlciBvZiBmYWN0b3JzIHRvIGV4dHJhY3RcbiAgICAgICAgdGVtcDQgPSBRQVYuZ2V0U3RhdGUoXCJvcmlnaW5hbFNvcnRTaXplXCIpO1xuICAgICAgICB0ZW1wNSA9IFFBVi5nZXRTdGF0ZShcInRvdGFsTnVtYmVyU29ydHNcIik7XG4gICAgICAgIHBjYUZhY3RvcnNUb0V4dHJhY3RBcnJheSA9IFs4LCB0ZW1wNCwgdGVtcDVdO1xuICAgICAgICBudW1iZXJGYWN0b3JzRXh0cmFjdGVkID0gXy5taW4ocGNhRmFjdG9yc1RvRXh0cmFjdEFycmF5KTtcblxuXG4gICAgICAgIG51bWJlcm9mUHJpbmNpcGFsQ29tcHMgPSBudW1iZXJGYWN0b3JzRXh0cmFjdGVkO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJudW1iZXJGYWN0b3JzRXh0cmFjdGVkXCIsIG51bWJlckZhY3RvcnNFeHRyYWN0ZWQpO1xuICAgICAgICAvLyAgUUFWLnBjYU51bWJlckZhY3RvcnNFeHRyYWN0ZWQgPSBudW1iZXJGYWN0b3JzRXh0cmFjdGVkO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJwY2FOdW1iZXJGYWN0b3JzRXh0cmFjdGVkXCIsIG51bWJlckZhY3RvcnNFeHRyYWN0ZWQpO1xuICAgICAgICBVVElMLmFkZEZhY3RvclNlbGVjdENoZWNrYm94ZXNSb3RhdGlvbihudW1iZXJGYWN0b3JzRXh0cmFjdGVkKTtcblxuICAgICAgICAvLyBsYWJlbHMgYWNjb3JkaW5nIHRvIGZhY3RvcnMgZXh0YWN0ZWQgKGFib3ZlKVxuICAgICAgICBmb3IgKG0gPSAwOyBtIDwgbnVtYmVyRmFjdG9yc0V4dHJhY3RlZDsgbSsrKSB7XG4gICAgICAgICAgICBmYWN0b3JMYWJlbHMucHVzaChcIkZhY3RvciBcIiArIChtICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcImZhY3RvckxhYmVsc1wiLCBmYWN0b3JMYWJlbHMpO1xuXG4gICAgICAgIHZhciBpc09ubGluZSA9IFVUSUwuY2hlY2tJZk9ubGluZSgpO1xuXG4gICAgICAgIC8vIHVzZSB3ZWIgd29ya2VyIGlmIGF2YWlsYWJsZSBhbmQgbm90IHJ1bm5pbmcgZnJvbSBsb2NhbCBmaWxlXG4gICAgICAgIGlmICh3aW5kb3cuV29ya2VyICYmIGlzT25saW5lKSB7XG4gICAgICAgICAgICAkKFwiI2ZhY3RvckV4dHJhY3Rpb25TcGlubmVyVGV4dFwiKS5jc3MoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICAgICAgJChcIiNmYWN0b3JFeHRyYWN0aW9uU3Bpbm5lckRpdlwiKS5hZGRDbGFzcygnY2FsY1NwaW5uZXInKTtcbiAgICAgICAgICAgIHZhciB3b3JrZXJNZXNzYWdlQXJyYXkgPSBbbnVtYmVyT2ZTb3J0cywgbnVtYmVyb2ZQcmluY2lwYWxDb21wcywgWF07XG4gICAgICAgICAgICB2YXIgbXlXb3JrZXIgPSBuZXcgV29ya2VyKCd3cmtycy93b3JrZXJQQ0EuanMnKTtcbiAgICAgICAgICAgIG15V29ya2VyLnBvc3RNZXNzYWdlKHdvcmtlck1lc3NhZ2VBcnJheSk7XG4gICAgICAgICAgICBteVdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGVpZ2VuVmVjcyA9IGUuZGF0YVswXTtcbiAgICAgICAgICAgICAgICBlaWdlblZhbHVlc1NvcnRlZCA9IGUuZGF0YVsxXTtcbiAgICAgICAgICAgICAgICBlaWdlblZhbHVlc0FzUGVyY2VudHMgPSBlLmRhdGFbMl07XG4gICAgICAgICAgICAgICAgZWlnZW5WYWx1ZXNDdW11bFBlcmNlbnRBcnJheSA9IGUuZGF0YVszXTtcblxuICAgICAgICAgICAgICAgIFFBVi5zZXRTdGF0ZShcImNlbnRyb2lkRmFjdG9yc1wiLCBlaWdlblZlY3MpO1xuICAgICAgICAgICAgICAgIFFBVi5zZXRTdGF0ZShcImVpZ2VuVmFsdWVzU29ydGVkXCIsIGVpZ2VuVmFsdWVzU29ydGVkKTtcbiAgICAgICAgICAgICAgICBRQVYuc2V0U3RhdGUoXCJlaWdlblZhbHVlc0FzUGVyY2VudHNcIiwgZWlnZW5WYWx1ZXNBc1BlcmNlbnRzKTtcbiAgICAgICAgICAgICAgICBRQVYuc2V0U3RhdGUoXCJlaWdlblZhbHVlc0N1bXVsUGVyY2VudEFycmF5XCIsIGVpZ2VuVmFsdWVzQ3VtdWxQZXJjZW50QXJyYXkpO1xuICAgICAgICAgICAgICAgIFFBVi5zZXRTdGF0ZShcImVpZ2VuVmVjc1wiLCBlaWdlblZlY3MpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgICAgICAgICAgdmFyIGFwcGVuZFRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiOCBQcmluY2lwYWwgQ29tcG9uZW50cyBFeHRyYWN0ZWRcIl07XG4gICAgICAgICAgICAgICAgJChcIiNyb3RhdGlvbkhpc3RvcnlMaXN0XCIpLmFwcGVuZCgnPGxpPicgKyBhcHBlbmRUZXh0ICsgJzwvYnV0dG9uPjwvbGk+Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBoaWRlIHNwaW5uZXIgYW5kIGNoYW5nZSBidXR0b24gZGlzcGxheSBzdGF0ZVxuICAgICAgICAgICAgICAgICQoXCIjZmFjdG9yRXh0cmFjdGlvblNwaW5uZXJUZXh0XCIpLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAkKFwiI2ZhY3RvckV4dHJhY3Rpb25TcGlubmVyRGl2XCIpLnJlbW92ZUNsYXNzKCdjYWxjU3Bpbm5lcicpO1xuICAgICAgICAgICAgICAgIFZJRVcuY2hhbmdlUGNhRXh0cmFjdGlvbkJ1dHRvbkRpc3BsYXkoKTtcblxuICAgICAgICAgICAgICAgIC8vIGRpc3BsYXkgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIFBDQS5kcmF3RXh0cmFjdGVkRmFjdG9yc1RhYmxlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgZGF0YSBmb3Igc2NyZWUgcGxvdFxuICAgICAgICAgICAgICAgIGRhdGFBcnJheTIgPSBlaWdlblZhbHVlc1NvcnRlZDtcbiAgICAgICAgICAgICAgICBkYXRhQXJyYXkgPSBkYXRhQXJyYXkyLnNsaWNlKDAsIDgpO1xuXG4gICAgICAgICAgICAgICAgVVRJTC5kcmF3U2NyZWVQbG90KGRhdGFBcnJheSk7XG5cbiAgICAgICAgICAgICAgICAkKFwiI3NlY3Rpb240ID4gaW5wdXRcIikuc2hvdygpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlaWdlblZhbHVlc1NvcnRlZCwgZWlnZW5WYWx1ZXNBc1BlcmNlbnRzLCBlaWdlblZhbHVlc0N1bXVsUGVyY2VudEFycmF5LCBlaWdlblZlY3NdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHdlYiB3b3JrZXJzIG5vdCBhdmFpbGFibGVcbiAgICAgICAgICAgIHZhciBzdmQsIGVpZ2VucztcbiAgICAgICAgICAgIHZhciBnZXRFaWdlbkN1bXVsUGVyY2VudEFycmF5LCBkb0VpZ2VuVmVjc0NhbGNzO1xuICAgICAgICAgICAgdmFyIGluZmxlY3Rpb25BcnJheTtcblxuICAgICAgICAgICAgLy8gLy8gc3ZkID0gbWF0cml4IG9mIGFsbCBwcmluY2lwbGUgY29tcG9uZW50cyBhcyBjb2x1bW4gdmVjdG9ycyAgICAgICAgICBcbiAgICAgICAgICAgIHN2ZCA9IFBDQS5jYWxjU3ZkKFgpO1xuXG4gICAgICAgICAgICAvLyBlaWdlbnMgPSBlaWdlbnZhbHVlcyBmb3IgZGF0YSBYIFxuICAgICAgICAgICAgZWlnZW5zID0gUENBLmNhbGNFaWdlbnMoWCk7XG5cbiAgICAgICAgICAgIC8vIHNvcnQgZWlnZW5WYWx1ZXMgZnJvbSBudW1lcmljXG4gICAgICAgICAgICBlaWdlblZhbHVlc1NvcnRlZCA9IFBDQS5zb3J0RWlnZW5WYWx1ZXMoZWlnZW5zLmxhbWJkYS54KTtcblxuICAgICAgICAgICAgLy8gY29udmVydCB0byBwZXJjZW50cyBhbmQgcHVzaCB0byBhcnJheVxuICAgICAgICAgICAgZ2V0RWlnZW5DdW11bFBlcmNlbnRBcnJheSA9IFBDQS5jYWxjRWlnZW5DdW11bFBlcmNlbnRBcnJheShlaWdlblZhbHVlc1NvcnRlZCwgbnVtYmVyT2ZTb3J0cyk7XG5cbiAgICAgICAgICAgIGVpZ2VuVmFsdWVzQXNQZXJjZW50cyA9IGdldEVpZ2VuQ3VtdWxQZXJjZW50QXJyYXlbMF07XG4gICAgICAgICAgICBlaWdlblZhbHVlc0N1bXVsUGVyY2VudEFycmF5ID0gZ2V0RWlnZW5DdW11bFBlcmNlbnRBcnJheVsxXTtcblxuICAgICAgICAgICAgZG9FaWdlblZlY3NDYWxjcyA9IFBDQS5jYWxjRWlnZW5WZWN0b3JzKG51bWJlck9mU29ydHMsIG51bWJlcm9mUHJpbmNpcGFsQ29tcHMsIGVpZ2VuVmFsdWVzU29ydGVkLCBzdmQpO1xuXG4gICAgICAgICAgICBlaWdlblZlY3MgPSBkb0VpZ2VuVmVjc0NhbGNzWzBdO1xuICAgICAgICAgICAgaW5mbGVjdGlvbkFycmF5ID0gZG9FaWdlblZlY3NDYWxjc1sxXTtcblxuICAgICAgICAgICAgZWlnZW5WZWNzID0gUENBLmluZmxlY3RQcmluY2lwYWxDb21wb25lbnRzKGVpZ2VuVmVjcywgaW5mbGVjdGlvbkFycmF5KTtcblxuICAgICAgICAgICAgUUFWLnNldFN0YXRlKFwiY2VudHJvaWRGYWN0b3JzXCIsIGVpZ2VuVmVjcyk7XG4gICAgICAgICAgICBRQVYuc2V0U3RhdGUoXCJlaWdlblZhbHVlc1NvcnRlZFwiLCBlaWdlblZhbHVlc1NvcnRlZCk7XG4gICAgICAgICAgICBRQVYuc2V0U3RhdGUoXCJlaWdlblZhbHVlc0FzUGVyY2VudHNcIiwgZWlnZW5WYWx1ZXNBc1BlcmNlbnRzKTtcbiAgICAgICAgICAgIFFBVi5zZXRTdGF0ZShcImVpZ2VuVmFsdWVzQ3VtdWxQZXJjZW50QXJyYXlcIiwgZWlnZW5WYWx1ZXNDdW11bFBlcmNlbnRBcnJheSk7XG4gICAgICAgICAgICBRQVYuc2V0U3RhdGUoXCJlaWdlblZlY3NcIiwgZWlnZW5WZWNzKTtcblxuICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgICAgICB2YXIgYXBwZW5kVGV4dCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCI4IFByaW5jaXBhbCBDb21wb25lbnRzIEV4dHJhY3RlZFwiXTtcbiAgICAgICAgICAgICQoXCIjcm90YXRpb25IaXN0b3J5TGlzdFwiKS5hcHBlbmQoJzxsaT4nICsgYXBwZW5kVGV4dCArICc8L2J1dHRvbj48L2xpPicpO1xuXG4gICAgICAgICAgICAvLyBoaWRlIHNwaW5uZXIgYW5kIGNoYW5nZSBidXR0b24gZGlzcGxheSBzdGF0ZVxuICAgICAgICAgICAgVklFVy5jaGFuZ2VQY2FFeHRyYWN0aW9uQnV0dG9uRGlzcGxheSgpO1xuICAgICAgICAgICAgUENBLmRyYXdFeHRyYWN0ZWRGYWN0b3JzVGFibGUoKTtcblxuICAgICAgICAgICAgLy8gZ2V0IGRhdGEgZm9yIHNjcmVlIHBsb3RcbiAgICAgICAgICAgIGRhdGFBcnJheTIgPSBlaWdlblZhbHVlc1NvcnRlZDtcbiAgICAgICAgICAgIGRhdGFBcnJheSA9IGRhdGFBcnJheTIuc2xpY2UoMCwgOCk7XG5cbiAgICAgICAgICAgIFVUSUwuZHJhd1NjcmVlUGxvdChkYXRhQXJyYXkpO1xuXG4gICAgICAgICAgICAkKFwiI3NlY3Rpb240ID4gaW5wdXRcIikuc2hvdygpO1xuXG4gICAgICAgICAgICByZXR1cm4gW2VpZ2VuVmFsdWVzU29ydGVkLCBlaWdlblZhbHVlc0FzUGVyY2VudHMsIGVpZ2VuVmFsdWVzQ3VtdWxQZXJjZW50QXJyYXksIGVpZ2VuVmVjc107XG4gICAgICAgIH1cbiAgICB9OyAvLyBFTkQgT0YgRE8gUENBIEZVTkNUSU9OXG5cblxuXG4gICAgUENBLmluZmxlY3RQcmluY2lwYWxDb21wb25lbnRzID0gZnVuY3Rpb24gKGVpZ2VuVmVjcywgaW5mbGVjdGlvbkFycmF5KSB7XG4gICAgICAgIC8vIGNoZWNrIGFuZCBpbmZsZWN0IGNvbXBvbmVudHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgZWlnZW5WZWNzWzBdLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICBpZiAoaW5mbGVjdGlvbkFycmF5W3NdIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBlaWdlblZlY3MubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZWlnZW5WZWNzW3RdW3NdID0gLWVpZ2VuVmVjc1t0XVtzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVpZ2VuVmVjcztcbiAgICB9O1xuXG4gICAgUENBLmNhbGNFaWdlblZlY3RvcnMgPSBmdW5jdGlvbiAobnVtYmVyT2ZTb3J0cywgbnVtYmVyb2ZQcmluY2lwYWxDb21wcywgZWlnZW5WYWx1ZXNTb3J0ZWQsIHN2ZCkge1xuICAgICAgICB2YXIgaW5mbGVjdGlvbkFycmF5ID0gW107XG4gICAgICAgIHZhciB0ZW1wMSwgY3JpdEluZmxlY3Rpb25WYWx1ZSwgdGVtcDMsIHRlbXA0O1xuICAgICAgICAvLyBzZXR1cCBlbXB0eSBhcnJheVxuICAgICAgICB2YXIgZWlnZW5WZWNzID0gW107XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgbnVtYmVyT2ZTb3J0czsgcCsrKSB7XG4gICAgICAgICAgICBlaWdlblZlY3MucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGVhY2ggY29tcG9uZW50ICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IG51bWJlcm9mUHJpbmNpcGFsQ29tcHM7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXAxID0gTWF0aC5zcXJ0KGVpZ2VuVmFsdWVzU29ydGVkW2ldKTtcbiAgICAgICAgICAgIGNyaXRJbmZsZWN0aW9uVmFsdWUgPSAwO1xuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBRU29ydCB0byBnZXQgbG9hZGluZyBhbmQgYWxzbyBjYWxjIENSSVRcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gc3ZkLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgICAgICAgIHRlbXAzID0gZXZlblJvdW5kKChzdmRbal1baV0gKiB0ZW1wMSksIDgpO1xuICAgICAgICAgICAgICAgIGVpZ2VuVmVjc1tqXVtpXSA9IHRlbXAzO1xuICAgICAgICAgICAgICAgIC8vIHNldCB1cCBkYXRhIGZvciBpbmZsdWVjdGlvbiB0ZXN0XG4gICAgICAgICAgICAgICAgdGVtcDQgPSBldmVuUm91bmQoKHRlbXAzICogTWF0aC5hYnModGVtcDMpKSwgOCk7XG4gICAgICAgICAgICAgICAgY3JpdEluZmxlY3Rpb25WYWx1ZSA9IGNyaXRJbmZsZWN0aW9uVmFsdWUgKyB0ZW1wNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmxlY3Rpb25BcnJheS5wdXNoKGV2ZW5Sb3VuZChjcml0SW5mbGVjdGlvblZhbHVlLCA4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtlaWdlblZlY3MsIGluZmxlY3Rpb25BcnJheV07XG4gICAgfTtcblxuXG4gICAgUENBLmNhbGNFaWdlbkN1bXVsUGVyY2VudEFycmF5ID0gZnVuY3Rpb24gKGVpZ2VuVmFsdWVzU29ydGVkLCBudW1iZXJPZlNvcnRzKSB7XG4gICAgICAgIHZhciBwZXJjZW50TnVtYmVyID0gMTAwIC8gbnVtYmVyT2ZTb3J0cztcbiAgICAgICAgdmFyIGVpZ2VuVmFsdWVzQXNQZXJjZW50cyA9IFtdO1xuICAgICAgICB2YXIgZWlnZW5WYWx1ZXNQZXJjZW50O1xuICAgICAgICB2YXIgZWlnZW5WYWx1ZXNDdW11bFBlcmNlbnRBcnJheSA9IFtdO1xuICAgICAgICB2YXIgZWlnZW5WYWx1ZUN1bXVsUGVyY2VudEFjY3VtID0gMDtcblxuICAgICAgICBmb3IgKHZhciBrID0gMCwga0xlbiA9IGVpZ2VuVmFsdWVzU29ydGVkLmxlbmd0aDsgayA8IGtMZW47IGsrKykge1xuICAgICAgICAgICAgZWlnZW5WYWx1ZXNTb3J0ZWRba10gPSBldmVuUm91bmQoKGVpZ2VuVmFsdWVzU29ydGVkW2tdKSwgOCk7XG4gICAgICAgICAgICBlaWdlblZhbHVlc1BlcmNlbnQgPSBldmVuUm91bmQoKGVpZ2VuVmFsdWVzU29ydGVkW2tdICogcGVyY2VudE51bWJlciksIDApO1xuICAgICAgICAgICAgZWlnZW5WYWx1ZXNBc1BlcmNlbnRzLnB1c2goZWlnZW5WYWx1ZXNQZXJjZW50KTtcbiAgICAgICAgICAgIGVpZ2VuVmFsdWVDdW11bFBlcmNlbnRBY2N1bSA9IGVpZ2VuVmFsdWVDdW11bFBlcmNlbnRBY2N1bSArIGVpZ2VuVmFsdWVzUGVyY2VudDtcbiAgICAgICAgICAgIGVpZ2VuVmFsdWVzQ3VtdWxQZXJjZW50QXJyYXkucHVzaChlaWdlblZhbHVlQ3VtdWxQZXJjZW50QWNjdW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZWlnZW5WYWx1ZXNBc1BlcmNlbnRzLCBlaWdlblZhbHVlc0N1bXVsUGVyY2VudEFycmF5XTtcbiAgICB9O1xuXG5cbiAgICBQQ0Euc29ydEVpZ2VuVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAvLyBzb3J0IGVpZ2VuVmFsdWVzIGZyb20gbnVtZXJpY1xuICAgICAgICAvLyBlaWdlblZhbHVlc1NvcnRlZCA9IGVpZ2Vucy5sYW1iZGEueDtcbiAgICAgICAgdmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYiAtIGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuXG5cbiAgICBQQ0EuY2FsY1N2ZCA9IGZ1bmN0aW9uIChYKSB7XG4gICAgICAgIC8vIHN2ZCA9IG1hdHJpeCBvZiBhbGwgcHJpbmNpcGxlIGNvbXBvbmVudHMgYXMgY29sdW1uIHZlY3RvcnMgICAgICAgICAgXG4gICAgICAgIHZhciBtLCBzaWdtYSwgc3ZkO1xuICAgICAgICBtID0gWC5sZW5ndGg7XG4gICAgICAgIHNpZ21hID0gbnVtZXJpYy5kaXYobnVtZXJpYy5kb3QobnVtZXJpYy50cmFuc3Bvc2UoWCksIFgpLCBtKTtcbiAgICAgICAgc3ZkID0gbnVtZXJpYy5zdmQoc2lnbWEpLlU7XG4gICAgICAgIHJldHVybiBzdmQ7XG4gICAgfTtcblxuICAgIFBDQS5jYWxjRWlnZW5zID0gZnVuY3Rpb24gKFgpIHtcbiAgICAgICAgLy8gZWlnZW5zID0gZWlnZW52YWx1ZXMgZm9yIGRhdGEgWCBcbiAgICAgICAgdmFyIGVpZ2VucyA9IG51bWVyaWMuZWlnKFgpO1xuICAgICAgICByZXR1cm4gZWlnZW5zO1xuICAgIH07XG5cbiAgICBQQ0EuZHJhd0V4dHJhY3RlZEZhY3RvcnNUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVpZ2VuVmVjcyA9IFFBVi5nZXRTdGF0ZShcImVpZ2VuVmVjc1wiKTtcbiAgICAgICAgdmFyIGksIGosIG5hbWVzLCBwY2FIZWFkZXJzLCBoZWFkZXJzTGVuZ3RoLCBwY2FUYWJsZUhlYWRlcnMsIHBjYVRhcmdldHMsIHBjYVRhYmxlVGFyZ2V0cztcblxuICAgICAgICBuYW1lcyA9IFFBVi5nZXRTdGF0ZShcInJlc3BvbmRlbnROYW1lc1wiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVpZ2VuVmVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICAgICAgZWlnZW5WZWNzW2ldLnVuc2hpZnQoaiwgbmFtZXNbal0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBmYWNUZXh0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5GYWN0b3I7XG4gICAgICAgIHZhciByZXNwb25kVGV4dCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uUmVzcG9uZGVudDtcblxuICAgICAgICBwY2FIZWFkZXJzID0gW3tcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJOdW1iZXJcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRpdGxlOiByZXNwb25kVGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogZmFjVGV4dCArIFwiIDFcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogZmFjVGV4dCArIFwiIDJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogZmFjVGV4dCArIFwiIDNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogZmFjVGV4dCArIFwiIDRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogZmFjVGV4dCArIFwiIDVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogZmFjVGV4dCArIFwiIDZcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogZmFjVGV4dCArIFwiIDdcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogZmFjVGV4dCArIFwiIDhcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuXG4gICAgICAgIHBjYVRhcmdldHMgPSBbMiwgMywgNCwgNSwgNiwgNywgOCwgOV07XG5cblxuICAgICAgICBoZWFkZXJzTGVuZ3RoID0gUUFWLnBjYU51bWJlckZhY3RvcnNFeHRyYWN0ZWQgKyAyO1xuICAgICAgICBwY2FUYWJsZUhlYWRlcnMgPSBwY2FIZWFkZXJzLnNsaWNlKDAsIGhlYWRlcnNMZW5ndGgpO1xuICAgICAgICBwY2FUYWJsZVRhcmdldHMgPSBwY2FUYXJnZXRzLnNsaWNlKDAsIFFBVi5wY2FOdW1iZXJGYWN0b3JzRXh0cmFjdGVkKTtcblxuICAgICAgICBRQVYucGNhVGFibGVIZWFkZXJzID0gcGNhVGFibGVIZWFkZXJzO1xuICAgICAgICBRQVYucGNhVGFibGVUYXJnZXRzID0gcGNhVGFibGVUYXJnZXRzO1xuXG4gICAgICAgIHZhciBjb25maWdPYmogPSB7fTtcbiAgICAgICAgY29uZmlnT2JqLmRvbUVsZW1lbnQgPSBcIiNmYWN0b3JSb3RhdGlvblRhYmxlMVwiO1xuICAgICAgICBjb25maWdPYmouZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uZmlnT2JqLmRhdGEgPSBlaWdlblZlY3M7XG4gICAgICAgIGNvbmZpZ09iai5oZWFkZXJzID0gcGNhVGFibGVIZWFkZXJzO1xuICAgICAgICBjb25maWdPYmouY29sRGVmcyA9IFt7XG4gICAgICAgICAgICAgICAgdGFyZ2V0czogWzAsIDFdLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2R0LWhlYWQtY2VudGVyIGR0LWJvZHktY2VudGVyIGR0LWJvZHktbmFtZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0czogcGNhVGFibGVUYXJnZXRzLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2R0LWhlYWQtY2VudGVyIGR0LWJvZHktcmlnaHQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldHM6ICdfYWxsJyxcbiAgICAgICAgICAgICAgICBcImNyZWF0ZWRDZWxsXCI6IGZ1bmN0aW9uICh0ZCwgY2VsbERhdGEsIHJvd0RhdGEsIHJvdywgY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsRGF0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGQpLmNzcygnY29sb3InLCAncmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG5cbiAgICAgICAgVVRJTC5kcmF3RGF0YXRhYmxlKGNvbmZpZ09iaik7XG4gICAgICAgIFBDQS5jcmVhdGVGb290ZXIoKTtcblxuICAgIH07XG5cbiAgICBQQ0EuY3JlYXRlRm9vdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjcmVhdGUgZm9vdGVyXG4gICAgICAgIHZhciBmb290ZXIsIHRlbXAsIHRlbXAyLCB0ZW1wMywgdGFibGVBcnJheSwgYXJyYXksIGFycmF5MiwgYXJyYXkzLCB0ciwgdGg7XG4gICAgICAgIHZhciBwY2FGb290ZXJUYWJsZUhlYWRlcnM7XG5cbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBjdW1WYXJUZXh0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIkN1bSAlIEV4cGxuIFZhclwiXTtcbiAgICAgICAgdmFyIHZhclRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiJSBleHBsYWluZWQgdmFyaWFuY2VcIl07XG4gICAgICAgIHZhciBlaWdlblRleHQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLkVpZ2VudmFsdWVzO1xuXG5cbiAgICAgICAgdGVtcCA9IFFBVi5nZXRTdGF0ZShcImVpZ2VuVmFsdWVzU29ydGVkXCIpO1xuICAgICAgICB0ZW1wLnVuc2hpZnQoXCJcIiwgZWlnZW5UZXh0KTtcbiAgICAgICAgYXJyYXkgPSB0ZW1wLnNsaWNlKDAsIDEwKTtcblxuICAgICAgICB0ZW1wMiA9IFFBVi5nZXRTdGF0ZShcImVpZ2VuVmFsdWVzQXNQZXJjZW50c1wiKTtcbiAgICAgICAgdGVtcDIudW5zaGlmdChcIlwiLCB2YXJUZXh0KTtcbiAgICAgICAgYXJyYXkyID0gdGVtcDIuc2xpY2UoMCwgMTApO1xuXG4gICAgICAgIHRlbXAzID0gUUFWLmdldFN0YXRlKFwiZWlnZW5WYWx1ZXNDdW11bFBlcmNlbnRBcnJheVwiKTtcbiAgICAgICAgdGVtcDMudW5zaGlmdChcIlwiLCBjdW1WYXJUZXh0KTtcbiAgICAgICAgYXJyYXkzID0gdGVtcDMuc2xpY2UoMCwgMTApO1xuXG5cbiAgICAgICAgdGFibGVBcnJheSA9IFtdO1xuICAgICAgICB0YWJsZUFycmF5LnB1c2goYXJyYXksIGFycmF5MiwgYXJyYXkzKTtcblxuICAgICAgICBwY2FGb290ZXJUYWJsZUhlYWRlcnMgPSBRQVYuZ2V0U3RhdGUoXCJwY2FUYWJsZUhlYWRlcnNcIik7XG4gICAgICAgIHBjYUZvb3RlclRhYmxlSGVhZGVyc1swXS50aXRsZSA9IFwiXCI7XG4gICAgICAgIHBjYUZvb3RlclRhYmxlSGVhZGVyc1swXS5zVGl0bGUgPSBcIlwiO1xuICAgICAgICBwY2FGb290ZXJUYWJsZUhlYWRlcnNbMV0udGl0bGUgPSBcIlwiO1xuICAgICAgICBwY2FGb290ZXJUYWJsZUhlYWRlcnNbMV0uc1RpdGxlID0gXCJcIjtcblxuXG4gICAgICAgIHZhciBjb25maWdPYmogPSB7fTtcbiAgICAgICAgY29uZmlnT2JqLmRvbUVsZW1lbnQgPSBcIiNmYWN0b3JSb3RhdGlvblRhYmxlMUZvb3RlclwiO1xuICAgICAgICBjb25maWdPYmouZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uZmlnT2JqLmRhdGEgPSB0YWJsZUFycmF5O1xuICAgICAgICBjb25maWdPYmoub3JkZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uZmlnT2JqLmhlYWRlcnMgPSBwY2FGb290ZXJUYWJsZUhlYWRlcnM7XG4gICAgICAgIGNvbmZpZ09iai5jb2xEZWZzID0gW3tcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiBbMCwgMV0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1jZW50ZXIgZHQtYm9keS1uYW1lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiBfLmNsb25lKFFBVi5wY2FUYWJsZVRhcmdldHMpLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2R0LWhlYWQtY2VudGVyIGR0LWJvZHktcmlnaHQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldHM6ICdfYWxsJyxcbiAgICAgICAgICAgICAgICBcImNyZWF0ZWRDZWxsXCI6IGZ1bmN0aW9uICh0ZCwgY2VsbERhdGEsIHJvd0RhdGEsIHJvdywgY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsRGF0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGQpLmNzcygnY29sb3InLCAncmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG5cbiAgICAgICAgVVRJTC5kcmF3RGF0YXRhYmxlKGNvbmZpZ09iaik7XG5cbiAgICB9O1xuXG59KHdpbmRvdy5QQ0EgPSB3aW5kb3cuUENBIHx8IHt9LCBRQVYpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9QQ0EuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gNyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=')}});