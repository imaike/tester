!function(g){function I(C){if(A[C])return A[C].exports;var t=A[C]={i:C,l:!1,exports:{}};return g[C].call(t.exports,t,t.exports,I),t.l=!0,t.exports}var A={};I.m=g,I.c=A,I.i=function(g){return g},I.d=function(g,A,C){I.o(g,A)||Object.defineProperty(g,A,{configurable:!1,enumerable:!0,get:C})},I.n=function(g){var A=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(A,"a",A),A},I.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},I.p="",I(I.s=8)}({8:function(module,exports){eval('// Ken-Q Analysis\n//Copyright (C) 2016 Shawn Banasick\n//\n//    This program is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, either version 3 of the License, or\n//    (at your option) any later version.\n\n// JSlint declarations\n/* global resources, d3, VIEW, d3_save_svg, CORR, alasql, window, QAV, $, document, evenRound, UTIL, _  */\n\n(function(OUTPUT, QAV, undefined) {\n    \'use strict\';\n    //     DOWNLOAD FUNCTIONS\n\n    // todo - bug fix escape codes for "\'" in statement listing\n    OUTPUT.generateOutput = function pushProjectHistoryToOutputArray() {\n        var sheetNames = [];\n        var output = [];\n\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation["Project Overview"];\n        var appendText2 = resources[language].translation.Undo;\n        var appendText3 = resources[language].translation["Analysis Completed on"];\n        var appendText4 = resources[language].translation["Total Number of Statements"];\n        var appendText5 = resources[language].translation["Q-sort Triangle Shape"];\n        var appendText6 = resources[language].translation["Total Number of Q-sorts"];\n        var appendText7 = resources[language].translation["Analysis Process"];\n        var appendText8 = resources[language].translation["Project name"];\n        var versionNum = resources[language].translation.versionNumber;\n\n        var newSheet = {\n            sheetid: appendText1,\n            headers: false\n        };\n        sheetNames.push(newSheet);\n\n        // no ala download data\n        var sheetNamesXlsx = [];\n        sheetNamesXlsx.push(appendText1);\n        var dataXlsx = [];\n\n        var settings = [];\n        var spacer = ["", ""];\n\n        var projectName = QAV.getState("qavProjectName");\n        var projectNameArray = [appendText8, projectName];\n        settings.push(spacer, projectNameArray, spacer);\n        dataXlsx.push(spacer, projectNameArray, spacer);\n\n        var totalStatements = QAV.getState("qavOriginalSortSize");\n        var totalNumberStatementsArray = [appendText4, totalStatements];\n        settings.push(totalNumberStatementsArray, spacer);\n        dataXlsx.push(totalNumberStatementsArray, spacer);\n\n        var sortTriangleShape = QAV.getState("qavSortTriangleShape");\n        var sortTriangleShape2 = sortTriangleShape.join();\n        var sortTriangleShapeArray = [appendText5, sortTriangleShape2];\n        settings.push(sortTriangleShapeArray, spacer);\n        dataXlsx.push(sortTriangleShapeArray, spacer);\n\n        var totalSorts = QAV.getState("qavTotalNumberSorts");\n        var totalSortsArray = [appendText6, totalSorts];\n        settings.push(totalSortsArray, spacer);\n        dataXlsx.push(totalSortsArray, spacer);\n\n        var list = document.getElementById("rotationHistoryList");\n        var items = list.childNodes;\n        var temp,\n            temp1,\n            temp2;\n\n        settings.push([appendText7, ""]);\n        dataXlsx.push([appendText7, ""]);\n\n        // pull list items and push to array for output\n        for (var i = 0; i < items.length; i++) {\n            var listArray1 = [];\n            temp = i + 1;\n            temp1 = items[i].textContent;\n            temp2 = temp1.replace(appendText2, "");\n            listArray1.push(temp, temp2);\n            settings.push(listArray1);\n            dataXlsx.push(listArray1);\n        }\n\n        var outputLanguage = QAV.getState("language");\n        settings.push(spacer, ["Language", outputLanguage]);\n        dataXlsx.push(spacer, ["Language", outputLanguage]);\n\n        var timeCompleted = UTIL.currentDate1() + " at " + UTIL.currentTime1();\n        settings.push(spacer, [\n            appendText3 + timeCompleted,\n            ""\n        ]);\n\n        dataXlsx.push(spacer, [\n            appendText3 + timeCompleted,\n            ""\n        ]);\n\n        settings.push(spacer, ["Version Number: ", versionNum]);\n        dataXlsx.push(spacer, ["Version Number: ", versionNum]);\n\n        var colSizes = [\n            [{\n                wch: 40\n            }, {\n                wch: 70\n            }]\n        ];\n\n        var outputData = [];\n        outputData.push(dataXlsx);\n\n        output.push(settings);\n        pushStatementsToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes);\n    };\n\n    function pushStatementsToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes) {\n        var statements = QAV.getState("qavCurrentStatements");\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation.Statements;\n        var appendText2 = resources[language].translation["Statement Number"];\n\n        var newSheet = {\n            sheetid: appendText1,\n            header: true\n        };\n        sheetNamesXlsx.push(appendText1);\n\n        var maxStatementLength = 0;\n        var arrayOfStatements = [];\n        arrayOfStatements.push([\n            "", ""\n        ], [appendText2, appendText1]);\n        for (var ii = 0, iiLen = statements.length; ii < iiLen; ii++) {\n            var tempArray1 = [];\n            tempArray1.push((ii + 1), statements[ii]);\n            arrayOfStatements.push(tempArray1);\n            var stringLength = statements[ii].length;\n            if (stringLength > maxStatementLength) {\n                maxStatementLength = stringLength;\n            }\n        }\n        outputData.push(arrayOfStatements);\n\n        var columns = [{\n            wch: 10\n        }, {\n            wch: maxStatementLength\n        }];\n        colSizes.push(columns);\n        QAV.setState("maxStatementLength", maxStatementLength);\n\n        pushSortsToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushSortsToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes) {\n\n        var language = QAV.getState("language");\n        var appendText2 = resources[language].translation.Respondent;\n        var appendText3 = resources[language].translation.Mean;\n        var appendText4 = resources[language].translation["Standard Deviation"];\n        var appendText6 = resources[language].translation["Q-sorts"];\n\n        sheetNamesXlsx.push(appendText6);\n\n        var sortsAsNumbers = QAV.getState("sortsAsNumbers");\n        var respondentNames = QAV.getState("qavRespondentNames");\n        var dataArray = [];\n\n        // set up column widths\n        var columns = [{\n            wch: 15\n        }];\n        for (var ii = 0, iiLen = sortsAsNumbers[0].length + 2; ii < iiLen; ii++) {\n            columns.push({\n                wch: 5\n            });\n        }\n        colSizes.push(columns);\n\n        var stddev,\n            statementSort;\n        // create sheet header\n        var headerArray = [appendText2];\n        for (var jj = 0, jjLen = sortsAsNumbers[0].length; jj < jjLen; jj++) {\n            statementSort = "S" + (jj + 1);\n            headerArray.push(statementSort);\n        }\n        headerArray.push(appendText3, appendText4);\n        dataArray.push([\n            "", ""\n        ], [\n            appendText6, ""\n        ], [\n            "", ""\n        ], headerArray);\n\n        // push in sorts, means, and standard devs\n        for (var kk = 0, kkLen = sortsAsNumbers.length; kk < kkLen; kk++) {\n            var average3 = evenRound((UTIL.average(sortsAsNumbers[kk])), 3);\n            stddev = evenRound((UTIL.standardDeviation(sortsAsNumbers[kk])), 3);\n            sortsAsNumbers[kk].unshift(respondentNames[kk]);\n            sortsAsNumbers[kk].push(average3, stddev);\n            dataArray.push(sortsAsNumbers[kk]);\n        }\n        outputData.push(dataArray);\n\n        QAV.setState("freeDistributionArray", dataArray);\n\n        pushCorrelationArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushCorrelationArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes) {\n\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation["Correlation matrix"];\n        var appendText2 = resources[language].translation["between Q-sorts"];\n\n        sheetNamesXlsx.push(appendText1);\n\n        var correlationTableArrayFormatted3 = QAV.getState("correlationTableArrayFormatted");\n\n        // get max respondent name length\n        var respondentNameMaxLength = 0;\n        for (var i = 0, iLen = correlationTableArrayFormatted3[0].length; i < iLen; i++) {\n            var temp1 = correlationTableArrayFormatted3[0][i].length;\n            if (temp1 > respondentNameMaxLength) {\n                respondentNameMaxLength = temp1;\n            }\n        }\n        if (respondentNameMaxLength < 5) {\n            respondentNameMaxLength = 5;\n        }\n\n        // set up column spacing\n        var columns = [];\n        for (var j = 0, jLen = (correlationTableArrayFormatted3[0].length + 1); j < jLen; j++) {\n            columns.push({\n                wch: respondentNameMaxLength\n            });\n        }\n        colSizes.push(columns);\n\n        correlationTableArrayFormatted3.unshift([\n            "", ""\n        ], [appendText1 + appendText2], ["", ""]);\n        outputData.push(correlationTableArrayFormatted3);\n\n        pushUnrotatedFactorsTableToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushUnrotatedFactorsTableToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes) {\n        var factorMatrixTransposed, i, j, k, m, temp, tempA, temp1, temp2, temp2A;\n        var newSheet, expVar, centroidsArray, tempObj, respondentNames, typeOfFactor, numFactorsExtracted;\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation["Unrotated Factor Matrix"];\n        var appendText2 = resources[language].translation.Eigenvalues;\n        var appendText3 = resources[language].translation.Factor;\n        var appendText4 = resources[language].translation.Respondent;\n\n        respondentNames = QAV.respondentNames;\n        factorMatrixTransposed = QAV.getState("eigenVecs");\n        temp = QAV.getState("eigenValuesSorted");\n        temp2 = QAV.getState("eigenValuesAsPercents");\n        temp1 = QAV.getState("factorLabels");\n        expVar = QAV.getState("expVarCentroid");\n        numFactorsExtracted = QAV.getState("numFactorsExtracted");\n        typeOfFactor = QAV.getState("typeOfFactor");\n\n        sheetNamesXlsx.push(appendText1);\n\n        // set excel column widths\n        var columns = [{\n            wch: 20\n        }];\n        for (var iii = 0, iiiLen = temp1.length; iii < iiLen; iii++) {\n            columns.push({\n                wch: 8\n            });\n        }\n        colSizes.push(columns);\n\n        // add labels to Unrotated factor data\n        if (typeOfFactor === "PCA") {\n\n            temp2 = temp2.slice(0, numFactorsExtracted);\n            temp = temp.slice(0, numFactorsExtracted);\n\n            // conform PCA to legacy centroid data structure\n            for (m = 0; m < (respondentNames.length - 1); m++) {\n                factorMatrixTransposed[m].unshift(respondentNames[m + 1]);\n            }\n            temp1.unshift("");\n            factorMatrixTransposed.unshift(temp1);\n\n            // add eigenvals to match data structure\n            temp.unshift(appendText2);\n            factorMatrixTransposed.push([], temp);\n            temp2.unshift("");\n            factorMatrixTransposed.push(temp2);\n        } else {\n            factorMatrixTransposed = QAV.getState("factorMatrixTransposed");\n            factorMatrixTransposed.push(expVar);\n        }\n\n        // change after deleting alasql code\n        var unrotatedFactors = _.cloneDeep(factorMatrixTransposed);\n        unrotatedFactors[0][0] = (appendText4);\n\n        for (var ii = 1, iiLen = unrotatedFactors.length - 1; ii < iiLen; ii++) {\n            for (var jj = 1, jjLen = unrotatedFactors[ii].length; jj < jjLen; jj++) {\n                unrotatedFactors[ii][jj] = evenRound(unrotatedFactors[ii][jj], 4);\n            }\n        }\n        unrotatedFactors.unshift([\n            "", ""\n        ], [appendText1], ["", ""]);\n        outputData.push(unrotatedFactors);\n\n        pushCumulativeCommunalitiesMaxtrixToOutputArray(sheetNames, output, factorMatrixTransposed, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushCumulativeCommunalitiesMaxtrixToOutputArray(sheetNames, output, factorMatrixTransposed, outputData, sheetNamesXlsx, colSizes) {\n        var newSheet, cumulCommMatrix9, explnVarRow, responderHeadersRow;\n        var i, j, k, temp1, temp2, respondentName;\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation["Cumul Comm Matrix"];\n        var appendText2 = resources[language].translation["cumulative % explained variance"];\n        var appendText4 = resources[language].translation.Respondent;\n        var appendText5 = resources[language].translation["Cumulative Communalities Matrix"];\n\n        sheetNamesXlsx.push(appendText1);\n\n        // isolate data\n        cumulCommMatrix9 = _.cloneDeep(factorMatrixTransposed);\n\n        // set excel column widths\n        var columns = [{\n            wch: 30\n        }];\n        for (var ii = 0, iiLen = cumulCommMatrix9[0].length; ii < iiLen; ii++) {\n            columns.push({\n                wch: 8\n            });\n        }\n        colSizes.push(columns);\n\n        explnVarRow = cumulCommMatrix9.pop();\n        // get rid of eigenvalue row\n        cumulCommMatrix9.pop();\n        responderHeadersRow = cumulCommMatrix9.shift();\n        // add respondent names and do rounding\n        for (i = 0; i < cumulCommMatrix9.length; i++) {\n            respondentName = cumulCommMatrix9[i].shift();\n            for (j = 0; j < cumulCommMatrix9[i].length; j++) {\n                if (j === 0) {\n                    temp1 = cumulCommMatrix9[i][j];\n                    cumulCommMatrix9[i][j] = evenRound((temp1 * temp1), 4);\n                } else {\n                    temp1 = cumulCommMatrix9[i][j];\n                    cumulCommMatrix9[i][j] = evenRound(((temp1 * temp1) + cumulCommMatrix9[i][(j - 1)]), 4);\n                }\n            }\n            cumulCommMatrix9[i].unshift(respondentName);\n        }\n        cumulCommMatrix9.unshift(responderHeadersRow);\n        // add cumulative explained variance\n        explnVarRow.shift();\n        for (k = 0; k < explnVarRow.length; k++) {\n            if (k === 0) {} else {\n                temp2 = explnVarRow[k];\n                explnVarRow[k] = explnVarRow[k] + explnVarRow[(k - 1)];\n            }\n        }\n        explnVarRow.unshift(appendText2);\n        cumulCommMatrix9.push(explnVarRow);\n        output.push(cumulCommMatrix9);\n        // format for excel\n        cumulCommMatrix9[0][0] = appendText4;\n        cumulCommMatrix9.unshift([\n            "", ""\n        ], [appendText5], ["", ""]);\n        outputData.push(cumulCommMatrix9);\n\n        pushRotatedFactorsArrayToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    //  AKA factor loadings table\n    function pushRotatedFactorsArrayToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes) {\n        var results = QAV.getState("results");\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation.Loadings;\n        var appendText2 = resources[language].translation.Flagged;\n        var appendText3 = resources[language].translation["Factor Matrix with Defining Sorts Flagged"];\n\n        sheetNamesXlsx.push(appendText1);\n\n        var formattedResults = [];\n        var jLoopLen = results[0].length;\n        var i, j;\n        var iLoopLen = results.length;\n        var temp;\n        var tempArray = [];\n\n        var headerRowFromCurrentTable = $(\'#factorRotationTable2 thead tr\')[0];\n        $.each(headerRowFromCurrentTable.cells, function(i, v) {\n            var temp5 = v.textContent;\n            tempArray.push(temp5);\n        });\n        formattedResults.push(tempArray);\n\n        // resort the array\n        results.sort(function(a, b) {\n            return a[0] - b[0];\n        });\n\n        for (i = 0; i < iLoopLen; i++) {\n            for (j = 0; j < jLoopLen; j++) {\n                temp = results[i][j];\n                if (temp === "true") {\n                    results[i][j] = appendText2;\n                } else if (temp === "false") {\n                    results[i][j] = "";\n                } else if (j !== 0 && !isNaN(temp)) {\n                    results[i][j] = evenRound((temp), 4);\n                }\n            }\n            formattedResults.push(results[i]);\n        }\n        var expVar = QAV.getState("expVar");\n        formattedResults.push(expVar);\n\n        // set excel column widths\n        var columns = [{\n            wch: 20\n        }];\n        for (var ii = 0, iiLen = formattedResults[0].length; ii < iiLen; ii++) {\n            columns.push({\n                wch: 8\n            });\n        }\n        colSizes.push(columns);\n\n        output.push(formattedResults);\n\n        formattedResults.unshift([\n            "", ""\n        ], [appendText3], ["", ""]);\n        outputData.push(formattedResults);\n        pushFreeDistributionDataToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushFreeDistributionDataToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes) {\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation["Free Dist"];\n        var appendText2 = resources[language].translation.Respondent;\n        var appendText3 = resources[language].translation.Mean;\n        var appendText4 = resources[language].translation["Standard Deviation"];\n        var appendText5 = resources[language].translation["Free Distribution Data Results"];\n        var qavCurrentStatements = QAV.getState("qavCurrentStatements");\n\n        var newSheet = {\n            sheetid: appendText1,\n            headers: false\n        };\n        sheetNames.push(newSheet);\n        sheetNamesXlsx.push(appendText1);\n\n        var columns = [{\n            wch: 20\n        }, {\n            wch: 10\n        }, {\n            wch: 10\n        }];\n        colSizes.push(columns);\n\n        var freeDistributionArray = QAV.getState("freeDistributionArray");\n\n        freeDistributionArray = freeDistributionArray.slice(3);\n        var freeDistributionData = [];\n        var cutLength = freeDistributionArray[0].length - 3;\n        for (var i = 0, iLen = freeDistributionArray.length; i < iLen; i++) {\n            var tempCut = freeDistributionArray[i].splice(1, cutLength);\n            freeDistributionData.push(freeDistributionArray[i]);\n        }\n        freeDistributionData.unshift(["", ""], [appendText5], ["", ""]);\n        outputData.push(freeDistributionData);\n        pushFactorsToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushFactorsToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes) {\n\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation["Sorts Weight"];\n        var appendText2 = resources[language].translation["Sorts Corr"];\n        var appendText3 = resources[language].translation["Statement Number"];\n        var appendText4 = resources[language].translation.Statement;\n        var appendText5 = resources[language].translation["Z-score"];\n        var appendText6 = resources[language].translation["Sort Values"];\n\n        var analysisOutput2 = QAV.getState("analysisOutput");\n        var analysisOutput = _.cloneDeep(analysisOutput2);\n        var sigSortsArray = QAV.getState("sigSortsArray");\n        var sortsAsNumbers = QAV.getState("sortsAsNumbers");\n        var qavRespondentNames = QAV.getState("qavRespondentNames");\n        var correlationTableArrayFormatted2 = QAV.getState("correlationTableArrayFormatted");\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n        var sortWeights = QAV.getState("sortWeights");\n\n        // to hold data in QAV until later insertion into output results - to match PQMethod order\n        var factorWeightFactorArrayHolder = [];\n        var miniCorrelationArrayHolder = [];\n        var synFactorArray1Holder = [];\n        var synFactorArray1 = [];\n        var sheetNamesHolder1 = [];\n        var sheetNamesHolder2 = [];\n        var sheetNamesHolder3 = [];\n\n        for (var i = 0; i < analysisOutput.length; i++) {\n            var temp1 = {};\n            var temp1a = {};\n            var temp1b = {};\n\n            temp1a.sheetid = sigSortsArray[i]["Factor Number"] + appendText1;\n            temp1a.header = true;\n            sheetNamesHolder1.push(temp1a);\n\n            temp1b.sheetid = sigSortsArray[i]["Factor Number"] + appendText2;\n            temp1b.header = true;\n            sheetNamesHolder2.push(temp1b);\n\n            temp1.sheetid = sigSortsArray[i]["Factor Number"];\n            temp1.header = true;\n            sheetNamesHolder3.push(temp1);\n        }\n\n        QAV.setState("sheetNamesHolder1", sheetNamesHolder1);\n        QAV.setState("sheetNamesHolder2", sheetNamesHolder2);\n        QAV.setState("sheetNamesHolder3", sheetNamesHolder3);\n\n        // pull raw sorts for factor tables\n        var rawSorts = [];\n        for (var p = 0; p < sigSortsArray.length; p++) {\n            var tempArray = [];\n            for (var r = 0; r < sigSortsArray[p].SigSorts.length; r++) {\n                var sigSort = sigSortsArray[p].SigSorts[r];\n                var rawSortIndex = qavRespondentNames.indexOf(sigSort);\n                var rawSortValues = sortsAsNumbers[rawSortIndex];\n                tempArray.push(rawSortValues);\n            }\n            rawSorts.push(tempArray);\n        }\n\n        // for each factor check get a sigSort (if another remains)\n        // get the raw sort for that specific sigSort\n        // read that sigSorts raw sort data into testObj\n        var compositeFactorMasterArray = [];\n        var matchCount = [];\n        //  FOR EACH FACTOR LOOP\n        for (var j = 0; j < analysisOutput.length; j++) {\n\n            // FACTOR WEIGHTS TABLES STARTS FROM HERE\n            var factorWeightFactorArray = [\n                ["Q-Sort", "Weight"]\n            ];\n            var factorWeightName = userSelectedFactors[j];\n            for (var w = 0; w < sortWeights.length; w++) {\n                var factorWeightTempArray = [];\n                if (sortWeights[w][0] === factorWeightName) {\n                    factorWeightTempArray.push(sortWeights[w][1], sortWeights[w][3]);\n                    factorWeightFactorArray.push(factorWeightTempArray);\n                }\n            }\n            // output.push(factorWeightFactorArray);\n            factorWeightFactorArrayHolder.push(factorWeightFactorArray);\n\n\n            // FACTOR SCORE MINI CORRELATION TABLES STARTS FROM HERE\n\n            // loop through sigSortsArray to get this factor\'s sig Sorts\n            var miniSortsID = userSelectedFactors[j];\n            var miniCorrelationFactorsArray = [];\n            for (var t = 0; t < sigSortsArray.length; t++) {\n                if (sigSortsArray[t]["Factor Number"] === miniSortsID) {\n                    miniCorrelationFactorsArray.push(sigSortsArray[t].SigSorts);\n                }\n            }\n\n            // pull correlations from table\n            var miniCorrelationArray = [];\n            var miniCorrelationHeaderArray = ["Q-Sort"];\n            var miniCorrelationHeaderIndex = correlationTableArrayFormatted2[0];\n\n            // loop through all sig Sorts\n            for (var t3 = 0; t3 < miniCorrelationFactorsArray[0].length; t3++) {\n\n                miniCorrelationHeaderArray.push(miniCorrelationFactorsArray[0][t3]);\n\n                // loop through correlation table array\n                for (var t1 = 0; t1 < correlationTableArrayFormatted2.length; t1++) {\n\n                    var tempArrayT1 = [];\n\n                    // find row for  the sig sorts, then push data\n                    if (correlationTableArrayFormatted2[t1][0] === miniCorrelationFactorsArray[0][t3]) {\n\n                        // push name into left column\n                        tempArrayT1.push(miniCorrelationFactorsArray[0][t3]);\n\n                        // cycle through row to find push data for all sigSorts\n                        for (var t2 = 0; t2 < miniCorrelationFactorsArray[0].length; t2++) {\n                            var index = miniCorrelationHeaderIndex.indexOf(miniCorrelationFactorsArray[0][t2]);\n                            tempArrayT1.push(correlationTableArrayFormatted2[t1][index]);\n                        }\n                        miniCorrelationArray.push(tempArrayT1);\n                    }\n\n                }\n            }\n            miniCorrelationArray.unshift(miniCorrelationHeaderArray);\n\n            // output.push(miniCorrelationArray);\n            miniCorrelationArrayHolder.push(miniCorrelationArray);\n\n            // SYNTHETIC FACTOR OUTPUT STARTS FROM HERE\n            // convert arrays to object\n            var synFactorArray = [];\n            var matchCountArray = [];\n            var compositeFactorArray = [];\n\n            // simul calc two md arrays - one for tables, one for match counts\n            for (var m = 0, mLen = analysisOutput[0].length; m < mLen; m++) {\n                // initialize and empty temp objs and arrays\n                var tempObj = {};\n                var tempObj5 = {};\n                var matchSortValue = [];\n                var matchingCounter = 0;\n                var compositeFactorTempArray = [];\n\n                tempObj5.indexer = analysisOutput[j][m].statement;\n                tempObj5.matchSortValue = analysisOutput[j][m].sortValue;\n                tempObj5.zScore = analysisOutput[j][m].zScore;\n                var testValue = analysisOutput[j][m].sortValue;\n\n                tempObj[appendText3] = analysisOutput[j][m].statement;\n                tempObj[appendText4] = analysisOutput[j][m].sortStatement;\n                tempObj[appendText5] = analysisOutput[j][m].zScore;\n                tempObj[appendText6] = analysisOutput[j][m].sortValue;\n\n                // set up new output array\n                compositeFactorTempArray.push(analysisOutput[j][m].statement, analysisOutput[j][m].sortStatement, analysisOutput[j][m].zScore, analysisOutput[j][m].sortValue);\n\n                for (var s = 0, sLen = rawSorts[j].length; s < sLen; s++) {\n                    tempObj["Raw Sort " + sigSortsArray[j].SigSorts[s]] = rawSorts[j][s][m];\n                    // add to new output array\n                    compositeFactorTempArray.push(rawSorts[j][s][m]);\n                    // matchSortValue.push(rawSorts[j][s][m]);\n                    if (testValue === rawSorts[j][s][m]) {\n                        matchingCounter++;\n                    }\n                } // pushing in raw sort vals\n                tempObj5.matchingCounts = matchingCounter;\n                tempObj5.matchingCountsPercent = parseInt((matchingCounter / sLen * 100), 10);\n                // tempObj5.matchSortValue = matchSortValue;\n                matchCountArray.push(tempObj5);\n                synFactorArray.push(tempObj);\n                // add to new output array\n                compositeFactorArray.push(compositeFactorTempArray);\n            } // pushing in q-sort loadings\n            // add to new output Master array\n            compositeFactorMasterArray.push(compositeFactorArray);\n            matchCount.push(matchCountArray); // push in factor arrays\n            synFactorArray1 = synFactorArray.slice(0);\n\n            synFactorArray1.sort(function(a, b) {\n                if (b[appendText5] === a[appendText5]) {\n                    return b[appendText3] - a[appendText3];\n                } else {\n                    return b[appendText5] - a[appendText5];\n                }\n            });\n\n            // output.push(synFactorArray1);\n            synFactorArray1Holder.push(synFactorArray1);\n        }\n\n        QAV.setState("factorWeightFactorArrayHolder", factorWeightFactorArrayHolder);\n        QAV.setState("miniCorrelationArrayHolder", miniCorrelationArrayHolder);\n        QAV.setState("synFactorArray1Holder", synFactorArray1Holder);\n        QAV.setState("matchCount", matchCount);\n        QAV.setState("compositeFactorMasterArray", compositeFactorMasterArray);\n\n        pushFactorScoreComparisonRanksTableToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushFactorScoreComparisonRanksTableToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes) {\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation["Factor Score Ranks"];\n        var appendText2 = resources[language].translation.Factors;\n        var appendText3 = resources[language].translation["Statement Number"];\n        var appendText4 = resources[language].translation.Statement;\n        var appendText5 = resources[language].translation["Z-score"];\n        var appendText6 = resources[language].translation["Factor Scores with Corresponding Ranks"];\n        var appendText7 = resources[language].translation.Rank;\n        var appendText8 = resources[language].translation["Sort Values"];\n\n        var synFactorArray1 = QAV.getState("synFactorArray1Holder");\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n        var tempArray1,\n            rankValue,\n            rankingTempArray;\n        var statementRankingArray = [];\n\n        // var newSheet = {\n        //     sheetid: appendText1,\n        //     headers: false\n        // };\n        // sheetNames.push(newSheet);\n        sheetNamesXlsx.push(appendText1);\n\n        var maxStatementLength = QAV.getState("maxStatementLength");\n        var columns = [{\n            wch: 8\n        }, {\n            wch: maxStatementLength\n        }, {\n            wch: 8\n        }];\n        for (var ss = 0, ssLen = (userSelectedFactors.length * 2); ss < ssLen; ss++) {\n            columns.push({\n                wch: 7\n            });\n        }\n        colSizes.push(columns);\n\n\n        // add factor ranks and round at 2 digits\n        for (var j = 0, jLen = synFactorArray1.length; j < jLen; j++) {\n            for (var jj = 0, jjLen = synFactorArray1[j].length; jj < jjLen; jj++) {\n                synFactorArray1[j][jj][appendText5] = evenRound((synFactorArray1[j][jj][appendText5]), 2);\n            }\n            synFactorArray1[j]\n                .sort(function(a, b) {\n                    if (b[appendText5] === a[appendText5]) {\n                        return a[appendText3] - b[appendText3];\n                    } else {\n                        return b[appendText5] - a[appendText5];\n                    }\n                });\n\n            for (var i = 0, iLen = synFactorArray1[j].length; i < iLen; i++) {\n                rankValue = (i + 1);\n                synFactorArray1[j][i].Rank = rankValue;\n            }\n\n            synFactorArray1[j]\n                .sort(function(a, b) {\n                    return a[appendText3] - b[appendText3];\n                });\n        }\n\n        // re-sort for use below?\n        // synFactorArray1[0]\n        //     .sort(function(a, b) {\n        //         return a[appendText3] - b[appendText3];\n        //     });\n\n        var compositeFactorMasterArray = QAV.getState("compositeFactorMasterArray");\n        var factorScoreRanksArray = [];\n\n        // sort by statement number and push num and statement and num into ranks array\n        compositeFactorMasterArray[0].sort(function(a, b) {\n            if (a[0] === b[0]) {\n                return 0;\n            } else {\n                return (a[0] < b[0]) ?\n                    -1 :\n                    1;\n            }\n        });\n        for (var ww = 0, wwLen = compositeFactorMasterArray[0].length; ww < wwLen; ww++) {\n            var tempArraymm1 = [];\n            tempArraymm1.push(compositeFactorMasterArray[0][ww][0]);\n            tempArraymm1.push(compositeFactorMasterArray[0][ww][1]);\n            tempArraymm1.push(compositeFactorMasterArray[0][ww][0]);\n            factorScoreRanksArray.push(tempArraymm1);\n        }\n\n        // cycle through user selected factors to get zScore and rank\n        for (var kk = 0, kkLen = compositeFactorMasterArray.length; kk < kkLen; kk++) {\n            // sort by statement number\n            compositeFactorMasterArray[kk]\n                .sort(function(a, b) {\n                    if (a[0] === b[0]) {\n                        return 0;\n                    } else {\n                        return (a[0] < b[0]) ?\n                            -1 :\n                            1;\n                    }\n                });\n            // insert zScore\n            for (var ii = 0, iiLen = compositeFactorMasterArray[kk].length; ii < iiLen; ii++) {\n                var tempZscore = evenRound(compositeFactorMasterArray[kk][ii][2], 2);\n                factorScoreRanksArray[ii].push(tempZscore);\n            }\n            // re-sort by latest pushed zScore\n            // var placeSetter = factorScoreRanksArray[0].length - 1;\n            var placeSetter = 2;\n            compositeFactorMasterArray[kk].sort(function(a, b) {\n                if (a[placeSetter] === b[placeSetter]) {\n                    return 0;\n                } else {\n                    return (b[placeSetter] < a[placeSetter]) ?\n                        -1 :\n                        1;\n                }\n            });\n\n            for (var rr = 0, rrLen = compositeFactorMasterArray[kk].length; rr < rrLen; rr++) {\n                var RankValue2 = (rr + 1);\n                compositeFactorMasterArray[kk][rr].push(RankValue2);\n            }\n\n            // re-sort to statement number\n            compositeFactorMasterArray[kk]\n                .sort(function(a, b) {\n                    if (a[0] === b[0]) {\n                        return 0;\n                    } else {\n                        return (a[0] < b[0]) ?\n                            -1 :\n                            1;\n                    }\n                });\n\n            // get and push ranking numbers\n            for (var pp = 0, ppLen = compositeFactorMasterArray[kk].length; pp < ppLen; pp++) {\n                var RankValue3 = compositeFactorMasterArray[kk][pp].pop();\n                factorScoreRanksArray[pp].push(RankValue3);\n            }\n            // placeSetter = placeSetter + 2;\n        }\n\n        var spacer = ["", ""];\n        var tempArrayHeader = ["", appendText6];\n        var tempArrayHeader2 = [appendText3, appendText4, appendText3];\n        var tempSubHeader = ["", "", ""];\n        for (var yy = 0, yyLen = userSelectedFactors.length; yy < yyLen; yy++) {\n            tempArrayHeader2.push(userSelectedFactors[yy], userSelectedFactors[yy]);\n            tempSubHeader.push("Z-score", "Rank");\n        }\n\n        factorScoreRanksArray.unshift(spacer, tempArrayHeader, spacer, tempArrayHeader2, tempSubHeader);\n        outputData.push(factorScoreRanksArray);\n\n        // setup the array of ranked statements\n        var factorScoreComparisonArray = [];\n        for (var k = 0, kLen = synFactorArray1[0].length; k < kLen; k++) {\n            rankingTempArray = [];\n            tempArray1 = {};\n            tempArray1.Num1 = synFactorArray1[0][k][appendText3];\n            tempArray1.Statement = synFactorArray1[0][k][appendText4];\n            tempArray1.Num2 = synFactorArray1[0][k][appendText3];\n            tempArray1.Zscore1 = synFactorArray1[0][k][appendText5];\n            var rank1 = synFactorArray1[0][k][appendText7];\n            tempArray1.Rank1 = rank1;\n            var tempSortValue = synFactorArray1[0][k][appendText8];\n            rankingTempArray.push(tempSortValue);\n            for (var m = 1, mLen = synFactorArray1.length; m < mLen; m++) {\n                var mm = m + 1;\n                tempArray1["Zscore" + mm] = synFactorArray1[m][k][appendText5];\n                tempArray1["Rank" + mm] = synFactorArray1[m][k][appendText7];\n                var tempSortValue2 = synFactorArray1[m][k][appendText8];\n                rankingTempArray.push(tempSortValue2);\n            }\n            factorScoreComparisonArray.push(tempArray1);\n            statementRankingArray.push(rankingTempArray);\n        }\n\n        QAV.setState("statementRankingArray", statementRankingArray);\n\n        pushFactorScoreCorrelationsToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushFactorScoreCorrelationsToOutputArray(sheetNames, output, outputData, sheetNamesXlsx, colSizes) {\n\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation["Factor score correlations"];\n\n        sheetNamesXlsx.push(appendText1);\n\n        var analysisOutput = QAV.getState("analysisOutput");\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n        var analysisOutput2 = _.cloneDeep(analysisOutput);\n        var factorScoresCorrelationArray2 = [];\n        var temp1, temp2, tempArray;\n\n        var columns = [{\n            wch: 7\n        }];\n        for (var ss = 0, ssLen = (userSelectedFactors.length); ss < ssLen; ss++) {\n            columns.push({\n                wch: 7\n            });\n        }\n        colSizes.push(columns);\n\n        // i loop through selected factors, j loop through sorts to get new array of z-scores\n        // todo - added after other calculations, so now repeats with factor download sheets - dry out\n        for (var i = 0; i < userSelectedFactors.length; i++) {\n            temp2 = userSelectedFactors[i];\n            tempArray = [];\n            for (var j = 0; j < analysisOutput2[i].length; j++) {\n                temp1 = analysisOutput2[i][j].zScore;\n                tempArray.push(temp1);\n            }\n            factorScoresCorrelationArray2.push(tempArray);\n        }\n\n        // todo - converting to integer gives lots variation with PQmethod - use evenRound?\n        var factorScoresCorrelationArray = [];\n        for (var q = 0; q < factorScoresCorrelationArray2.length; q++) {\n            var temp11 = _.map(factorScoresCorrelationArray2[q], evenRoundFunc);\n            factorScoresCorrelationArray.push(temp11);\n        }\n\n        function evenRoundFunc(n) {\n            var temp1 = evenRound((n), 5);\n            return temp1;\n        }\n\n        var pullX;\n        var correlationTableArrayFragment = [];\n        var correlationTableArray = [];\n        for (var k = 0; k < factorScoresCorrelationArray.length; k++) {\n            pullX = factorScoresCorrelationArray[k];\n            correlationTableArrayFragment = factorScoresCorrelationsHelper(factorScoresCorrelationArray, pullX);\n            correlationTableArray.push(correlationTableArrayFragment);\n            correlationTableArrayFragment = [];\n        }\n\n        function factorScoresCorrelationsHelper(factorScoresCorrelationArray, pullX) {\n\n            var correlationHolder,\n                correlationHolder2;\n            var correlationTableArrayFragment = [];\n\n            _(factorScoresCorrelationArray).forEach(function(element) {\n                correlationHolder2 = CORR.getPqmethodCorrelation(pullX, element);\n                correlationHolder = evenRound((correlationHolder2[0]), 4);\n                correlationTableArrayFragment.push(correlationHolder);\n            }).value();\n            return correlationTableArrayFragment;\n        }\n\n        // add factor names to first column\n        for (var m = 0; m < correlationTableArray.length; m++) {\n            var temp8 = userSelectedFactors[m];\n            correlationTableArray[m].unshift(temp8);\n        }\n\n        var tempArray3 = [];\n        tempArray3.push("");\n        for (var p = 0; p < userSelectedFactors.length; p++) {\n            var temp9 = userSelectedFactors[p];\n            tempArray3.push(temp9);\n        }\n        correlationTableArray.unshift(tempArray3);\n\n        QAV.setState("correlationTableArrayHolder", correlationTableArray);\n        output.push(correlationTableArray);\n\n        //var correlationTableArray2 = _.cloneDeep(correlationTableArray);\n        correlationTableArray.unshift([\n            "", ""\n        ], [appendText1], ["", ""]);\n\n        outputData.push(correlationTableArray);\n\n        // pushFactorsToOutputArray(sheetNames, output);\n        insertFactorsIntoOutputArray(sheetNames, output, analysisOutput, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function insertFactorsIntoOutputArray(sheetNames, output, analysisOutput, outputData, sheetNamesXlsx, colSizes) {\n\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation["Sorts Weight"];\n        var appendText2 = resources[language].translation["Sorts Corr"];\n        var appendText3 = resources[language].translation["Statement Number"];\n        var appendText4 = resources[language].translation.Statement;\n        var appendText5 = resources[language].translation["Z-score"];\n        // var appendText6 = resources[language].translation["Sort Values"];\n        var appendText7 = resources[language].translation["Raw Sort"];\n        var appendText8 = resources[language].translation["Sort Values"];\n        var appendText9 = resources[language].translation["Sorts Correlations"];\n        var appendText10 = resources[language].translation["Factor Scores for "];\n\n        var sheetNamesHolder1 = QAV.getState("sheetNamesHolder1");\n        var sheetNamesHolder2 = QAV.getState("sheetNamesHolder2");\n        var sheetNamesHolder3 = QAV.getState("sheetNamesHolder3");\n\n        var factorWeightFactorArray = QAV.getState("factorWeightFactorArrayHolder");\n        var miniCorrelationArray = QAV.getState("miniCorrelationArrayHolder");\n        var synFactorArray1 = QAV.getState("synFactorArray1Holder");\n        var compositeFactorMasterArray = QAV.getState("compositeFactorMasterArray");\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n        var sigSortsArray = QAV.getState("sigSortsArray");\n        var maxStatementLength = QAV.getState("maxStatementLength");\n        var spacer = ["", ""];\n\n        for (var ii = 0, iiLen = userSelectedFactors.length; ii < iiLen; ii++) {\n\n            var sheetHeaderArrayPartial = [appendText3, appendText4, appendText5, appendText8];\n\n            // set weights name\n            sheetNamesXlsx.push((sheetNamesHolder1[ii].sheetid));\n\n            // set weights columns\n            var columns = [{\n                wch: 8\n            }, {\n                wch: 8\n            }];\n            colSizes.push(columns);\n\n            // set weights sheet\n            factorWeightFactorArray[ii].unshift(spacer, [userSelectedFactors[ii], appendText1], spacer);\n            outputData.push(factorWeightFactorArray[ii]);\n\n            // set sorts corr name\n            sheetNamesXlsx.push((sheetNamesHolder2[ii].sheetid));\n\n            // set sorts corr cols\n            var columns2 = [{\n                wch: 8\n            }];\n            for (var ss = 0, ssLen = (userSelectedFactors.length); ss < ssLen; ss++) {\n                columns2.push({\n                    wch: 8\n                });\n            }\n            colSizes.push(columns2);\n\n            // set sorts corr sheet\n            miniCorrelationArray[ii].unshift(spacer, [userSelectedFactors[ii], appendText9], spacer);\n            outputData.push(miniCorrelationArray[ii]);\n\n            // set factor sheet name\n            sheetNamesXlsx.push((sheetNamesHolder3[ii].sheetid));\n\n            // set factor sheet cols\n            var columns3 = [{\n                wch: 8\n            }, {\n                wch: maxStatementLength\n            }, {\n                wch: 9\n            }, {\n                wch: 12\n            }];\n            for (var tt = 0, ttLen = sigSortsArray[ii].SigSorts.length; tt < ttLen; tt++) {\n                columns3.push({\n                    wch: 12\n                });\n            }\n            colSizes.push(columns3);\n\n            // set factor sheets\n            // re-sort to zScore\n            compositeFactorMasterArray[ii].sort(function(a, b) {\n                if (a[2] === b[2]) {\n                    return (a[0] < b[0]) ?\n                        -1 :\n                        1;\n                } else {\n                    return (b[2] < a[2]) ?\n                        -1 :\n                        1;\n                }\n            });\n\n            for (var jj = 0, jjLen = sigSortsArray[ii].SigSorts.length; jj < jjLen; jj++) {\n                sheetHeaderArrayPartial.push(appendText7 + " " + sigSortsArray[ii].SigSorts[jj]);\n            }\n            compositeFactorMasterArray[ii].unshift(spacer, ["", appendText10 + " " + userSelectedFactors[ii]], spacer, sheetHeaderArrayPartial);\n            outputData.push(compositeFactorMasterArray[ii]);\n        }\n\n        for (var i = 0, iLen = factorWeightFactorArray.length; i < iLen; i++) {\n            sheetNames.push(sheetNamesHolder1[i]);\n            sheetNames.push(sheetNamesHolder2[i]);\n            sheetNames.push(sheetNamesHolder3[i]);\n            output.push(factorWeightFactorArray[i]);\n            output.push(miniCorrelationArray[i]);\n            output.push(synFactorArray1[i]);\n        }\n\n        pushFactorPowerSetDiffsToOutputArray(sheetNames, output, analysisOutput, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushFactorPowerSetDiffsToOutputArray(sheetNames, output, analysisOutput, outputData, sheetNamesXlsx, colSizes) {\n        var language = QAV.getState("language");\n        var chartText1 = resources[language].translation.Diff;\n        var chartText2 = resources[language].translation.Difference;\n        var chartText3 = resources[language].translation["Statement Number"];\n        var chartText4 = resources[language].translation.Statement;\n        var chartText5 = resources[language].translation["Descending Array of Differences Between"];\n        var chartText6 = resources[language].translation.and;\n        var oneFactor, anotherFactor;\n        var maxStatementLength = QAV.getState("maxStatementLength");\n        var spacer = ["", ""];\n\n        var factorPairs = [];\n        for (var i = 0; i < analysisOutput.length - 1; i++) {\n            for (var j = i; j < analysisOutput.length - 1; j++) {\n                factorPairs.push([\n                    analysisOutput[i],\n                    analysisOutput[j + 1]\n                ]);\n            }\n        }\n        var diffArraySorted;\n        var namesComboArray = [];\n        var sheetHeader1Array = [];\n\n        for (var k = 0; k < factorPairs.length; k++) {\n            var namesComboArrayFrag = [];\n            var sheetHeader1 = [chartText3, chartText4];\n            oneFactor = factorPairs[k][0][0].factor;\n            anotherFactor = factorPairs[k][1][0].factor;\n            namesComboArrayFrag.push(oneFactor, anotherFactor);\n            var temp1 = {};\n            temp1.sheetid = chartText1 + oneFactor + " " + anotherFactor;\n            temp1.header = true;\n            sheetNames.push(temp1);\n            namesComboArray.push(namesComboArrayFrag);\n            sheetNamesXlsx.push(chartText1 + oneFactor + " " + anotherFactor);\n\n            sheetHeader1.push(oneFactor, anotherFactor, chartText2);\n            sheetHeader1Array.push(sheetHeader1);\n\n            var columns = [{\n                wch: 8\n            }, {\n                wch: maxStatementLength\n            }, {\n                wch: 8\n            }, {\n                wch: 8\n            }, {\n                wch: 10\n            }];\n            colSizes.push(columns);\n        }\n\n        // push each pair to output\n        for (var m = 0; m < factorPairs.length; m++) {\n            var diffArray = [];\n            var diffArrayXlsx = [];\n            for (var p = 0; p < factorPairs[m][0].length; p++) {\n                var tempArray = [];\n\n                var temp1a = factorPairs[m][0][p].statement;\n                var temp1b = factorPairs[m][0][p].sortStatement;\n                var temp1c = factorPairs[m][0][p].zScore;\n                var temp1d = factorPairs[m][1][p].zScore;\n                var factorsDiff = evenRound(((factorPairs[m][0][p].zScore) - (factorPairs[m][1][p].zScore)), 3);\n                tempArray.push(temp1a, temp1b, temp1c, temp1d, factorsDiff);\n                diffArrayXlsx.push(tempArray);\n            }\n\n            diffArrayXlsx.sort(function(a, b) {\n                if (a[4] === b[4]) {\n                    return 0;\n                } else {\n                    return (b[4] < a[4]) ?\n                        -1 :\n                        1;\n                }\n            });\n            diffArrayXlsx.unshift(spacer, [chartText5 + " " + namesComboArray[m][0] + " " + chartText6 + " " + namesComboArray[m][1]], spacer, sheetHeader1Array[m]);\n            outputData.push(diffArrayXlsx);\n        }\n\n        pushConsensusStatementsToOutput(sheetNames, output, analysisOutput, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushConsensusStatementsToOutput(sheetNames, output, analysisOutput, outputData, sheetNamesXlsx, colSizes) {\n\n        var language = QAV.getState("language");\n        var chartText1 = resources[language].translation["Z-Score Variance"];\n        var chartText2 = resources[language].translation["Consensus-Disagreement"];\n        var chartText3 = resources[language].translation["Statement Number"];\n        var chartText4 = resources[language].translation.Statement;\n        var chartText5 = resources[language].translation["Z-Score Variance"];\n        var chartText6 = resources[language].translation["Factor Q-sort Values for Statements sorted by Consensus vs. Disagreement"];\n\n        var sigFactorNumbersArray = QAV.getState("sigFactorNumbersArray");\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n        var maxStatementLength = QAV.getState("maxStatementLength");\n        var spacer = ["", ""];\n\n        sigFactorNumbersArray.sort();\n\n        var tableHeader = [chartText3, chartText4];\n        var tableHeader2 = tableHeader.concat(userSelectedFactors);\n        tableHeader2.push(chartText5);\n\n        sheetNamesXlsx.push(chartText2);\n\n        // set factor sheet cols\n        var columns = [{\n            wch: 8\n        }, {\n            wch: maxStatementLength\n        }];\n        for (var tt = 0, ttLen = userSelectedFactors.length; tt < ttLen; tt++) {\n            columns.push({\n                wch: 8\n            });\n        }\n        columns.push({\n            wch: 15\n        });\n        colSizes.push(columns);\n\n        var consensusDisagreeArray = [];\n        var zScoreArrayForStatements = [];\n        for (var i = 0; i < analysisOutput[0].length; i++) {\n            var tempArray1a = [];\n            tempArray1a.push(analysisOutput[0][i].statement, analysisOutput[0][i].sortStatement);\n            var tempArray = [];\n            for (var j = 0; j < analysisOutput.length; j++) {\n                var temp1 = sigFactorNumbersArray[j];\n                tempArray1a.push(analysisOutput[j][i].sortValue);\n                tempArray.push(analysisOutput[j][i].zScore);\n            }\n            var zScoreVariance = evenRound((UTIL.variance(tempArray)), 3);\n            tempArray1a.push(zScoreVariance);\n            consensusDisagreeArray.push(tempArray1a);\n        }\n\n        var locator = userSelectedFactors.length + 2;\n        consensusDisagreeArray.sort(function(a, b) {\n            if (a[locator] === b[locator]) {\n                return 0;\n            } else {\n                return (a[locator] < b[locator]) ?\n                    -1 :\n                    1;\n            }\n        });\n        consensusDisagreeArray.unshift(spacer, [chartText6], spacer, tableHeader2);\n        outputData.push(consensusDisagreeArray);\n\n        pushFactorCharacteristicsToOutput(sheetNames, output, analysisOutput, sigFactorNumbersArray, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushFactorCharacteristicsToOutput(sheetNames, output, analysisOutput, sigFactorNumbersArray, outputData, sheetNamesXlsx, colSizes) {\n\n        var language = QAV.getState("language");\n        var chartText1 = resources[language].translation["Factor Characteristics"];\n        var chartText2 = resources[language].translation["Factor Number"];\n        var chartText3 = resources[language].translation["No. of Defining Variables"];\n        var chartText4 = resources[language].translation["Avg. Rel. Coef."];\n        var chartText5 = resources[language].translation["Composite Reliability"];\n        var chartText6 = resources[language].translation["S.E. of Factor Z-scores"];\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n        var sigSortsArray = QAV.getState("sigSortsArray");\n        var spacer = ["", ""];\n\n        sheetNamesXlsx.push(chartText1);\n\n        // set factor sheet col widths\n        var columns = [{\n            wch: 20\n        }];\n        for (var tt = 0, ttLen = userSelectedFactors.length; tt < ttLen; tt++) {\n            columns.push({\n                wch: 8\n            });\n        }\n        colSizes.push(columns);\n\n        var factorCharacteristicsSheetArray = [];\n\n        // line 1 - factor labels\n        var line1Array = [""];\n        var line1Arrayb = line1Array.concat(userSelectedFactors);\n        factorCharacteristicsSheetArray.push(line1Arrayb);\n\n\n        // line 2 - No. of Defining Variables\n        var line2Array = [chartText3];\n        for (var j = 0; j < sigSortsArray.length; j++) {\n            line2Array.push(sigSortsArray[j].SigSorts.length);\n        }\n        factorCharacteristicsSheetArray.push(line2Array);\n\n        // line 3 - Avg. Rel. Coef.\n        // todo - !important - change this for unrestrained unforced sort patterns?\n        var line3Array = [chartText4];\n        for (var k = 0; k < sigSortsArray.length; k++) {\n            line3Array.push(0.800);\n        }\n        factorCharacteristicsSheetArray.push(line3Array);\n\n        // line 4 - Composite Reliability\n        var line4Array = [chartText5];\n        var nSorts,\n            compositeRel;\n        var composRelArray = [];\n        for (var m = 0; m < sigSortsArray.length; m++) {\n            nSorts = sigSortsArray[m].SigSorts.length;\n            compositeRel = evenRound(((nSorts * 0.800) / (1 + ((nSorts - 1) * 0.800))), 3);\n            composRelArray.push(compositeRel);\n            line4Array.push(compositeRel);\n        }\n        factorCharacteristicsSheetArray.push(line4Array);\n\n        // line 5 - S.E. of Factor Z-scores\n        var line5Array = [chartText6];\n        var stndErrorArray = [];\n        for (var p = 0; p < sigSortsArray.length; p++) {\n            var stndError = evenRound(Math.sqrt(Math.abs(1.0 - composRelArray[p])), 3);\n            stndErrorArray.push(stndError);\n            line5Array.push(stndError);\n        }\n        factorCharacteristicsSheetArray.push(line5Array);\n        factorCharacteristicsSheetArray.unshift(spacer, [chartText1], spacer);\n\n        outputData.push(factorCharacteristicsSheetArray);\n\n        pushStandardErrorsDifferencesToOutput(sheetNames, output, stndErrorArray, analysisOutput, sigFactorNumbersArray, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushStandardErrorsDifferencesToOutput(sheetNames, output, stndErrorArray, analysisOutput, sigFactorNumbersArray, outputData, sheetNamesXlsx, colSizes) {\n\n        var language = QAV.getState("language");\n        var chartText1 = resources[language].translation["Standard Errors for Diffs"];\n        var chartText2 = resources[language].translation["Standard Errors for Differences in Factor Z-scores"];\n        var sigSortsArray = QAV.getState("sigSortsArray");\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n        var spacer = ["", ""];\n\n        sheetNamesXlsx.push(chartText1);\n\n        // set factor sheet col widths\n        var columns = [{\n            wch: 8\n        }];\n        for (var tt = 0, ttLen = userSelectedFactors.length; tt < ttLen; tt++) {\n            columns.push({\n                wch: 8\n            });\n        }\n        colSizes.push(columns);\n\n        var standardErrorDiffSheetArray = [];\n\n        // line 1\n        var line1Array = [""];\n        var line1Arrayb = line1Array.concat(userSelectedFactors);\n        standardErrorDiffSheetArray.push(line1Arrayb);\n\n        var stndErrorDiffArray = [];\n        var stndErrorDiffDataArray = [];\n        var stndErrorDiffDataDistingArray = [];\n\n        var stndError1, stndError2, stndError3;\n\n        // lines 2 to end\n        for (var j = 0; j < sigSortsArray.length; j++) {\n            var tempArray1 = [];\n            tempArray1.push(sigSortsArray[j]["Factor Number"]);\n\n            for (var k = 0; k < sigSortsArray.length; k++) {\n                var stndErrorDiffDataArrayTemp1 = [];\n                var tempArray2 = [];\n                stndErrorDiffDataArrayTemp1.push("Factor " + sigSortsArray[j]["Factor Number"]);\n                tempArray2.push(sigSortsArray[j]["Factor Number"]);\n                stndErrorDiffDataArrayTemp1.push("Factor " + sigSortsArray[k]["Factor Number"]);\n                tempArray2.push(sigSortsArray[k]["Factor Number"]);\n                stndError1 = stndErrorArray[j];\n                stndError2 = stndErrorArray[k];\n                stndError3 = evenRound((Math.sqrt((stndError1 * stndError1) + (stndError2 * stndError2))), 3);\n                stndErrorDiffDataArrayTemp1.push(stndError3);\n                tempArray2.push(stndError3);\n                tempArray1.push(stndError3);\n                stndErrorDiffDataArray.push(stndErrorDiffDataArrayTemp1);\n                stndErrorDiffDataDistingArray.push(tempArray2);\n            }\n            standardErrorDiffSheetArray.push(tempArray1);\n        }\n        standardErrorDiffSheetArray.unshift(spacer, [chartText2], spacer);\n        outputData.push(standardErrorDiffSheetArray);\n\n        pushDistinguishingStatementsToOutput(sheetNames, output, sigSortsArray, analysisOutput, stndErrorDiffDataArray, stndErrorDiffDataDistingArray, sigFactorNumbersArray, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushDistinguishingStatementsToOutput(sheetNames, output, sigSortsArray, analysisOutput, stndErrorDiffDataArray, stndErrorDiffDataDistingArray, sigFactorNumbersArray, outputData, sheetNamesXlsx, colSizes) {\n\n        var language = QAV.getState("language");\n        var chartText1 = resources[language].translation["Dist State"];\n        var chartText2 = resources[language].translation["Consensus Statements"];\n        var maxStatementLength = QAV.getState("maxStatementLength");\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n\n        // property to count loop iterations for assigning significance * in disting factor output\n        formatDistingArrayForDownload.calledTimes = 0;\n\n        // loop to set up worksheet names and push into output array\n        for (var i = 0; i < sigSortsArray.length; i++) {\n\n            sheetNamesXlsx.push(chartText1 + sigSortsArray[i]["Factor Number"]);\n\n            // set up col widths for excel output - todo - change maxStatementLength?\n            var columns = [{\n                wch: 8\n            }, {\n                wch: maxStatementLength\n            }, {\n                wch: 8\n            }];\n            for (var tt = 0, ttLen = userSelectedFactors.length; tt < ttLen; tt++) {\n                columns.push({\n                    wch: 8\n                }, {\n                    wch: 8\n                }, {\n                    wch: 8\n                });\n            }\n            colSizes.push(columns);\n        }\n\n        // starting calcs for distinguishing factors\n        var sedComparisonValue, j, k, m;\n        var consensusStatementComparisonArray05 = [];\n        var consensusStatementComparisonArray01 = [];\n        var distStatementDataVizArray = [];\n        var masterDistingStatementNumbersArray05 = [];\n        var masterDistingStatementNumbersArray01 = [];\n\n        // looping through all factors to determine if distinguishing!\n        // todo - create if statement for case of only two sig factors-bypass processing of second c 4894\n        for (j = 0; j < sigSortsArray.length; j++) {\n            // factor j\n            // looping through all statements in each j factor\n            var distingStatementsTransferArray05 = [];\n            var distingStatementsTransferArray01 = [];\n            var consensusStatementTransferArray05 = [];\n            var consensusStatementTransferArray01 = [];\n\n            for (k = 0; k < analysisOutput[0].length; k++) {\n                // looping through each statement\'s other factor zScores to compare\n                // also grabbing the appropriate SED value for each comparison\n                var sig05 = false;\n                var sig05Array = [];\n                var sig01 = false;\n                var sig01Array = [];\n                var newStatementNum;\n\n                for (m = 0; m < sigSortsArray.length; m++) {\n                    // factor m\n                    // check to avoid comparison with self\n                    if (analysisOutput[j][k].factor === analysisOutput[m][k].factor) {} else {\n                        // loop through SED array to find comparison value\n                        sedComparisonValue = null;\n\n                        for (var p = 0; p < stndErrorDiffDataDistingArray.length; p++) {\n                            var searchVal1 = stndErrorDiffDataDistingArray[p][0];\n                            var searchVal2 = stndErrorDiffDataDistingArray[p][1];\n                            var iteratorJShift = sigFactorNumbersArray[j];\n                            var iteratorMShift = sigFactorNumbersArray[m];\n\n                            if (searchVal1 === iteratorJShift && searchVal2 === iteratorMShift) {\n                                sedComparisonValue = stndErrorDiffDataDistingArray[p][2];\n                            }\n                        }\n\n                        if (Math.abs(analysisOutput[j][k].zScore - analysisOutput[m][k].zScore) >= (sedComparisonValue * 1.96)) {\n                            analysisOutput[j][k].zScore = evenRound((analysisOutput[j][k].zScore), 2);\n                            sig05 = true;\n                            sig05Array.push(sig05);\n                        }\n\n                        if (Math.abs(analysisOutput[j][k].zScore - analysisOutput[m][k].zScore) >= (sedComparisonValue * 2.58)) {\n                            analysisOutput[j][k].zScore = evenRound((analysisOutput[j][k].zScore), 2);\n                            sig01 = true;\n                            sig01Array.push(sig01);\n                        }\n                    }\n                }\n\n                newStatementNum = k + 1;\n\n                if (sig05Array.length === (sigFactorNumbersArray.length - 1)) {\n                    distingStatementsTransferArray05.push(newStatementNum);\n                }\n\n                if (sig01Array.length === (sigFactorNumbersArray.length - 1)) {\n                    distingStatementsTransferArray01.push(newStatementNum);\n                }\n\n                if (sig05Array.length === 0) {\n                    consensusStatementTransferArray05.push(newStatementNum);\n                }\n\n                if (sig01Array.length === 0) {\n                    consensusStatementTransferArray01.push(newStatementNum);\n                }\n            }\n\n            var distingStatementsTransferArray05b = _.uniq(distingStatementsTransferArray05, true);\n            var distingStatementsTransferArray01b = _.uniq(distingStatementsTransferArray01, true);\n            var distingStatementsTransferArray05c = _.difference(distingStatementsTransferArray05b, distingStatementsTransferArray01b);\n\n            masterDistingStatementNumbersArray05.push(distingStatementsTransferArray05c);\n            masterDistingStatementNumbersArray01.push(distingStatementsTransferArray01b);\n\n            consensusStatementComparisonArray05.push(consensusStatementTransferArray05);\n            consensusStatementComparisonArray01.push(consensusStatementTransferArray01);\n\n            var factorNumber = sigFactorNumbersArray[j];\n\n            var formattedDistingStatements = formatDistingArrayForDownload(distingStatementsTransferArray01b, distingStatementsTransferArray05c, factorNumber, analysisOutput, sigFactorNumbersArray);\n\n            distStatementDataVizArray.push(formattedDistingStatements[0]);\n\n            outputData.push(formattedDistingStatements[1]);\n        }\n\n        QAV.setState("masterDistingStatementNumbersArray01", masterDistingStatementNumbersArray01);\n        QAV.setState("masterDistingStatementNumbersArray05", masterDistingStatementNumbersArray05);\n\n        // ******\n        // develop consensus statement data\n        // ******\n        //var outputForDataViz = _.cloneDeep(analysisOutput);\n        QAV.setState("distStatementDataVizArray", distStatementDataVizArray);\n        QAV.setState("outputForDataViz", analysisOutput);\n\n        do {\n            consensusStatementComparisonArray05 = reduceDistingArray(consensusStatementComparisonArray05);\n        } while (consensusStatementComparisonArray05.length > 1);\n\n        do {\n            consensusStatementComparisonArray01 = reduceDistingArray(consensusStatementComparisonArray01);\n        } while (consensusStatementComparisonArray01.length > 1);\n\n        var consensus05 = _.flatten(consensusStatementComparisonArray05);\n        var consensusStatementComparisonArray01b = _.flatten(consensusStatementComparisonArray01);\n\n        var consensus01 = _.xor(consensus05, consensusStatementComparisonArray01b);\n\n        QAV.setState("consensus05Statements", consensus05);\n        QAV.setState("consensus01Statements", consensus01);\n\n        sheetNamesXlsx.push(chartText2);\n\n        // set up col widths for excel output\n        var columns2 = [{\n            wch: 12\n        }, {\n            wch: 12\n        }, {\n            wch: maxStatementLength\n        }, {\n            wch: 12\n        }];\n        for (var ttt = 0, tttLen = userSelectedFactors.length; ttt < tttLen; ttt++) {\n            columns2.push({\n                wch: 12\n            }, {\n                wch: 15\n            }, {\n                wch: 15\n            });\n        }\n        colSizes.push(columns2);\n\n        var formattedConsensusStatements = formatConsensusArrayForDownload(consensus05, consensus01, analysisOutput, sigFactorNumbersArray);\n        QAV.setState("formattedConsensusStatements", formattedConsensusStatements[0]);\n\n        outputData.push(formattedConsensusStatements[1]);\n\n        pushCribSheetsToOutput(sheetNames, output, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushCribSheetsToOutput(sheetNames, output, outputData, sheetNamesXlsx, colSizes) {\n        var language = QAV.getState("language");\n        var appendText1 = resources[language].translation[" Rel. Ranks"];\n        var appendText2 = resources[language].translation["Relative Ranking of Statements in "];\n        var appendText3 = resources[language].translation["Statement Number"];\n        var appendText5 = resources[language].translation["Z-score"];\n        var appendText9 = resources[language].translation.Distinguishing;\n        var appendText8 = resources[language].translation.Consensus;\n        var appendTextHeader1 = resources[language].translation["Highest Ranked Statements"];\n        var appendTextHeader2a = resources[language].translation["Positive Statements Ranked Higher in "];\n        var appendTextHeader2b = resources[language].translation["Array than in Other Factor Arrays"];\n        var appendTextHeader3a = resources[language].translation["Negative Statements Ranked Lower in "];\n        var appendTextHeader3b = resources[language].translation["Array than in Other Factor ArraysB"];\n        var appendTextHeader4 = resources[language].translation["Lowest Ranked Statements"];\n        var maxStatementLength = QAV.getState("maxStatementLength");\n        var appendText6 = resources[language].translation.Statement;\n        var appendText7 = resources[language].translation["Sort Values"];\n        // var appendText8 = resources[language].translation["Note: "];\n\n        var statementRankingArray = QAV.getState("statementRankingArray");\n        var userSelectedFactors = QAV.getState("userSelectedFactors");\n        var factorInformation,\n            lowestRankStatements,\n            tempObj1,\n            cribArray = [];\n        var cribArray2 = [];\n        var highestRankStatements,\n            tempObj2,\n            tempObj3,\n            tempObj4;\n        var maxRankValue,\n            minRankValue,\n            compositeSortValue,\n            compositeSortValue2;\n        var currentRank,\n            currentRank2;\n\n        // determine the number of statements in the extreme columns\n        var sortTriangleShape = QAV.getState("qavSortTriangleShape");\n        var synFactorArray1Holder = QAV.getState("synFactorArray1Holder");\n\n        var arrayMax = +(_.max(sortTriangleShape));\n        var arrayMin = +(_.min(sortTriangleShape));\n        var triangleCounts = _.countBy(sortTriangleShape, _.identity);\n\n        var maxCounts = triangleCounts[arrayMax];\n        var minCounts = triangleCounts[arrayMin];\n\n        // loop through factors\n        for (var j = 0, jLen = userSelectedFactors.length; j < jLen; j++) {\n\n            sheetNamesXlsx.push(userSelectedFactors[j] + appendText1);\n\n            var columns = [{\n                wch: 8\n            }, {\n                wch: 80\n            }, {\n                wch: 8\n            }, {\n                wch: 12\n            }];\n            colSizes.push(columns);\n\n            cribArray = [\n                [],\n                [],\n                [],\n                []\n            ];\n\n            cribArray2 = [\n                [],\n                [],\n                [],\n                []\n            ];\n\n            factorInformation = _.cloneDeep(synFactorArray1Holder[j]);\n\n            // sort by statement number\n            factorInformation.sort(function(a, b) {\n                return a[appendText3] - b[appendText3];\n            });\n\n            //console.log(JSON.stringify(factorInformation));\n\n            // append the ranking arrays\n            for (var k = 0, kLen = factorInformation.length; k < kLen; k++) {\n                factorInformation[k].rankArray = statementRankingArray[k];\n            }\n\n            // resort back to high to low z-score sort\n            factorInformation\n                .sort(function(a, b) {\n                    if (b[appendText5] === a[appendText5]) {\n                        return a[appendText3] - b[appendText3];\n                    } else {\n                        return b[appendText5] - a[appendText5];\n                    }\n                });\n\n            // push highest to cribArray\n            for (var m = 0; m < minCounts; m++) {\n                // tempObj1 = {};\n                highestRankStatements = factorInformation.shift();\n                var stateNum0 = highestRankStatements[appendText3];\n                var statement0 = highestRankStatements[appendText6];\n                var checkIfDisOrCon0 = checkIfDistinguishingOrConsensus(stateNum0, j);\n                var compositeSortValue0 = highestRankStatements[appendText7];\n                var otherValues = _.clone(highestRankStatements.rankArray);\n                otherValues.splice(j, 1);\n                var array0 = [stateNum0, statement0, compositeSortValue0, checkIfDisOrCon0];\n                var array0a = array0.concat(otherValues);\n                cribArray2[0].push(array0a);\n            }\n\n            // push lowest to cribArray\n            for (var p = 0; p < maxCounts; p++) {\n                // tempObj2 = {};\n                lowestRankStatements = factorInformation.pop();\n                var stateNum3 = lowestRankStatements[appendText3];\n                var statement3 = lowestRankStatements[appendText6];\n                var checkIfDisOrCon3 = checkIfDistinguishingOrConsensus(stateNum3, j);\n                var compositeSortValue3 = lowestRankStatements[appendText7];\n                var otherValues3 = _.clone(lowestRankStatements.rankArray);\n                otherValues3.splice(j, 1);\n                var array3 = [stateNum3, statement3, compositeSortValue3, checkIfDisOrCon3];\n                var array3a = array3.concat(otherValues3);\n\n                cribArray2[3].unshift(array3a);\n            }\n\n            // look for higher relative statements and push to cribArray\n            for (var r = 0, rLen = factorInformation.length; r < rLen; r++) {\n                compositeSortValue = factorInformation[r][appendText7];\n                if (compositeSortValue > -1) {\n                    maxRankValue = _.max(factorInformation[r].rankArray);\n                    if (compositeSortValue === maxRankValue) {\n                        var otherValues2 = _.clone(factorInformation[r].rankArray);\n                        otherValues2.splice(j, 1);\n                        var stateNum = factorInformation[r][appendText3];\n                        var checkIfDisOrCon = checkIfDistinguishingOrConsensus(stateNum, j);\n                        var tempArray22 = [\n                            stateNum,\n                            (factorInformation[r][appendText6]),\n                            (compositeSortValue),\n                            checkIfDisOrCon\n                        ];\n                        var combinedArray1 = tempArray22.concat(otherValues2);\n                        cribArray2[1].push(combinedArray1);\n                    }\n                }\n                if (compositeSortValue < 1) {\n                    minRankValue = _.min(factorInformation[r].rankArray);\n                    currentRank2 = factorInformation[r].rankArray[j];\n                    if (compositeSortValue === minRankValue) {\n                        var otherValuesLower = _.clone(factorInformation[r].rankArray);\n                        otherValuesLower.splice(j, 1);\n                        var stateNum2 = factorInformation[r][appendText3];\n                        var checkIfDisOrCon2 = checkIfDistinguishingOrConsensus(stateNum2, j);\n                        var tempArray33 = [\n                            stateNum2,\n                            (factorInformation[r][appendText6]),\n                            (compositeSortValue),\n                            checkIfDisOrCon2\n                        ];\n                        var combinedArray2 = tempArray33.concat(otherValuesLower);\n                        cribArray2[2].push(combinedArray2);\n                    }\n                }\n            }\n\n            var spacerArray = ["", ""];\n\n            // construct headers for statement groups\n            var facName = userSelectedFactors[j];\n\n            // create column headers for other factors\n            var otherFactorNames = _.clone(userSelectedFactors);\n            otherFactorNames.splice(j, 1);\n            var higherRankedHeader = [\n                "", appendTextHeader2a + facName + appendTextHeader2b\n            ];\n\n            var header1 = [\n                "", appendText2 + facName\n            ];\n            var header0 = ["", appendTextHeader1, facName, appendText9].concat(otherFactorNames);\n            cribArray2[0].unshift(spacerArray, header1, [\n                "", "", "", appendText8\n            ], header0);\n\n            cribArray2[1].unshift(spacerArray, higherRankedHeader);\n\n            var header3 = {};\n            header3.stateNum = "";\n            header3.statement = appendTextHeader3a + facName + appendTextHeader3b;\n            header3.sortValue = "";\n            cribArray2[2].unshift(spacerArray, [\n                "",\n                (appendTextHeader3a + facName + appendTextHeader3b),\n                ""\n            ]);\n\n            var header4 = {};\n            header4.stateNum = "";\n            header4.statement = appendTextHeader4;\n            header4.sortValue = "";\n            cribArray2[3].unshift(spacerArray, ["", (appendTextHeader4), ""]);\n\n            output.push(_.flattenDeep(cribArray));\n            outputData.push(_.flatten(cribArray2));\n        }\n\n        // helper function\n        function checkIfDistinguishingOrConsensus(statementNumber, loopNumber) {\n            var masterDistingStatementNumbersArray01 = QAV.getState("masterDistingStatementNumbersArray01");\n            var masterDistingStatementNumbersArray05 = QAV.getState("masterDistingStatementNumbersArray05");\n            var consensus05 = QAV.getState("consensus05Statements");\n            var consensus01 = QAV.getState("consensus01Statements");\n            if (_.contains(masterDistingStatementNumbersArray05[loopNumber], statementNumber)) {\n                return "  D";\n            } else if (_.contains(consensus01, statementNumber)) {\n                return "  C";\n            } else if (_.contains(masterDistingStatementNumbersArray01[loopNumber], statementNumber)) {\n                return "  D*";\n            } else if (_.contains(consensus05, statementNumber)) {\n                return "  C*";\n            } else {\n                return "";\n            }\n        }\n        pushSettingsToOutput(sheetNames, output, outputData, sheetNamesXlsx, colSizes);\n    }\n\n    function pushSettingsToOutput(sheetNames, output, outputData, sheetNamesXlsx, colSizes) {\n        QAV.setState("outputComplete", "true");\n        QAV.setState("outputSpreadsheetArray", output);\n        QAV.setState("outputSpreadsheetSheetNamesArray", sheetNames);\n\n        // for output testing - do not delete!\n        // console.log(JSON.stringify(output));\n        // console.log(JSON.stringify(sheetNames));\n\n        // console.log(JSON.stringify(outputData));\n        // console.log(JSON.stringify(sheetNamesXlsx));\n        // console.log(JSON.stringify(colSizes));\n\n        QAV.setState("dataXlsx", outputData);\n        QAV.setState("sheetNamesXlsx", sheetNamesXlsx);\n        QAV.setState("colSizes", colSizes);\n    }\n\n    //*******************************************************************************\n    //********  HELPER FUNCTIONS  ***************************************************\n    //*******************************************************************************\n\n    // helper function for distinguishing statements array\n    function formatConsensusArrayForDownload(consensus05, consensus01, analysisOutput, sigFactorNumbersArray) {\n\n        var language = QAV.getState("language");\n        var chartText1 = resources[language].translation["Consensus Statements"];\n        var chartText2 = resources[language].translation["Those That Do Not Distinguish Between ANY Pair of Factors"];\n        var chartText3 = resources[language].translation["All Listed Statements are Non-Significant at P > 0.01, and Those Flagged with an * are also Non-Significant at P > 0.05)"];\n        var chartText4 = resources[language].translation.Significance;\n        var chartText5 = resources[language].translation.Statement;\n        var chartText6 = resources[language].translation.Num;\n        var chartText7 = resources[language].translation["Statement Number"];\n        var chartText8 = resources[language].translation["Z-score"];\n        var spacer = ["", ""];\n        var outputLength = analysisOutput.length;\n        var consensus05Length = consensus05.length;\n        var consensus01Length = consensus01.length;\n\n        var printArray = [];\n        var printArray2 = [];\n        var consensusSheetArray = [];\n        var consensusSheetArray2 = [];\n\n        // push headers\n        var emptyLineObj = {};\n        emptyLineObj["No."] = " ";\n        emptyLineObj["SIG "] = " ";\n        emptyLineObj["Statement "] = " ";\n        emptyLineObj["Num "] = " ";\n\n        for (var i = 0; i < outputLength; i++) {\n            emptyLineObj["Q-SV-" + sigFactorNumbersArray[i]] = " ";\n            emptyLineObj["Z-SCR-" + sigFactorNumbersArray[i]] = " ";\n            emptyLineObj["SIG" + sigFactorNumbersArray[i]] = " ";\n        }\n\n        consensusSheetArray.push(spacer, [chartText1 + " -- " + chartText2], spacer, [chartText3], spacer, spacer);\n\n        var line3Array = [];\n        printArray.push(emptyLineObj);\n        var printHeaderObj1 = {};\n        printHeaderObj1["No."] = chartText1 + " -- " + chartText2;\n        printArray.push(printHeaderObj1);\n        printArray.push(emptyLineObj);\n        var printHeaderObj2 = {};\n        printHeaderObj2["No."] = chartText3;\n        printArray.push(printHeaderObj2);\n        printArray.push(emptyLineObj);\n        printArray.push(emptyLineObj);\n        var printHeaderObj4 = {};\n        printHeaderObj4["No."] = chartText7;\n        printHeaderObj4["SIG "] = chartText4;\n        printHeaderObj4["Statement "] = chartText5;\n        printHeaderObj4["Num "] = chartText7;\n\n        line3Array.push(chartText7, chartText4, chartText5, chartText7);\n\n        for (var j = 0; j < outputLength; j++) {\n            printHeaderObj4["Q-SV-" + sigFactorNumbersArray[j]] = sigFactorNumbersArray[j] + " Q-SV";\n            printHeaderObj4["Z-SCR-" + sigFactorNumbersArray[j]] = sigFactorNumbersArray[j] + " " + chartText8;\n            line3Array.push((sigFactorNumbersArray[j] + " Q-SV"), (sigFactorNumbersArray[j] + " " + chartText8));\n        }\n        printArray.push(printHeaderObj4);\n        consensusSheetArray.push(line3Array);\n\n        var tempObj,\n            tempObj2,\n            kShift,\n            pShift;\n\n        // push 05 statements\n        for (var k = 0; k < consensus05Length; k++) {\n            tempObj = {};\n            var tempArray = [];\n            kShift = consensus05[k];\n\n            // cycle through statement numbers and get statement, factors q score and sort value from results object and set sig level to ""\n            tempObj["No."] = kShift;\n            // ["No."] = kShift;\n            tempObj["SIG "] = "*";\n            tempObj["Statement "] = analysisOutput[0][(kShift - 1)].sortStatement;\n            tempObj["Num "] = kShift;\n\n            tempArray.push(kShift, "*", (analysisOutput[0][(kShift - 1)].sortStatement), kShift);\n\n            for (var m = 0; m < outputLength; m++) {\n                tempObj["Q-SV-" + sigFactorNumbersArray[m]] = analysisOutput[m][(kShift - 1)].sortValue;\n                tempObj["Z-SCR-" + sigFactorNumbersArray[m]] = analysisOutput[m][(kShift - 1)].zScore;\n                tempArray.push((analysisOutput[m][(kShift - 1)].sortValue), (analysisOutput[m][(kShift - 1)].zScore));\n            }\n            printArray2.push(tempObj);\n            consensusSheetArray2.push(tempArray);\n        }\n\n        // cycle through statement numbers and get statement, factors q score and sort value from results object and set sig level to "*"\n        for (var p = 0; p < consensus01Length; p++) {\n            var tempArray2 = [];\n            tempObj2 = {};\n            pShift = consensus01[p];\n\n            tempObj2["No."] = pShift;\n            tempObj2["SIG "] = "";\n            tempObj2["Statement "] = analysisOutput[0][(pShift - 1)].sortStatement;\n            tempObj2["Num "] = pShift;\n\n            tempArray2.push(pShift, "", (analysisOutput[0][(pShift - 1)].sortStatement), pShift);\n\n            for (var q = 0; q < outputLength; q++) {\n                tempObj2["Q-SV-" + sigFactorNumbersArray[q]] = analysisOutput[q][(pShift - 1)].sortValue;\n                tempObj2["Z-SCR-" + sigFactorNumbersArray[q]] = analysisOutput[q][(pShift - 1)].zScore;\n                tempArray2.push((analysisOutput[q][(pShift - 1)].sortValue), (analysisOutput[q][(pShift - 1)].zScore));\n            }\n            printArray2.push(tempObj2);\n            consensusSheetArray2.push(tempArray2);\n        }\n\n        var printArray3 = printArray2.sort(function(a, b) {\n            return a["No."] - b["No."];\n        });\n\n        consensusSheetArray2.sort(function(a, b) {\n            if (a[0] === b[0]) {\n                return 0;\n            } else {\n                return (a[0] < b[0]) ?\n                    -1 :\n                    1;\n            }\n        });\n\n        var finalArray = consensusSheetArray.concat(consensusSheetArray2);\n\n        for (var r = 0; r < printArray3.length; r++) {\n            printArray.push(printArray3[r]);\n        }\n        return [printArray, finalArray];\n    }\n\n    // helper function for distinguishing arrays\n    function reduceDistingArray(array) {\n        var reducedArray = [];\n        for (var r = 0; r < array.length; r++) {\n            var increment3 = r + 1;\n            var commonSet2 = _.intersection(array[r], array[increment3]);\n            reducedArray.push(commonSet2);\n        }\n        if (reducedArray.length > 1) {\n            reducedArray.pop();\n        }\n        return reducedArray;\n    }\n\n    /*\n     * helper function\n     */\n    function formatDistingArrayForDownload(distingStatementsTransferArray01, distingStatementsTransferArray05, factorNumber, analysisOutput, sigFactorNumbersArray) {\n\n        var language = QAV.getState("language");\n        var chartText1 = resources[language].translation["Distinguishing Statements for"];\n        var chartText2 = resources[language].translation["(P < .05 : Asterisk (*) Indicates Significance at P < .01)"];\n        var chartText3 = resources[language].translation["Both the Factor Q-Sort Value and the Z-Score (Z-SCR) are Shown"];\n        var chartText4 = resources[language].translation.Significance;\n        var chartText5 = resources[language].translation.Statement;\n        var chartText6 = resources[language].translation.Num;\n        var chartText7 = resources[language].translation["Statement Number"];\n        var chartText8 = resources[language].translation["Z-score"];\n\n        var outputLength = analysisOutput.length;\n        var disting05Length = distingStatementsTransferArray05.length;\n        var disting01Length = distingStatementsTransferArray01.length;\n\n        var printArray = [];\n        var printArray2 = [];\n        var spacer = ["", ""];\n\n        var distinguishingSheetArray = [];\n\n        // line 1\n        var line1Array = [chartText1 + factorNumber];\n        distinguishingSheetArray.push(spacer, line1Array);\n\n        // line 2\n        distinguishingSheetArray.push(spacer, [chartText2]);\n\n        // line 3\n        distinguishingSheetArray.push(spacer, [chartText3], spacer, spacer);\n\n        // line 4 - headers\n        var line4Array = [chartText7, chartText5, chartText7];\n\n        // push headers\n        var emptyLineObj = {};\n        emptyLineObj["No."] = " ";\n        emptyLineObj["Statement "] = " ";\n        emptyLineObj["Num "] = " ";\n\n        for (var i = 0; i < outputLength; i++) {\n            emptyLineObj["Q-SV-" + sigFactorNumbersArray[i]] = " ";\n            emptyLineObj["Z-SCR-" + sigFactorNumbersArray[i]] = " ";\n            emptyLineObj["SIG" + sigFactorNumbersArray[i]] = " ";\n        }\n\n        printArray.push(emptyLineObj);\n        var printHeaderObj1 = {};\n        printHeaderObj1["No."] = chartText1 + factorNumber;\n        printArray.push(printHeaderObj1);\n        printArray.push(emptyLineObj);\n        var printHeaderObj2 = {};\n        printHeaderObj2["No."] = chartText2;\n        printArray.push(printHeaderObj2);\n        printArray.push(emptyLineObj);\n        var printHeaderObj3 = {};\n        printHeaderObj3["No."] = chartText3;\n        printArray.push(printHeaderObj3);\n        printArray.push(emptyLineObj);\n        printArray.push(emptyLineObj);\n        var printHeaderObj4 = {};\n        printHeaderObj4["No."] = chartText7;\n        printHeaderObj4["Statement "] = chartText5;\n        printHeaderObj4["Num "] = chartText7;\n\n        for (var j = 0; j < outputLength; j++) {\n            printHeaderObj4["Q-SV-" + sigFactorNumbersArray[j]] = sigFactorNumbersArray[j] + " Q-SV";\n            printHeaderObj4["Z-SCR-" + sigFactorNumbersArray[j]] = sigFactorNumbersArray[j] + " " + chartText8;\n            printHeaderObj4["SIG" + sigFactorNumbersArray[j]] = chartText4;\n\n            line4Array.push((sigFactorNumbersArray[j] + " Q-SV"), (sigFactorNumbersArray[j] + " " + chartText8), chartText4);\n\n        }\n        printArray.push(printHeaderObj4);\n        distinguishingSheetArray.push(line4Array);\n\n        var tempObj,\n            tempObj2,\n            kShift,\n            pShift;\n\n        // line 5\n        var distinguishingSheetArray2 = [];\n\n        // push 05 statements\n        for (var k = 0; k < disting05Length; k++) {\n            var line5Array = [];\n            tempObj = {};\n            kShift = distingStatementsTransferArray05[k];\n\n            // cycle through statement numbers and get statement, factors q score and sort value from results object and set sig level to ""\n            tempObj["No."] = kShift;\n            line5Array.push(kShift);\n\n            tempObj["Statement "] = analysisOutput[0][(kShift - 1)].sortStatement;\n            line5Array.push(analysisOutput[0][(kShift - 1)].sortStatement, kShift);\n\n            tempObj["Num "] = kShift;\n            for (var m = 0; m < outputLength; m++) {\n                tempObj["Q-SV-" + sigFactorNumbersArray[m]] = analysisOutput[m][(kShift - 1)].sortValue;\n                tempObj["Z-SCR-" + sigFactorNumbersArray[m]] = analysisOutput[m][(kShift - 1)].zScore;\n                tempObj["SIG" + sigFactorNumbersArray[m]] = "";\n                line5Array.push((analysisOutput[m][(kShift - 1)].sortValue), (analysisOutput[m][(kShift - 1)].zScore), "");\n            }\n            printArray2.push(tempObj);\n            distinguishingSheetArray2.push(line5Array);\n        }\n\n        // cycle through statement numbers and get statement, factors q score and sort value from results object and set sig level to "*"\n        for (var p = 0; p < disting01Length; p++) {\n            var line6Array = [];\n            tempObj2 = {};\n            pShift = distingStatementsTransferArray01[p];\n\n            tempObj2["No."] = pShift;\n            tempObj2["Statement "] = analysisOutput[0][(pShift - 1)].sortStatement;\n            tempObj2["Num "] = pShift;\n\n            line6Array.push(pShift, (analysisOutput[0][(pShift - 1)].sortStatement), pShift);\n\n            for (var q = 0; q < outputLength; q++) {\n                tempObj2["Q-SV-" + sigFactorNumbersArray[q]] = analysisOutput[q][(pShift - 1)].sortValue;\n                tempObj2["Z-SCR-" + sigFactorNumbersArray[q]] = analysisOutput[q][(pShift - 1)].zScore;\n\n                line6Array.push((analysisOutput[q][(pShift - 1)].sortValue), (analysisOutput[q][(pShift - 1)].zScore));\n\n                if (q === formatDistingArrayForDownload.calledTimes) {\n                    tempObj2["SIG" + sigFactorNumbersArray[q]] = "*";\n                    line6Array.push("*");\n                } else {\n                    tempObj2["SIG" + sigFactorNumbersArray[q]] = "";\n                    line6Array.push("");\n                }\n            }\n            printArray2.push(tempObj2);\n            distinguishingSheetArray2.push(line6Array);\n        }\n\n        var lookupValue = sigFactorNumbersArray[formatDistingArrayForDownload.calledTimes];\n\n        var sortFactorValue = "Z-SCR-" + lookupValue;\n\n        // sort desc\n        var printArray3 = printArray2.sort(function(a, b) {\n            return b[sortFactorValue] - a[sortFactorValue];\n        });\n\n        for (var r = 0; r < printArray3.length; r++) {\n            printArray.push(printArray3[r]);\n        }\n\n        var lookupValue2 = formatDistingArrayForDownload.calledTimes;\n\n        var modifiedIndexValue = [\n            4,\n            7,\n            10,\n            13,\n            16,\n            19,\n            22,\n            25\n        ];\n\n        var indexer = modifiedIndexValue[lookupValue2];\n\n        distinguishingSheetArray2.sort(function(a, b) {\n            if (a[indexer] === b[indexer]) {\n                return 0;\n            } else {\n                return (b[indexer] < a[indexer]) ?\n                    -1 :\n                    1;\n            }\n        });\n\n        var finalSheetArray = distinguishingSheetArray.concat(distinguishingSheetArray2);\n\n        formatDistingArrayForDownload.calledTimes++;\n\n        return [printArray, finalSheetArray];\n    }\n\n    // todo - evenRound the sed comparison values in disting statements function\n    // todo - check to get rid of outputcomplete check - no longer needed i think by hiding download button\n\n    OUTPUT.downloadExcelOutputFile = function() {\n\n        var data = QAV.getState("dataXlsx");\n        var ws_name = QAV.getState("sheetNamesXlsx");\n        var wscols = QAV.getState("colSizes");\n\n        function sheet_from_array_of_arrays(data, opts) {\n            var ws = {};\n            var range = {\n                s: {\n                    c: 10000000,\n                    r: 10000000\n                },\n                e: {\n                    c: 0,\n                    r: 0\n                }\n            };\n            for (var R = 0; R != data.length; ++R) {\n                for (var C = 0; C != data[R].length; ++C) {\n                    if (range.s.r > R)\n                        range.s.r = R;\n                    if (range.s.c > C)\n                        range.s.c = C;\n                    if (range.e.r < R)\n                        range.e.r = R;\n                    if (range.e.c < C)\n                        range.e.c = C;\n                    var cell = {\n                        v: data[R][C]\n                    };\n                    if (cell.v === null)\n                        continue;\n                    var cell_ref = XLSX\n                        .utils\n                        .encode_cell({\n                            c: C,\n                            r: R\n                        });\n\n                    if (typeof cell.v === \'number\')\n                        cell.t = \'n\';\n                    else if (typeof cell.v === \'boolean\')\n                        cell.t = \'b\';\n                    else if (cell.v instanceof Date) {\n                        cell.t = \'n\';\n                        cell.z = XLSX.SSF._table[14];\n                        cell.v = datenum(cell.v);\n                    } else\n                        cell.t = \'s\';\n\n                    ws[cell_ref] = cell;\n                }\n            }\n            if (range.s.c < 10000000)\n                ws[\'!ref\'] = XLSX.utils.encode_range(range);\n\n            return ws;\n        }\n\n        function Workbook() {\n            if (!(this instanceof Workbook))\n                return new Workbook();\n            this.SheetNames = [];\n            this.Sheets = {};\n        }\n\n        // set column widths example\n        // var wscols = [{\n        //         wch: 6\n        //     },\n        //     {\n        //         wch: 7\n        //     },\n        //     {\n        //         wch: 10\n        //     },\n        //     {\n        //         wch: 50\n        //     }\n        // ];\n\n        var wb = new Workbook();\n\n        /* add worksheet to workbook */\n        for (var i = 0; i < ws_name.length; i++) {\n            var ws = sheet_from_array_of_arrays(data[i]);\n            ws[\'!cols\'] = wscols[i];\n            wb\n                .SheetNames\n                .push(ws_name[i]);\n            wb.Sheets[ws_name[i]] = ws;\n        }\n\n        var wbout = XLSX.write(wb, {\n            bookType: \'xlsx\',\n            bookSST: true,\n            type: \'binary\'\n        });\n\n        function s2ab(s) {\n            var buf = new ArrayBuffer(s.length);\n            var view = new Uint8Array(buf);\n            for (var i = 0; i != s.length; ++i)\n                view[i] = s.charCodeAt(i) & 0xFF;\n            return buf;\n        }\n\n        var timeStamp = UTIL.currentDate1() + "_" + UTIL.currentTime1();\n        var projectName = QAV.getState("qavProjectName");\n        var nameFile = \'KenQ_output_\' + projectName + \'_\' + timeStamp + \'.xlsx\';\n\n        saveAs(new Blob([s2ab(wbout)], {\n            type: "application/octet-stream"\n        }), nameFile);\n    };\n\n\n    OUTPUT.downloadCsvOutputFile = function() {\n        var data = QAV.getState("dataXlsx");\n\n        var spacer = ["", "", ""];\n\n        var newDataArray = [];\n        for (var i = 0, iLen = data.length; i < iLen; i++) {\n            for (var j = 0, jLen = data[i].length; j < jLen; j++) {\n                newDataArray.push(data[i][j]);\n            }\n            newDataArray.push(spacer, spacer, spacer, spacer, spacer, spacer);\n        }\n\n        newDataArray.shift();\n\n        var timeStamp = UTIL.currentDate1() + "_" + UTIL.currentTime1();\n        var projectName = QAV.getState("qavProjectName");\n        var nameFile = \'KenQ_output_\' + projectName + \'_\' + timeStamp + ".csv";\n\n        UTIL.exportToCsv(nameFile, newDataArray);\n    };\n\n}(window.OUTPUT = window.OUTPUT || {}, QAV));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9PVVRQVVQuanM/Y2JiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBLZW4tUSBBbmFseXNpc1xuLy9Db3B5cmlnaHQgKEMpIDIwMTYgU2hhd24gQmFuYXNpY2tcbi8vXG4vLyAgICBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBKU2xpbnQgZGVjbGFyYXRpb25zXG4vKiBnbG9iYWwgcmVzb3VyY2VzLCBkMywgVklFVywgZDNfc2F2ZV9zdmcsIENPUlIsIGFsYXNxbCwgd2luZG93LCBRQVYsICQsIGRvY3VtZW50LCBldmVuUm91bmQsIFVUSUwsIF8gICovXG5cbihmdW5jdGlvbihPVVRQVVQsIFFBViwgdW5kZWZpbmVkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vICAgICBET1dOTE9BRCBGVU5DVElPTlNcblxuICAgIC8vIHRvZG8gLSBidWcgZml4IGVzY2FwZSBjb2RlcyBmb3IgXCInXCIgaW4gc3RhdGVtZW50IGxpc3RpbmdcbiAgICBPVVRQVVQuZ2VuZXJhdGVPdXRwdXQgPSBmdW5jdGlvbiBwdXNoUHJvamVjdEhpc3RvcnlUb091dHB1dEFycmF5KCkge1xuICAgICAgICB2YXIgc2hlZXROYW1lcyA9IFtdO1xuICAgICAgICB2YXIgb3V0cHV0ID0gW107XG5cbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJQcm9qZWN0IE92ZXJ2aWV3XCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDIgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLlVuZG87XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MyA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJBbmFseXNpcyBDb21wbGV0ZWQgb25cIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJUb3RhbCBOdW1iZXIgb2YgU3RhdGVtZW50c1wiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQ1ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlEtc29ydCBUcmlhbmdsZSBTaGFwZVwiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQ2ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlRvdGFsIE51bWJlciBvZiBRLXNvcnRzXCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDcgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiQW5hbHlzaXMgUHJvY2Vzc1wiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQ4ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlByb2plY3QgbmFtZVwiXTtcbiAgICAgICAgdmFyIHZlcnNpb25OdW0gPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLnZlcnNpb25OdW1iZXI7XG5cbiAgICAgICAgdmFyIG5ld1NoZWV0ID0ge1xuICAgICAgICAgICAgc2hlZXRpZDogYXBwZW5kVGV4dDEsXG4gICAgICAgICAgICBoZWFkZXJzOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBzaGVldE5hbWVzLnB1c2gobmV3U2hlZXQpO1xuXG4gICAgICAgIC8vIG5vIGFsYSBkb3dubG9hZCBkYXRhXG4gICAgICAgIHZhciBzaGVldE5hbWVzWGxzeCA9IFtdO1xuICAgICAgICBzaGVldE5hbWVzWGxzeC5wdXNoKGFwcGVuZFRleHQxKTtcbiAgICAgICAgdmFyIGRhdGFYbHN4ID0gW107XG5cbiAgICAgICAgdmFyIHNldHRpbmdzID0gW107XG4gICAgICAgIHZhciBzcGFjZXIgPSBbXCJcIiwgXCJcIl07XG5cbiAgICAgICAgdmFyIHByb2plY3ROYW1lID0gUUFWLmdldFN0YXRlKFwicWF2UHJvamVjdE5hbWVcIik7XG4gICAgICAgIHZhciBwcm9qZWN0TmFtZUFycmF5ID0gW2FwcGVuZFRleHQ4LCBwcm9qZWN0TmFtZV07XG4gICAgICAgIHNldHRpbmdzLnB1c2goc3BhY2VyLCBwcm9qZWN0TmFtZUFycmF5LCBzcGFjZXIpO1xuICAgICAgICBkYXRhWGxzeC5wdXNoKHNwYWNlciwgcHJvamVjdE5hbWVBcnJheSwgc3BhY2VyKTtcblxuICAgICAgICB2YXIgdG90YWxTdGF0ZW1lbnRzID0gUUFWLmdldFN0YXRlKFwicWF2T3JpZ2luYWxTb3J0U2l6ZVwiKTtcbiAgICAgICAgdmFyIHRvdGFsTnVtYmVyU3RhdGVtZW50c0FycmF5ID0gW2FwcGVuZFRleHQ0LCB0b3RhbFN0YXRlbWVudHNdO1xuICAgICAgICBzZXR0aW5ncy5wdXNoKHRvdGFsTnVtYmVyU3RhdGVtZW50c0FycmF5LCBzcGFjZXIpO1xuICAgICAgICBkYXRhWGxzeC5wdXNoKHRvdGFsTnVtYmVyU3RhdGVtZW50c0FycmF5LCBzcGFjZXIpO1xuXG4gICAgICAgIHZhciBzb3J0VHJpYW5nbGVTaGFwZSA9IFFBVi5nZXRTdGF0ZShcInFhdlNvcnRUcmlhbmdsZVNoYXBlXCIpO1xuICAgICAgICB2YXIgc29ydFRyaWFuZ2xlU2hhcGUyID0gc29ydFRyaWFuZ2xlU2hhcGUuam9pbigpO1xuICAgICAgICB2YXIgc29ydFRyaWFuZ2xlU2hhcGVBcnJheSA9IFthcHBlbmRUZXh0NSwgc29ydFRyaWFuZ2xlU2hhcGUyXTtcbiAgICAgICAgc2V0dGluZ3MucHVzaChzb3J0VHJpYW5nbGVTaGFwZUFycmF5LCBzcGFjZXIpO1xuICAgICAgICBkYXRhWGxzeC5wdXNoKHNvcnRUcmlhbmdsZVNoYXBlQXJyYXksIHNwYWNlcik7XG5cbiAgICAgICAgdmFyIHRvdGFsU29ydHMgPSBRQVYuZ2V0U3RhdGUoXCJxYXZUb3RhbE51bWJlclNvcnRzXCIpO1xuICAgICAgICB2YXIgdG90YWxTb3J0c0FycmF5ID0gW2FwcGVuZFRleHQ2LCB0b3RhbFNvcnRzXTtcbiAgICAgICAgc2V0dGluZ3MucHVzaCh0b3RhbFNvcnRzQXJyYXksIHNwYWNlcik7XG4gICAgICAgIGRhdGFYbHN4LnB1c2godG90YWxTb3J0c0FycmF5LCBzcGFjZXIpO1xuXG4gICAgICAgIHZhciBsaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyb3RhdGlvbkhpc3RvcnlMaXN0XCIpO1xuICAgICAgICB2YXIgaXRlbXMgPSBsaXN0LmNoaWxkTm9kZXM7XG4gICAgICAgIHZhciB0ZW1wLFxuICAgICAgICAgICAgdGVtcDEsXG4gICAgICAgICAgICB0ZW1wMjtcblxuICAgICAgICBzZXR0aW5ncy5wdXNoKFthcHBlbmRUZXh0NywgXCJcIl0pO1xuICAgICAgICBkYXRhWGxzeC5wdXNoKFthcHBlbmRUZXh0NywgXCJcIl0pO1xuXG4gICAgICAgIC8vIHB1bGwgbGlzdCBpdGVtcyBhbmQgcHVzaCB0byBhcnJheSBmb3Igb3V0cHV0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaXN0QXJyYXkxID0gW107XG4gICAgICAgICAgICB0ZW1wID0gaSArIDE7XG4gICAgICAgICAgICB0ZW1wMSA9IGl0ZW1zW2ldLnRleHRDb250ZW50O1xuICAgICAgICAgICAgdGVtcDIgPSB0ZW1wMS5yZXBsYWNlKGFwcGVuZFRleHQyLCBcIlwiKTtcbiAgICAgICAgICAgIGxpc3RBcnJheTEucHVzaCh0ZW1wLCB0ZW1wMik7XG4gICAgICAgICAgICBzZXR0aW5ncy5wdXNoKGxpc3RBcnJheTEpO1xuICAgICAgICAgICAgZGF0YVhsc3gucHVzaChsaXN0QXJyYXkxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXRMYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICBzZXR0aW5ncy5wdXNoKHNwYWNlciwgW1wiTGFuZ3VhZ2VcIiwgb3V0cHV0TGFuZ3VhZ2VdKTtcbiAgICAgICAgZGF0YVhsc3gucHVzaChzcGFjZXIsIFtcIkxhbmd1YWdlXCIsIG91dHB1dExhbmd1YWdlXSk7XG5cbiAgICAgICAgdmFyIHRpbWVDb21wbGV0ZWQgPSBVVElMLmN1cnJlbnREYXRlMSgpICsgXCIgYXQgXCIgKyBVVElMLmN1cnJlbnRUaW1lMSgpO1xuICAgICAgICBzZXR0aW5ncy5wdXNoKHNwYWNlciwgW1xuICAgICAgICAgICAgYXBwZW5kVGV4dDMgKyB0aW1lQ29tcGxldGVkLFxuICAgICAgICAgICAgXCJcIlxuICAgICAgICBdKTtcblxuICAgICAgICBkYXRhWGxzeC5wdXNoKHNwYWNlciwgW1xuICAgICAgICAgICAgYXBwZW5kVGV4dDMgKyB0aW1lQ29tcGxldGVkLFxuICAgICAgICAgICAgXCJcIlxuICAgICAgICBdKTtcblxuICAgICAgICBzZXR0aW5ncy5wdXNoKHNwYWNlciwgW1wiVmVyc2lvbiBOdW1iZXI6IFwiLCB2ZXJzaW9uTnVtXSk7XG4gICAgICAgIGRhdGFYbHN4LnB1c2goc3BhY2VyLCBbXCJWZXJzaW9uIE51bWJlcjogXCIsIHZlcnNpb25OdW1dKTtcblxuICAgICAgICB2YXIgY29sU2l6ZXMgPSBbXG4gICAgICAgICAgICBbe1xuICAgICAgICAgICAgICAgIHdjaDogNDBcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB3Y2g6IDcwXG4gICAgICAgICAgICB9XVxuICAgICAgICBdO1xuXG4gICAgICAgIHZhciBvdXRwdXREYXRhID0gW107XG4gICAgICAgIG91dHB1dERhdGEucHVzaChkYXRhWGxzeCk7XG5cbiAgICAgICAgb3V0cHV0LnB1c2goc2V0dGluZ3MpO1xuICAgICAgICBwdXNoU3RhdGVtZW50c1RvT3V0cHV0QXJyYXkoc2hlZXROYW1lcywgb3V0cHV0LCBvdXRwdXREYXRhLCBzaGVldE5hbWVzWGxzeCwgY29sU2l6ZXMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwdXNoU3RhdGVtZW50c1RvT3V0cHV0QXJyYXkoc2hlZXROYW1lcywgb3V0cHV0LCBvdXRwdXREYXRhLCBzaGVldE5hbWVzWGxzeCwgY29sU2l6ZXMpIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBRQVYuZ2V0U3RhdGUoXCJxYXZDdXJyZW50U3RhdGVtZW50c1wiKTtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uU3RhdGVtZW50cztcbiAgICAgICAgdmFyIGFwcGVuZFRleHQyID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlN0YXRlbWVudCBOdW1iZXJcIl07XG5cbiAgICAgICAgdmFyIG5ld1NoZWV0ID0ge1xuICAgICAgICAgICAgc2hlZXRpZDogYXBwZW5kVGV4dDEsXG4gICAgICAgICAgICBoZWFkZXI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgc2hlZXROYW1lc1hsc3gucHVzaChhcHBlbmRUZXh0MSk7XG5cbiAgICAgICAgdmFyIG1heFN0YXRlbWVudExlbmd0aCA9IDA7XG4gICAgICAgIHZhciBhcnJheU9mU3RhdGVtZW50cyA9IFtdO1xuICAgICAgICBhcnJheU9mU3RhdGVtZW50cy5wdXNoKFtcbiAgICAgICAgICAgIFwiXCIsIFwiXCJcbiAgICAgICAgXSwgW2FwcGVuZFRleHQyLCBhcHBlbmRUZXh0MV0pO1xuICAgICAgICBmb3IgKHZhciBpaSA9IDAsIGlpTGVuID0gc3RhdGVtZW50cy5sZW5ndGg7IGlpIDwgaWlMZW47IGlpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZW1wQXJyYXkxID0gW107XG4gICAgICAgICAgICB0ZW1wQXJyYXkxLnB1c2goKGlpICsgMSksIHN0YXRlbWVudHNbaWldKTtcbiAgICAgICAgICAgIGFycmF5T2ZTdGF0ZW1lbnRzLnB1c2godGVtcEFycmF5MSk7XG4gICAgICAgICAgICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RhdGVtZW50c1tpaV0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0cmluZ0xlbmd0aCA+IG1heFN0YXRlbWVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1heFN0YXRlbWVudExlbmd0aCA9IHN0cmluZ0xlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXREYXRhLnB1c2goYXJyYXlPZlN0YXRlbWVudHMpO1xuXG4gICAgICAgIHZhciBjb2x1bW5zID0gW3tcbiAgICAgICAgICAgIHdjaDogMTBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgd2NoOiBtYXhTdGF0ZW1lbnRMZW5ndGhcbiAgICAgICAgfV07XG4gICAgICAgIGNvbFNpemVzLnB1c2goY29sdW1ucyk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcIm1heFN0YXRlbWVudExlbmd0aFwiLCBtYXhTdGF0ZW1lbnRMZW5ndGgpO1xuXG4gICAgICAgIHB1c2hTb3J0c1RvT3V0cHV0QXJyYXkoc2hlZXROYW1lcywgb3V0cHV0LCBvdXRwdXREYXRhLCBzaGVldE5hbWVzWGxzeCwgY29sU2l6ZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hTb3J0c1RvT3V0cHV0QXJyYXkoc2hlZXROYW1lcywgb3V0cHV0LCBvdXRwdXREYXRhLCBzaGVldE5hbWVzWGxzeCwgY29sU2l6ZXMpIHtcblxuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQyID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5SZXNwb25kZW50O1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDMgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLk1lYW47XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJTdGFuZGFyZCBEZXZpYXRpb25cIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJRLXNvcnRzXCJdO1xuXG4gICAgICAgIHNoZWV0TmFtZXNYbHN4LnB1c2goYXBwZW5kVGV4dDYpO1xuXG4gICAgICAgIHZhciBzb3J0c0FzTnVtYmVycyA9IFFBVi5nZXRTdGF0ZShcInNvcnRzQXNOdW1iZXJzXCIpO1xuICAgICAgICB2YXIgcmVzcG9uZGVudE5hbWVzID0gUUFWLmdldFN0YXRlKFwicWF2UmVzcG9uZGVudE5hbWVzXCIpO1xuICAgICAgICB2YXIgZGF0YUFycmF5ID0gW107XG5cbiAgICAgICAgLy8gc2V0IHVwIGNvbHVtbiB3aWR0aHNcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBbe1xuICAgICAgICAgICAgd2NoOiAxNVxuICAgICAgICB9XTtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwLCBpaUxlbiA9IHNvcnRzQXNOdW1iZXJzWzBdLmxlbmd0aCArIDI7IGlpIDwgaWlMZW47IGlpKyspIHtcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgd2NoOiA1XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb2xTaXplcy5wdXNoKGNvbHVtbnMpO1xuXG4gICAgICAgIHZhciBzdGRkZXYsXG4gICAgICAgICAgICBzdGF0ZW1lbnRTb3J0O1xuICAgICAgICAvLyBjcmVhdGUgc2hlZXQgaGVhZGVyXG4gICAgICAgIHZhciBoZWFkZXJBcnJheSA9IFthcHBlbmRUZXh0Ml07XG4gICAgICAgIGZvciAodmFyIGpqID0gMCwgampMZW4gPSBzb3J0c0FzTnVtYmVyc1swXS5sZW5ndGg7IGpqIDwgampMZW47IGpqKyspIHtcbiAgICAgICAgICAgIHN0YXRlbWVudFNvcnQgPSBcIlNcIiArIChqaiArIDEpO1xuICAgICAgICAgICAgaGVhZGVyQXJyYXkucHVzaChzdGF0ZW1lbnRTb3J0KTtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJBcnJheS5wdXNoKGFwcGVuZFRleHQzLCBhcHBlbmRUZXh0NCk7XG4gICAgICAgIGRhdGFBcnJheS5wdXNoKFtcbiAgICAgICAgICAgIFwiXCIsIFwiXCJcbiAgICAgICAgXSwgW1xuICAgICAgICAgICAgYXBwZW5kVGV4dDYsIFwiXCJcbiAgICAgICAgXSwgW1xuICAgICAgICAgICAgXCJcIiwgXCJcIlxuICAgICAgICBdLCBoZWFkZXJBcnJheSk7XG5cbiAgICAgICAgLy8gcHVzaCBpbiBzb3J0cywgbWVhbnMsIGFuZCBzdGFuZGFyZCBkZXZzXG4gICAgICAgIGZvciAodmFyIGtrID0gMCwga2tMZW4gPSBzb3J0c0FzTnVtYmVycy5sZW5ndGg7IGtrIDwga2tMZW47IGtrKyspIHtcbiAgICAgICAgICAgIHZhciBhdmVyYWdlMyA9IGV2ZW5Sb3VuZCgoVVRJTC5hdmVyYWdlKHNvcnRzQXNOdW1iZXJzW2trXSkpLCAzKTtcbiAgICAgICAgICAgIHN0ZGRldiA9IGV2ZW5Sb3VuZCgoVVRJTC5zdGFuZGFyZERldmlhdGlvbihzb3J0c0FzTnVtYmVyc1tra10pKSwgMyk7XG4gICAgICAgICAgICBzb3J0c0FzTnVtYmVyc1tra10udW5zaGlmdChyZXNwb25kZW50TmFtZXNba2tdKTtcbiAgICAgICAgICAgIHNvcnRzQXNOdW1iZXJzW2trXS5wdXNoKGF2ZXJhZ2UzLCBzdGRkZXYpO1xuICAgICAgICAgICAgZGF0YUFycmF5LnB1c2goc29ydHNBc051bWJlcnNba2tdKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXREYXRhLnB1c2goZGF0YUFycmF5KTtcblxuICAgICAgICBRQVYuc2V0U3RhdGUoXCJmcmVlRGlzdHJpYnV0aW9uQXJyYXlcIiwgZGF0YUFycmF5KTtcblxuICAgICAgICBwdXNoQ29ycmVsYXRpb25BcnJheShzaGVldE5hbWVzLCBvdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaENvcnJlbGF0aW9uQXJyYXkoc2hlZXROYW1lcywgb3V0cHV0LCBvdXRwdXREYXRhLCBzaGVldE5hbWVzWGxzeCwgY29sU2l6ZXMpIHtcblxuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQxID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIkNvcnJlbGF0aW9uIG1hdHJpeFwiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQyID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcImJldHdlZW4gUS1zb3J0c1wiXTtcblxuICAgICAgICBzaGVldE5hbWVzWGxzeC5wdXNoKGFwcGVuZFRleHQxKTtcblxuICAgICAgICB2YXIgY29ycmVsYXRpb25UYWJsZUFycmF5Rm9ybWF0dGVkMyA9IFFBVi5nZXRTdGF0ZShcImNvcnJlbGF0aW9uVGFibGVBcnJheUZvcm1hdHRlZFwiKTtcblxuICAgICAgICAvLyBnZXQgbWF4IHJlc3BvbmRlbnQgbmFtZSBsZW5ndGhcbiAgICAgICAgdmFyIHJlc3BvbmRlbnROYW1lTWF4TGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBjb3JyZWxhdGlvblRhYmxlQXJyYXlGb3JtYXR0ZWQzWzBdLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHRlbXAxID0gY29ycmVsYXRpb25UYWJsZUFycmF5Rm9ybWF0dGVkM1swXVtpXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGVtcDEgPiByZXNwb25kZW50TmFtZU1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbmRlbnROYW1lTWF4TGVuZ3RoID0gdGVtcDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbmRlbnROYW1lTWF4TGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgcmVzcG9uZGVudE5hbWVNYXhMZW5ndGggPSA1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHVwIGNvbHVtbiBzcGFjaW5nXG4gICAgICAgIHZhciBjb2x1bW5zID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gKGNvcnJlbGF0aW9uVGFibGVBcnJheUZvcm1hdHRlZDNbMF0ubGVuZ3RoICsgMSk7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgd2NoOiByZXNwb25kZW50TmFtZU1heExlbmd0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29sU2l6ZXMucHVzaChjb2x1bW5zKTtcblxuICAgICAgICBjb3JyZWxhdGlvblRhYmxlQXJyYXlGb3JtYXR0ZWQzLnVuc2hpZnQoW1xuICAgICAgICAgICAgXCJcIiwgXCJcIlxuICAgICAgICBdLCBbYXBwZW5kVGV4dDEgKyBhcHBlbmRUZXh0Ml0sIFtcIlwiLCBcIlwiXSk7XG4gICAgICAgIG91dHB1dERhdGEucHVzaChjb3JyZWxhdGlvblRhYmxlQXJyYXlGb3JtYXR0ZWQzKTtcblxuICAgICAgICBwdXNoVW5yb3RhdGVkRmFjdG9yc1RhYmxlVG9PdXRwdXRBcnJheShzaGVldE5hbWVzLCBvdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaFVucm90YXRlZEZhY3RvcnNUYWJsZVRvT3V0cHV0QXJyYXkoc2hlZXROYW1lcywgb3V0cHV0LCBvdXRwdXREYXRhLCBzaGVldE5hbWVzWGxzeCwgY29sU2l6ZXMpIHtcbiAgICAgICAgdmFyIGZhY3Rvck1hdHJpeFRyYW5zcG9zZWQsIGksIGosIGssIG0sIHRlbXAsIHRlbXBBLCB0ZW1wMSwgdGVtcDIsIHRlbXAyQTtcbiAgICAgICAgdmFyIG5ld1NoZWV0LCBleHBWYXIsIGNlbnRyb2lkc0FycmF5LCB0ZW1wT2JqLCByZXNwb25kZW50TmFtZXMsIHR5cGVPZkZhY3RvciwgbnVtRmFjdG9yc0V4dHJhY3RlZDtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJVbnJvdGF0ZWQgRmFjdG9yIE1hdHJpeFwiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQyID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5FaWdlbnZhbHVlcztcbiAgICAgICAgdmFyIGFwcGVuZFRleHQzID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5GYWN0b3I7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uUmVzcG9uZGVudDtcblxuICAgICAgICByZXNwb25kZW50TmFtZXMgPSBRQVYucmVzcG9uZGVudE5hbWVzO1xuICAgICAgICBmYWN0b3JNYXRyaXhUcmFuc3Bvc2VkID0gUUFWLmdldFN0YXRlKFwiZWlnZW5WZWNzXCIpO1xuICAgICAgICB0ZW1wID0gUUFWLmdldFN0YXRlKFwiZWlnZW5WYWx1ZXNTb3J0ZWRcIik7XG4gICAgICAgIHRlbXAyID0gUUFWLmdldFN0YXRlKFwiZWlnZW5WYWx1ZXNBc1BlcmNlbnRzXCIpO1xuICAgICAgICB0ZW1wMSA9IFFBVi5nZXRTdGF0ZShcImZhY3RvckxhYmVsc1wiKTtcbiAgICAgICAgZXhwVmFyID0gUUFWLmdldFN0YXRlKFwiZXhwVmFyQ2VudHJvaWRcIik7XG4gICAgICAgIG51bUZhY3RvcnNFeHRyYWN0ZWQgPSBRQVYuZ2V0U3RhdGUoXCJudW1GYWN0b3JzRXh0cmFjdGVkXCIpO1xuICAgICAgICB0eXBlT2ZGYWN0b3IgPSBRQVYuZ2V0U3RhdGUoXCJ0eXBlT2ZGYWN0b3JcIik7XG5cbiAgICAgICAgc2hlZXROYW1lc1hsc3gucHVzaChhcHBlbmRUZXh0MSk7XG5cbiAgICAgICAgLy8gc2V0IGV4Y2VsIGNvbHVtbiB3aWR0aHNcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBbe1xuICAgICAgICAgICAgd2NoOiAyMFxuICAgICAgICB9XTtcbiAgICAgICAgZm9yICh2YXIgaWlpID0gMCwgaWlpTGVuID0gdGVtcDEubGVuZ3RoOyBpaWkgPCBpaUxlbjsgaWlpKyspIHtcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgd2NoOiA4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb2xTaXplcy5wdXNoKGNvbHVtbnMpO1xuXG4gICAgICAgIC8vIGFkZCBsYWJlbHMgdG8gVW5yb3RhdGVkIGZhY3RvciBkYXRhXG4gICAgICAgIGlmICh0eXBlT2ZGYWN0b3IgPT09IFwiUENBXCIpIHtcblxuICAgICAgICAgICAgdGVtcDIgPSB0ZW1wMi5zbGljZSgwLCBudW1GYWN0b3JzRXh0cmFjdGVkKTtcbiAgICAgICAgICAgIHRlbXAgPSB0ZW1wLnNsaWNlKDAsIG51bUZhY3RvcnNFeHRyYWN0ZWQpO1xuXG4gICAgICAgICAgICAvLyBjb25mb3JtIFBDQSB0byBsZWdhY3kgY2VudHJvaWQgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIGZvciAobSA9IDA7IG0gPCAocmVzcG9uZGVudE5hbWVzLmxlbmd0aCAtIDEpOyBtKyspIHtcbiAgICAgICAgICAgICAgICBmYWN0b3JNYXRyaXhUcmFuc3Bvc2VkW21dLnVuc2hpZnQocmVzcG9uZGVudE5hbWVzW20gKyAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wMS51bnNoaWZ0KFwiXCIpO1xuICAgICAgICAgICAgZmFjdG9yTWF0cml4VHJhbnNwb3NlZC51bnNoaWZ0KHRlbXAxKTtcblxuICAgICAgICAgICAgLy8gYWRkIGVpZ2VudmFscyB0byBtYXRjaCBkYXRhIHN0cnVjdHVyZVxuICAgICAgICAgICAgdGVtcC51bnNoaWZ0KGFwcGVuZFRleHQyKTtcbiAgICAgICAgICAgIGZhY3Rvck1hdHJpeFRyYW5zcG9zZWQucHVzaChbXSwgdGVtcCk7XG4gICAgICAgICAgICB0ZW1wMi51bnNoaWZ0KFwiXCIpO1xuICAgICAgICAgICAgZmFjdG9yTWF0cml4VHJhbnNwb3NlZC5wdXNoKHRlbXAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZhY3Rvck1hdHJpeFRyYW5zcG9zZWQgPSBRQVYuZ2V0U3RhdGUoXCJmYWN0b3JNYXRyaXhUcmFuc3Bvc2VkXCIpO1xuICAgICAgICAgICAgZmFjdG9yTWF0cml4VHJhbnNwb3NlZC5wdXNoKGV4cFZhcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGFuZ2UgYWZ0ZXIgZGVsZXRpbmcgYWxhc3FsIGNvZGVcbiAgICAgICAgdmFyIHVucm90YXRlZEZhY3RvcnMgPSBfLmNsb25lRGVlcChmYWN0b3JNYXRyaXhUcmFuc3Bvc2VkKTtcbiAgICAgICAgdW5yb3RhdGVkRmFjdG9yc1swXVswXSA9IChhcHBlbmRUZXh0NCk7XG5cbiAgICAgICAgZm9yICh2YXIgaWkgPSAxLCBpaUxlbiA9IHVucm90YXRlZEZhY3RvcnMubGVuZ3RoIC0gMTsgaWkgPCBpaUxlbjsgaWkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgamogPSAxLCBqakxlbiA9IHVucm90YXRlZEZhY3RvcnNbaWldLmxlbmd0aDsgamogPCBqakxlbjsgamorKykge1xuICAgICAgICAgICAgICAgIHVucm90YXRlZEZhY3RvcnNbaWldW2pqXSA9IGV2ZW5Sb3VuZCh1bnJvdGF0ZWRGYWN0b3JzW2lpXVtqal0sIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVucm90YXRlZEZhY3RvcnMudW5zaGlmdChbXG4gICAgICAgICAgICBcIlwiLCBcIlwiXG4gICAgICAgIF0sIFthcHBlbmRUZXh0MV0sIFtcIlwiLCBcIlwiXSk7XG4gICAgICAgIG91dHB1dERhdGEucHVzaCh1bnJvdGF0ZWRGYWN0b3JzKTtcblxuICAgICAgICBwdXNoQ3VtdWxhdGl2ZUNvbW11bmFsaXRpZXNNYXh0cml4VG9PdXRwdXRBcnJheShzaGVldE5hbWVzLCBvdXRwdXQsIGZhY3Rvck1hdHJpeFRyYW5zcG9zZWQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaEN1bXVsYXRpdmVDb21tdW5hbGl0aWVzTWF4dHJpeFRvT3V0cHV0QXJyYXkoc2hlZXROYW1lcywgb3V0cHV0LCBmYWN0b3JNYXRyaXhUcmFuc3Bvc2VkLCBvdXRwdXREYXRhLCBzaGVldE5hbWVzWGxzeCwgY29sU2l6ZXMpIHtcbiAgICAgICAgdmFyIG5ld1NoZWV0LCBjdW11bENvbW1NYXRyaXg5LCBleHBsblZhclJvdywgcmVzcG9uZGVySGVhZGVyc1JvdztcbiAgICAgICAgdmFyIGksIGosIGssIHRlbXAxLCB0ZW1wMiwgcmVzcG9uZGVudE5hbWU7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDEgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiQ3VtdWwgQ29tbSBNYXRyaXhcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJjdW11bGF0aXZlICUgZXhwbGFpbmVkIHZhcmlhbmNlXCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLlJlc3BvbmRlbnQ7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJDdW11bGF0aXZlIENvbW11bmFsaXRpZXMgTWF0cml4XCJdO1xuXG4gICAgICAgIHNoZWV0TmFtZXNYbHN4LnB1c2goYXBwZW5kVGV4dDEpO1xuXG4gICAgICAgIC8vIGlzb2xhdGUgZGF0YVxuICAgICAgICBjdW11bENvbW1NYXRyaXg5ID0gXy5jbG9uZURlZXAoZmFjdG9yTWF0cml4VHJhbnNwb3NlZCk7XG5cbiAgICAgICAgLy8gc2V0IGV4Y2VsIGNvbHVtbiB3aWR0aHNcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBbe1xuICAgICAgICAgICAgd2NoOiAzMFxuICAgICAgICB9XTtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwLCBpaUxlbiA9IGN1bXVsQ29tbU1hdHJpeDlbMF0ubGVuZ3RoOyBpaSA8IGlpTGVuOyBpaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHdjaDogOFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29sU2l6ZXMucHVzaChjb2x1bW5zKTtcblxuICAgICAgICBleHBsblZhclJvdyA9IGN1bXVsQ29tbU1hdHJpeDkucG9wKCk7XG4gICAgICAgIC8vIGdldCByaWQgb2YgZWlnZW52YWx1ZSByb3dcbiAgICAgICAgY3VtdWxDb21tTWF0cml4OS5wb3AoKTtcbiAgICAgICAgcmVzcG9uZGVySGVhZGVyc1JvdyA9IGN1bXVsQ29tbU1hdHJpeDkuc2hpZnQoKTtcbiAgICAgICAgLy8gYWRkIHJlc3BvbmRlbnQgbmFtZXMgYW5kIGRvIHJvdW5kaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjdW11bENvbW1NYXRyaXg5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXNwb25kZW50TmFtZSA9IGN1bXVsQ29tbU1hdHJpeDlbaV0uc2hpZnQoKTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdW11bENvbW1NYXRyaXg5W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcDEgPSBjdW11bENvbW1NYXRyaXg5W2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICBjdW11bENvbW1NYXRyaXg5W2ldW2pdID0gZXZlblJvdW5kKCh0ZW1wMSAqIHRlbXAxKSwgNCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcDEgPSBjdW11bENvbW1NYXRyaXg5W2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICBjdW11bENvbW1NYXRyaXg5W2ldW2pdID0gZXZlblJvdW5kKCgodGVtcDEgKiB0ZW1wMSkgKyBjdW11bENvbW1NYXRyaXg5W2ldWyhqIC0gMSldKSwgNCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VtdWxDb21tTWF0cml4OVtpXS51bnNoaWZ0KHJlc3BvbmRlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjdW11bENvbW1NYXRyaXg5LnVuc2hpZnQocmVzcG9uZGVySGVhZGVyc1Jvdyk7XG4gICAgICAgIC8vIGFkZCBjdW11bGF0aXZlIGV4cGxhaW5lZCB2YXJpYW5jZVxuICAgICAgICBleHBsblZhclJvdy5zaGlmdCgpO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZXhwbG5WYXJSb3cubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7fSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wMiA9IGV4cGxuVmFyUm93W2tdO1xuICAgICAgICAgICAgICAgIGV4cGxuVmFyUm93W2tdID0gZXhwbG5WYXJSb3dba10gKyBleHBsblZhclJvd1soayAtIDEpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBsblZhclJvdy51bnNoaWZ0KGFwcGVuZFRleHQyKTtcbiAgICAgICAgY3VtdWxDb21tTWF0cml4OS5wdXNoKGV4cGxuVmFyUm93KTtcbiAgICAgICAgb3V0cHV0LnB1c2goY3VtdWxDb21tTWF0cml4OSk7XG4gICAgICAgIC8vIGZvcm1hdCBmb3IgZXhjZWxcbiAgICAgICAgY3VtdWxDb21tTWF0cml4OVswXVswXSA9IGFwcGVuZFRleHQ0O1xuICAgICAgICBjdW11bENvbW1NYXRyaXg5LnVuc2hpZnQoW1xuICAgICAgICAgICAgXCJcIiwgXCJcIlxuICAgICAgICBdLCBbYXBwZW5kVGV4dDVdLCBbXCJcIiwgXCJcIl0pO1xuICAgICAgICBvdXRwdXREYXRhLnB1c2goY3VtdWxDb21tTWF0cml4OSk7XG5cbiAgICAgICAgcHVzaFJvdGF0ZWRGYWN0b3JzQXJyYXlUb091dHB1dEFycmF5KHNoZWV0TmFtZXMsIG91dHB1dCwgb3V0cHV0RGF0YSwgc2hlZXROYW1lc1hsc3gsIGNvbFNpemVzKTtcbiAgICB9XG5cbiAgICAvLyAgQUtBIGZhY3RvciBsb2FkaW5ncyB0YWJsZVxuICAgIGZ1bmN0aW9uIHB1c2hSb3RhdGVkRmFjdG9yc0FycmF5VG9PdXRwdXRBcnJheShzaGVldE5hbWVzLCBvdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFFBVi5nZXRTdGF0ZShcInJlc3VsdHNcIik7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDEgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLkxvYWRpbmdzO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDIgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLkZsYWdnZWQ7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MyA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJGYWN0b3IgTWF0cml4IHdpdGggRGVmaW5pbmcgU29ydHMgRmxhZ2dlZFwiXTtcblxuICAgICAgICBzaGVldE5hbWVzWGxzeC5wdXNoKGFwcGVuZFRleHQxKTtcblxuICAgICAgICB2YXIgZm9ybWF0dGVkUmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgakxvb3BMZW4gPSByZXN1bHRzWzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIGksIGo7XG4gICAgICAgIHZhciBpTG9vcExlbiA9IHJlc3VsdHMubGVuZ3RoO1xuICAgICAgICB2YXIgdGVtcDtcbiAgICAgICAgdmFyIHRlbXBBcnJheSA9IFtdO1xuXG4gICAgICAgIHZhciBoZWFkZXJSb3dGcm9tQ3VycmVudFRhYmxlID0gJCgnI2ZhY3RvclJvdGF0aW9uVGFibGUyIHRoZWFkIHRyJylbMF07XG4gICAgICAgICQuZWFjaChoZWFkZXJSb3dGcm9tQ3VycmVudFRhYmxlLmNlbGxzLCBmdW5jdGlvbihpLCB2KSB7XG4gICAgICAgICAgICB2YXIgdGVtcDUgPSB2LnRleHRDb250ZW50O1xuICAgICAgICAgICAgdGVtcEFycmF5LnB1c2godGVtcDUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9ybWF0dGVkUmVzdWx0cy5wdXNoKHRlbXBBcnJheSk7XG5cbiAgICAgICAgLy8gcmVzb3J0IHRoZSBhcnJheVxuICAgICAgICByZXN1bHRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaUxvb3BMZW47IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMb29wTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gcmVzdWx0c1tpXVtqXTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcCA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXVtqXSA9IGFwcGVuZFRleHQyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGVtcCA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV1bal0gPSBcIlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaiAhPT0gMCAmJiAhaXNOYU4odGVtcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXVtqXSA9IGV2ZW5Sb3VuZCgodGVtcCksIDQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcm1hdHRlZFJlc3VsdHMucHVzaChyZXN1bHRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwVmFyID0gUUFWLmdldFN0YXRlKFwiZXhwVmFyXCIpO1xuICAgICAgICBmb3JtYXR0ZWRSZXN1bHRzLnB1c2goZXhwVmFyKTtcblxuICAgICAgICAvLyBzZXQgZXhjZWwgY29sdW1uIHdpZHRoc1xuICAgICAgICB2YXIgY29sdW1ucyA9IFt7XG4gICAgICAgICAgICB3Y2g6IDIwXG4gICAgICAgIH1dO1xuICAgICAgICBmb3IgKHZhciBpaSA9IDAsIGlpTGVuID0gZm9ybWF0dGVkUmVzdWx0c1swXS5sZW5ndGg7IGlpIDwgaWlMZW47IGlpKyspIHtcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgd2NoOiA4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb2xTaXplcy5wdXNoKGNvbHVtbnMpO1xuXG4gICAgICAgIG91dHB1dC5wdXNoKGZvcm1hdHRlZFJlc3VsdHMpO1xuXG4gICAgICAgIGZvcm1hdHRlZFJlc3VsdHMudW5zaGlmdChbXG4gICAgICAgICAgICBcIlwiLCBcIlwiXG4gICAgICAgIF0sIFthcHBlbmRUZXh0M10sIFtcIlwiLCBcIlwiXSk7XG4gICAgICAgIG91dHB1dERhdGEucHVzaChmb3JtYXR0ZWRSZXN1bHRzKTtcbiAgICAgICAgcHVzaEZyZWVEaXN0cmlidXRpb25EYXRhVG9PdXRwdXRBcnJheShzaGVldE5hbWVzLCBvdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaEZyZWVEaXN0cmlidXRpb25EYXRhVG9PdXRwdXRBcnJheShzaGVldE5hbWVzLCBvdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcykge1xuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQxID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIkZyZWUgRGlzdFwiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQyID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5SZXNwb25kZW50O1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDMgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLk1lYW47XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJTdGFuZGFyZCBEZXZpYXRpb25cIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJGcmVlIERpc3RyaWJ1dGlvbiBEYXRhIFJlc3VsdHNcIl07XG4gICAgICAgIHZhciBxYXZDdXJyZW50U3RhdGVtZW50cyA9IFFBVi5nZXRTdGF0ZShcInFhdkN1cnJlbnRTdGF0ZW1lbnRzXCIpO1xuXG4gICAgICAgIHZhciBuZXdTaGVldCA9IHtcbiAgICAgICAgICAgIHNoZWV0aWQ6IGFwcGVuZFRleHQxLFxuICAgICAgICAgICAgaGVhZGVyczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgc2hlZXROYW1lcy5wdXNoKG5ld1NoZWV0KTtcbiAgICAgICAgc2hlZXROYW1lc1hsc3gucHVzaChhcHBlbmRUZXh0MSk7XG5cbiAgICAgICAgdmFyIGNvbHVtbnMgPSBbe1xuICAgICAgICAgICAgd2NoOiAyMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB3Y2g6IDEwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHdjaDogMTBcbiAgICAgICAgfV07XG4gICAgICAgIGNvbFNpemVzLnB1c2goY29sdW1ucyk7XG5cbiAgICAgICAgdmFyIGZyZWVEaXN0cmlidXRpb25BcnJheSA9IFFBVi5nZXRTdGF0ZShcImZyZWVEaXN0cmlidXRpb25BcnJheVwiKTtcblxuICAgICAgICBmcmVlRGlzdHJpYnV0aW9uQXJyYXkgPSBmcmVlRGlzdHJpYnV0aW9uQXJyYXkuc2xpY2UoMyk7XG4gICAgICAgIHZhciBmcmVlRGlzdHJpYnV0aW9uRGF0YSA9IFtdO1xuICAgICAgICB2YXIgY3V0TGVuZ3RoID0gZnJlZURpc3RyaWJ1dGlvbkFycmF5WzBdLmxlbmd0aCAtIDM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gZnJlZURpc3RyaWJ1dGlvbkFycmF5Lmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHRlbXBDdXQgPSBmcmVlRGlzdHJpYnV0aW9uQXJyYXlbaV0uc3BsaWNlKDEsIGN1dExlbmd0aCk7XG4gICAgICAgICAgICBmcmVlRGlzdHJpYnV0aW9uRGF0YS5wdXNoKGZyZWVEaXN0cmlidXRpb25BcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnJlZURpc3RyaWJ1dGlvbkRhdGEudW5zaGlmdChbXCJcIiwgXCJcIl0sIFthcHBlbmRUZXh0NV0sIFtcIlwiLCBcIlwiXSk7XG4gICAgICAgIG91dHB1dERhdGEucHVzaChmcmVlRGlzdHJpYnV0aW9uRGF0YSk7XG4gICAgICAgIHB1c2hGYWN0b3JzVG9PdXRwdXRBcnJheShzaGVldE5hbWVzLCBvdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaEZhY3RvcnNUb091dHB1dEFycmF5KHNoZWV0TmFtZXMsIG91dHB1dCwgb3V0cHV0RGF0YSwgc2hlZXROYW1lc1hsc3gsIGNvbFNpemVzKSB7XG5cbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJTb3J0cyBXZWlnaHRcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJTb3J0cyBDb3JyXCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDMgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiU3RhdGVtZW50IE51bWJlclwiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQ0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5TdGF0ZW1lbnQ7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJaLXNjb3JlXCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDYgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiU29ydCBWYWx1ZXNcIl07XG5cbiAgICAgICAgdmFyIGFuYWx5c2lzT3V0cHV0MiA9IFFBVi5nZXRTdGF0ZShcImFuYWx5c2lzT3V0cHV0XCIpO1xuICAgICAgICB2YXIgYW5hbHlzaXNPdXRwdXQgPSBfLmNsb25lRGVlcChhbmFseXNpc091dHB1dDIpO1xuICAgICAgICB2YXIgc2lnU29ydHNBcnJheSA9IFFBVi5nZXRTdGF0ZShcInNpZ1NvcnRzQXJyYXlcIik7XG4gICAgICAgIHZhciBzb3J0c0FzTnVtYmVycyA9IFFBVi5nZXRTdGF0ZShcInNvcnRzQXNOdW1iZXJzXCIpO1xuICAgICAgICB2YXIgcWF2UmVzcG9uZGVudE5hbWVzID0gUUFWLmdldFN0YXRlKFwicWF2UmVzcG9uZGVudE5hbWVzXCIpO1xuICAgICAgICB2YXIgY29ycmVsYXRpb25UYWJsZUFycmF5Rm9ybWF0dGVkMiA9IFFBVi5nZXRTdGF0ZShcImNvcnJlbGF0aW9uVGFibGVBcnJheUZvcm1hdHRlZFwiKTtcbiAgICAgICAgdmFyIHVzZXJTZWxlY3RlZEZhY3RvcnMgPSBRQVYuZ2V0U3RhdGUoXCJ1c2VyU2VsZWN0ZWRGYWN0b3JzXCIpO1xuICAgICAgICB2YXIgc29ydFdlaWdodHMgPSBRQVYuZ2V0U3RhdGUoXCJzb3J0V2VpZ2h0c1wiKTtcblxuICAgICAgICAvLyB0byBob2xkIGRhdGEgaW4gUUFWIHVudGlsIGxhdGVyIGluc2VydGlvbiBpbnRvIG91dHB1dCByZXN1bHRzIC0gdG8gbWF0Y2ggUFFNZXRob2Qgb3JkZXJcbiAgICAgICAgdmFyIGZhY3RvcldlaWdodEZhY3RvckFycmF5SG9sZGVyID0gW107XG4gICAgICAgIHZhciBtaW5pQ29ycmVsYXRpb25BcnJheUhvbGRlciA9IFtdO1xuICAgICAgICB2YXIgc3luRmFjdG9yQXJyYXkxSG9sZGVyID0gW107XG4gICAgICAgIHZhciBzeW5GYWN0b3JBcnJheTEgPSBbXTtcbiAgICAgICAgdmFyIHNoZWV0TmFtZXNIb2xkZXIxID0gW107XG4gICAgICAgIHZhciBzaGVldE5hbWVzSG9sZGVyMiA9IFtdO1xuICAgICAgICB2YXIgc2hlZXROYW1lc0hvbGRlcjMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuYWx5c2lzT3V0cHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcDEgPSB7fTtcbiAgICAgICAgICAgIHZhciB0ZW1wMWEgPSB7fTtcbiAgICAgICAgICAgIHZhciB0ZW1wMWIgPSB7fTtcblxuICAgICAgICAgICAgdGVtcDFhLnNoZWV0aWQgPSBzaWdTb3J0c0FycmF5W2ldW1wiRmFjdG9yIE51bWJlclwiXSArIGFwcGVuZFRleHQxO1xuICAgICAgICAgICAgdGVtcDFhLmhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICBzaGVldE5hbWVzSG9sZGVyMS5wdXNoKHRlbXAxYSk7XG5cbiAgICAgICAgICAgIHRlbXAxYi5zaGVldGlkID0gc2lnU29ydHNBcnJheVtpXVtcIkZhY3RvciBOdW1iZXJcIl0gKyBhcHBlbmRUZXh0MjtcbiAgICAgICAgICAgIHRlbXAxYi5oZWFkZXIgPSB0cnVlO1xuICAgICAgICAgICAgc2hlZXROYW1lc0hvbGRlcjIucHVzaCh0ZW1wMWIpO1xuXG4gICAgICAgICAgICB0ZW1wMS5zaGVldGlkID0gc2lnU29ydHNBcnJheVtpXVtcIkZhY3RvciBOdW1iZXJcIl07XG4gICAgICAgICAgICB0ZW1wMS5oZWFkZXIgPSB0cnVlO1xuICAgICAgICAgICAgc2hlZXROYW1lc0hvbGRlcjMucHVzaCh0ZW1wMSk7XG4gICAgICAgIH1cblxuICAgICAgICBRQVYuc2V0U3RhdGUoXCJzaGVldE5hbWVzSG9sZGVyMVwiLCBzaGVldE5hbWVzSG9sZGVyMSk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInNoZWV0TmFtZXNIb2xkZXIyXCIsIHNoZWV0TmFtZXNIb2xkZXIyKTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwic2hlZXROYW1lc0hvbGRlcjNcIiwgc2hlZXROYW1lc0hvbGRlcjMpO1xuXG4gICAgICAgIC8vIHB1bGwgcmF3IHNvcnRzIGZvciBmYWN0b3IgdGFibGVzXG4gICAgICAgIHZhciByYXdTb3J0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHNpZ1NvcnRzQXJyYXkubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHZhciB0ZW1wQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgc2lnU29ydHNBcnJheVtwXS5TaWdTb3J0cy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgIHZhciBzaWdTb3J0ID0gc2lnU29ydHNBcnJheVtwXS5TaWdTb3J0c1tyXTtcbiAgICAgICAgICAgICAgICB2YXIgcmF3U29ydEluZGV4ID0gcWF2UmVzcG9uZGVudE5hbWVzLmluZGV4T2Yoc2lnU29ydCk7XG4gICAgICAgICAgICAgICAgdmFyIHJhd1NvcnRWYWx1ZXMgPSBzb3J0c0FzTnVtYmVyc1tyYXdTb3J0SW5kZXhdO1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheS5wdXNoKHJhd1NvcnRWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmF3U29ydHMucHVzaCh0ZW1wQXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yIGVhY2ggZmFjdG9yIGNoZWNrIGdldCBhIHNpZ1NvcnQgKGlmIGFub3RoZXIgcmVtYWlucylcbiAgICAgICAgLy8gZ2V0IHRoZSByYXcgc29ydCBmb3IgdGhhdCBzcGVjaWZpYyBzaWdTb3J0XG4gICAgICAgIC8vIHJlYWQgdGhhdCBzaWdTb3J0cyByYXcgc29ydCBkYXRhIGludG8gdGVzdE9ialxuICAgICAgICB2YXIgY29tcG9zaXRlRmFjdG9yTWFzdGVyQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIG1hdGNoQ291bnQgPSBbXTtcbiAgICAgICAgLy8gIEZPUiBFQUNIIEZBQ1RPUiBMT09QXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW5hbHlzaXNPdXRwdXQubGVuZ3RoOyBqKyspIHtcblxuICAgICAgICAgICAgLy8gRkFDVE9SIFdFSUdIVFMgVEFCTEVTIFNUQVJUUyBGUk9NIEhFUkVcbiAgICAgICAgICAgIHZhciBmYWN0b3JXZWlnaHRGYWN0b3JBcnJheSA9IFtcbiAgICAgICAgICAgICAgICBbXCJRLVNvcnRcIiwgXCJXZWlnaHRcIl1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgZmFjdG9yV2VpZ2h0TmFtZSA9IHVzZXJTZWxlY3RlZEZhY3RvcnNbal07XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHNvcnRXZWlnaHRzLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvcldlaWdodFRlbXBBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChzb3J0V2VpZ2h0c1t3XVswXSA9PT0gZmFjdG9yV2VpZ2h0TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWN0b3JXZWlnaHRUZW1wQXJyYXkucHVzaChzb3J0V2VpZ2h0c1t3XVsxXSwgc29ydFdlaWdodHNbd11bM10pO1xuICAgICAgICAgICAgICAgICAgICBmYWN0b3JXZWlnaHRGYWN0b3JBcnJheS5wdXNoKGZhY3RvcldlaWdodFRlbXBBcnJheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3V0cHV0LnB1c2goZmFjdG9yV2VpZ2h0RmFjdG9yQXJyYXkpO1xuICAgICAgICAgICAgZmFjdG9yV2VpZ2h0RmFjdG9yQXJyYXlIb2xkZXIucHVzaChmYWN0b3JXZWlnaHRGYWN0b3JBcnJheSk7XG5cblxuICAgICAgICAgICAgLy8gRkFDVE9SIFNDT1JFIE1JTkkgQ09SUkVMQVRJT04gVEFCTEVTIFNUQVJUUyBGUk9NIEhFUkVcblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHNpZ1NvcnRzQXJyYXkgdG8gZ2V0IHRoaXMgZmFjdG9yJ3Mgc2lnIFNvcnRzXG4gICAgICAgICAgICB2YXIgbWluaVNvcnRzSUQgPSB1c2VyU2VsZWN0ZWRGYWN0b3JzW2pdO1xuICAgICAgICAgICAgdmFyIG1pbmlDb3JyZWxhdGlvbkZhY3RvcnNBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBzaWdTb3J0c0FycmF5Lmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ1NvcnRzQXJyYXlbdF1bXCJGYWN0b3IgTnVtYmVyXCJdID09PSBtaW5pU29ydHNJRCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5pQ29ycmVsYXRpb25GYWN0b3JzQXJyYXkucHVzaChzaWdTb3J0c0FycmF5W3RdLlNpZ1NvcnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHB1bGwgY29ycmVsYXRpb25zIGZyb20gdGFibGVcbiAgICAgICAgICAgIHZhciBtaW5pQ29ycmVsYXRpb25BcnJheSA9IFtdO1xuICAgICAgICAgICAgdmFyIG1pbmlDb3JyZWxhdGlvbkhlYWRlckFycmF5ID0gW1wiUS1Tb3J0XCJdO1xuICAgICAgICAgICAgdmFyIG1pbmlDb3JyZWxhdGlvbkhlYWRlckluZGV4ID0gY29ycmVsYXRpb25UYWJsZUFycmF5Rm9ybWF0dGVkMlswXTtcblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBzaWcgU29ydHNcbiAgICAgICAgICAgIGZvciAodmFyIHQzID0gMDsgdDMgPCBtaW5pQ29ycmVsYXRpb25GYWN0b3JzQXJyYXlbMF0ubGVuZ3RoOyB0MysrKSB7XG5cbiAgICAgICAgICAgICAgICBtaW5pQ29ycmVsYXRpb25IZWFkZXJBcnJheS5wdXNoKG1pbmlDb3JyZWxhdGlvbkZhY3RvcnNBcnJheVswXVt0M10pO1xuXG4gICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGNvcnJlbGF0aW9uIHRhYmxlIGFycmF5XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdDEgPSAwOyB0MSA8IGNvcnJlbGF0aW9uVGFibGVBcnJheUZvcm1hdHRlZDIubGVuZ3RoOyB0MSsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBBcnJheVQxID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCByb3cgZm9yICB0aGUgc2lnIHNvcnRzLCB0aGVuIHB1c2ggZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ycmVsYXRpb25UYWJsZUFycmF5Rm9ybWF0dGVkMlt0MV1bMF0gPT09IG1pbmlDb3JyZWxhdGlvbkZhY3RvcnNBcnJheVswXVt0M10pIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCBuYW1lIGludG8gbGVmdCBjb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBBcnJheVQxLnB1c2gobWluaUNvcnJlbGF0aW9uRmFjdG9yc0FycmF5WzBdW3QzXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN5Y2xlIHRocm91Z2ggcm93IHRvIGZpbmQgcHVzaCBkYXRhIGZvciBhbGwgc2lnU29ydHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQyID0gMDsgdDIgPCBtaW5pQ29ycmVsYXRpb25GYWN0b3JzQXJyYXlbMF0ubGVuZ3RoOyB0MisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbWluaUNvcnJlbGF0aW9uSGVhZGVySW5kZXguaW5kZXhPZihtaW5pQ29ycmVsYXRpb25GYWN0b3JzQXJyYXlbMF1bdDJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQXJyYXlUMS5wdXNoKGNvcnJlbGF0aW9uVGFibGVBcnJheUZvcm1hdHRlZDJbdDFdW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pQ29ycmVsYXRpb25BcnJheS5wdXNoKHRlbXBBcnJheVQxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWluaUNvcnJlbGF0aW9uQXJyYXkudW5zaGlmdChtaW5pQ29ycmVsYXRpb25IZWFkZXJBcnJheSk7XG5cbiAgICAgICAgICAgIC8vIG91dHB1dC5wdXNoKG1pbmlDb3JyZWxhdGlvbkFycmF5KTtcbiAgICAgICAgICAgIG1pbmlDb3JyZWxhdGlvbkFycmF5SG9sZGVyLnB1c2gobWluaUNvcnJlbGF0aW9uQXJyYXkpO1xuXG4gICAgICAgICAgICAvLyBTWU5USEVUSUMgRkFDVE9SIE9VVFBVVCBTVEFSVFMgRlJPTSBIRVJFXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGFycmF5cyB0byBvYmplY3RcbiAgICAgICAgICAgIHZhciBzeW5GYWN0b3JBcnJheSA9IFtdO1xuICAgICAgICAgICAgdmFyIG1hdGNoQ291bnRBcnJheSA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvbXBvc2l0ZUZhY3RvckFycmF5ID0gW107XG5cbiAgICAgICAgICAgIC8vIHNpbXVsIGNhbGMgdHdvIG1kIGFycmF5cyAtIG9uZSBmb3IgdGFibGVzLCBvbmUgZm9yIG1hdGNoIGNvdW50c1xuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDAsIG1MZW4gPSBhbmFseXNpc091dHB1dFswXS5sZW5ndGg7IG0gPCBtTGVuOyBtKyspIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIGFuZCBlbXB0eSB0ZW1wIG9ianMgYW5kIGFycmF5c1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wT2JqID0ge307XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBPYmo1ID0ge307XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoU29ydFZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nQ291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvc2l0ZUZhY3RvclRlbXBBcnJheSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdGVtcE9iajUuaW5kZXhlciA9IGFuYWx5c2lzT3V0cHV0W2pdW21dLnN0YXRlbWVudDtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqNS5tYXRjaFNvcnRWYWx1ZSA9IGFuYWx5c2lzT3V0cHV0W2pdW21dLnNvcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqNS56U2NvcmUgPSBhbmFseXNpc091dHB1dFtqXVttXS56U2NvcmU7XG4gICAgICAgICAgICAgICAgdmFyIHRlc3RWYWx1ZSA9IGFuYWx5c2lzT3V0cHV0W2pdW21dLnNvcnRWYWx1ZTtcblxuICAgICAgICAgICAgICAgIHRlbXBPYmpbYXBwZW5kVGV4dDNdID0gYW5hbHlzaXNPdXRwdXRbal1bbV0uc3RhdGVtZW50O1xuICAgICAgICAgICAgICAgIHRlbXBPYmpbYXBwZW5kVGV4dDRdID0gYW5hbHlzaXNPdXRwdXRbal1bbV0uc29ydFN0YXRlbWVudDtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqW2FwcGVuZFRleHQ1XSA9IGFuYWx5c2lzT3V0cHV0W2pdW21dLnpTY29yZTtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqW2FwcGVuZFRleHQ2XSA9IGFuYWx5c2lzT3V0cHV0W2pdW21dLnNvcnRWYWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCB1cCBuZXcgb3V0cHV0IGFycmF5XG4gICAgICAgICAgICAgICAgY29tcG9zaXRlRmFjdG9yVGVtcEFycmF5LnB1c2goYW5hbHlzaXNPdXRwdXRbal1bbV0uc3RhdGVtZW50LCBhbmFseXNpc091dHB1dFtqXVttXS5zb3J0U3RhdGVtZW50LCBhbmFseXNpc091dHB1dFtqXVttXS56U2NvcmUsIGFuYWx5c2lzT3V0cHV0W2pdW21dLnNvcnRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMCwgc0xlbiA9IHJhd1NvcnRzW2pdLmxlbmd0aDsgcyA8IHNMZW47IHMrKykge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wT2JqW1wiUmF3IFNvcnQgXCIgKyBzaWdTb3J0c0FycmF5W2pdLlNpZ1NvcnRzW3NdXSA9IHJhd1NvcnRzW2pdW3NdW21dO1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gbmV3IG91dHB1dCBhcnJheVxuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVGYWN0b3JUZW1wQXJyYXkucHVzaChyYXdTb3J0c1tqXVtzXVttXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoU29ydFZhbHVlLnB1c2gocmF3U29ydHNbal1bc11bbV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVzdFZhbHVlID09PSByYXdTb3J0c1tqXVtzXVttXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIHB1c2hpbmcgaW4gcmF3IHNvcnQgdmFsc1xuICAgICAgICAgICAgICAgIHRlbXBPYmo1Lm1hdGNoaW5nQ291bnRzID0gbWF0Y2hpbmdDb3VudGVyO1xuICAgICAgICAgICAgICAgIHRlbXBPYmo1Lm1hdGNoaW5nQ291bnRzUGVyY2VudCA9IHBhcnNlSW50KChtYXRjaGluZ0NvdW50ZXIgLyBzTGVuICogMTAwKSwgMTApO1xuICAgICAgICAgICAgICAgIC8vIHRlbXBPYmo1Lm1hdGNoU29ydFZhbHVlID0gbWF0Y2hTb3J0VmFsdWU7XG4gICAgICAgICAgICAgICAgbWF0Y2hDb3VudEFycmF5LnB1c2godGVtcE9iajUpO1xuICAgICAgICAgICAgICAgIHN5bkZhY3RvckFycmF5LnB1c2godGVtcE9iaik7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHRvIG5ldyBvdXRwdXQgYXJyYXlcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVGYWN0b3JBcnJheS5wdXNoKGNvbXBvc2l0ZUZhY3RvclRlbXBBcnJheSk7XG4gICAgICAgICAgICB9IC8vIHB1c2hpbmcgaW4gcS1zb3J0IGxvYWRpbmdzXG4gICAgICAgICAgICAvLyBhZGQgdG8gbmV3IG91dHB1dCBNYXN0ZXIgYXJyYXlcbiAgICAgICAgICAgIGNvbXBvc2l0ZUZhY3Rvck1hc3RlckFycmF5LnB1c2goY29tcG9zaXRlRmFjdG9yQXJyYXkpO1xuICAgICAgICAgICAgbWF0Y2hDb3VudC5wdXNoKG1hdGNoQ291bnRBcnJheSk7IC8vIHB1c2ggaW4gZmFjdG9yIGFycmF5c1xuICAgICAgICAgICAgc3luRmFjdG9yQXJyYXkxID0gc3luRmFjdG9yQXJyYXkuc2xpY2UoMCk7XG5cbiAgICAgICAgICAgIHN5bkZhY3RvckFycmF5MS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYlthcHBlbmRUZXh0NV0gPT09IGFbYXBwZW5kVGV4dDVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiW2FwcGVuZFRleHQzXSAtIGFbYXBwZW5kVGV4dDNdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiW2FwcGVuZFRleHQ1XSAtIGFbYXBwZW5kVGV4dDVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBvdXRwdXQucHVzaChzeW5GYWN0b3JBcnJheTEpO1xuICAgICAgICAgICAgc3luRmFjdG9yQXJyYXkxSG9sZGVyLnB1c2goc3luRmFjdG9yQXJyYXkxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFFBVi5zZXRTdGF0ZShcImZhY3RvcldlaWdodEZhY3RvckFycmF5SG9sZGVyXCIsIGZhY3RvcldlaWdodEZhY3RvckFycmF5SG9sZGVyKTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwibWluaUNvcnJlbGF0aW9uQXJyYXlIb2xkZXJcIiwgbWluaUNvcnJlbGF0aW9uQXJyYXlIb2xkZXIpO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJzeW5GYWN0b3JBcnJheTFIb2xkZXJcIiwgc3luRmFjdG9yQXJyYXkxSG9sZGVyKTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwibWF0Y2hDb3VudFwiLCBtYXRjaENvdW50KTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwiY29tcG9zaXRlRmFjdG9yTWFzdGVyQXJyYXlcIiwgY29tcG9zaXRlRmFjdG9yTWFzdGVyQXJyYXkpO1xuXG4gICAgICAgIHB1c2hGYWN0b3JTY29yZUNvbXBhcmlzb25SYW5rc1RhYmxlVG9PdXRwdXRBcnJheShzaGVldE5hbWVzLCBvdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaEZhY3RvclNjb3JlQ29tcGFyaXNvblJhbmtzVGFibGVUb091dHB1dEFycmF5KHNoZWV0TmFtZXMsIG91dHB1dCwgb3V0cHV0RGF0YSwgc2hlZXROYW1lc1hsc3gsIGNvbFNpemVzKSB7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDEgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiRmFjdG9yIFNjb3JlIFJhbmtzXCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDIgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLkZhY3RvcnM7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MyA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJTdGF0ZW1lbnQgTnVtYmVyXCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLlN0YXRlbWVudDtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQ1ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlotc2NvcmVcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJGYWN0b3IgU2NvcmVzIHdpdGggQ29ycmVzcG9uZGluZyBSYW5rc1wiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQ3ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5SYW5rO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDggPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiU29ydCBWYWx1ZXNcIl07XG5cbiAgICAgICAgdmFyIHN5bkZhY3RvckFycmF5MSA9IFFBVi5nZXRTdGF0ZShcInN5bkZhY3RvckFycmF5MUhvbGRlclwiKTtcbiAgICAgICAgdmFyIHVzZXJTZWxlY3RlZEZhY3RvcnMgPSBRQVYuZ2V0U3RhdGUoXCJ1c2VyU2VsZWN0ZWRGYWN0b3JzXCIpO1xuICAgICAgICB2YXIgdGVtcEFycmF5MSxcbiAgICAgICAgICAgIHJhbmtWYWx1ZSxcbiAgICAgICAgICAgIHJhbmtpbmdUZW1wQXJyYXk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRSYW5raW5nQXJyYXkgPSBbXTtcblxuICAgICAgICAvLyB2YXIgbmV3U2hlZXQgPSB7XG4gICAgICAgIC8vICAgICBzaGVldGlkOiBhcHBlbmRUZXh0MSxcbiAgICAgICAgLy8gICAgIGhlYWRlcnM6IGZhbHNlXG4gICAgICAgIC8vIH07XG4gICAgICAgIC8vIHNoZWV0TmFtZXMucHVzaChuZXdTaGVldCk7XG4gICAgICAgIHNoZWV0TmFtZXNYbHN4LnB1c2goYXBwZW5kVGV4dDEpO1xuXG4gICAgICAgIHZhciBtYXhTdGF0ZW1lbnRMZW5ndGggPSBRQVYuZ2V0U3RhdGUoXCJtYXhTdGF0ZW1lbnRMZW5ndGhcIik7XG4gICAgICAgIHZhciBjb2x1bW5zID0gW3tcbiAgICAgICAgICAgIHdjaDogOFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB3Y2g6IG1heFN0YXRlbWVudExlbmd0aFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB3Y2g6IDhcbiAgICAgICAgfV07XG4gICAgICAgIGZvciAodmFyIHNzID0gMCwgc3NMZW4gPSAodXNlclNlbGVjdGVkRmFjdG9ycy5sZW5ndGggKiAyKTsgc3MgPCBzc0xlbjsgc3MrKykge1xuICAgICAgICAgICAgY29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB3Y2g6IDdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbFNpemVzLnB1c2goY29sdW1ucyk7XG5cblxuICAgICAgICAvLyBhZGQgZmFjdG9yIHJhbmtzIGFuZCByb3VuZCBhdCAyIGRpZ2l0c1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IHN5bkZhY3RvckFycmF5MS5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGpqID0gMCwgampMZW4gPSBzeW5GYWN0b3JBcnJheTFbal0ubGVuZ3RoOyBqaiA8IGpqTGVuOyBqaisrKSB7XG4gICAgICAgICAgICAgICAgc3luRmFjdG9yQXJyYXkxW2pdW2pqXVthcHBlbmRUZXh0NV0gPSBldmVuUm91bmQoKHN5bkZhY3RvckFycmF5MVtqXVtqal1bYXBwZW5kVGV4dDVdKSwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzeW5GYWN0b3JBcnJheTFbal1cbiAgICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiW2FwcGVuZFRleHQ1XSA9PT0gYVthcHBlbmRUZXh0NV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhW2FwcGVuZFRleHQzXSAtIGJbYXBwZW5kVGV4dDNdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJbYXBwZW5kVGV4dDVdIC0gYVthcHBlbmRUZXh0NV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBzeW5GYWN0b3JBcnJheTFbal0ubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmFua1ZhbHVlID0gKGkgKyAxKTtcbiAgICAgICAgICAgICAgICBzeW5GYWN0b3JBcnJheTFbal1baV0uUmFuayA9IHJhbmtWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3luRmFjdG9yQXJyYXkxW2pdXG4gICAgICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVthcHBlbmRUZXh0M10gLSBiW2FwcGVuZFRleHQzXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlLXNvcnQgZm9yIHVzZSBiZWxvdz9cbiAgICAgICAgLy8gc3luRmFjdG9yQXJyYXkxWzBdXG4gICAgICAgIC8vICAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIGFbYXBwZW5kVGV4dDNdIC0gYlthcHBlbmRUZXh0M107XG4gICAgICAgIC8vICAgICB9KTtcblxuICAgICAgICB2YXIgY29tcG9zaXRlRmFjdG9yTWFzdGVyQXJyYXkgPSBRQVYuZ2V0U3RhdGUoXCJjb21wb3NpdGVGYWN0b3JNYXN0ZXJBcnJheVwiKTtcbiAgICAgICAgdmFyIGZhY3RvclNjb3JlUmFua3NBcnJheSA9IFtdO1xuXG4gICAgICAgIC8vIHNvcnQgYnkgc3RhdGVtZW50IG51bWJlciBhbmQgcHVzaCBudW0gYW5kIHN0YXRlbWVudCBhbmQgbnVtIGludG8gcmFua3MgYXJyYXlcbiAgICAgICAgY29tcG9zaXRlRmFjdG9yTWFzdGVyQXJyYXlbMF0uc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYVswXSA9PT0gYlswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFbMF0gPCBiWzBdKSA/XG4gICAgICAgICAgICAgICAgICAgIC0xIDpcbiAgICAgICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIHd3ID0gMCwgd3dMZW4gPSBjb21wb3NpdGVGYWN0b3JNYXN0ZXJBcnJheVswXS5sZW5ndGg7IHd3IDwgd3dMZW47IHd3KyspIHtcbiAgICAgICAgICAgIHZhciB0ZW1wQXJyYXltbTEgPSBbXTtcbiAgICAgICAgICAgIHRlbXBBcnJheW1tMS5wdXNoKGNvbXBvc2l0ZUZhY3Rvck1hc3RlckFycmF5WzBdW3d3XVswXSk7XG4gICAgICAgICAgICB0ZW1wQXJyYXltbTEucHVzaChjb21wb3NpdGVGYWN0b3JNYXN0ZXJBcnJheVswXVt3d11bMV0pO1xuICAgICAgICAgICAgdGVtcEFycmF5bW0xLnB1c2goY29tcG9zaXRlRmFjdG9yTWFzdGVyQXJyYXlbMF1bd3ddWzBdKTtcbiAgICAgICAgICAgIGZhY3RvclNjb3JlUmFua3NBcnJheS5wdXNoKHRlbXBBcnJheW1tMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjeWNsZSB0aHJvdWdoIHVzZXIgc2VsZWN0ZWQgZmFjdG9ycyB0byBnZXQgelNjb3JlIGFuZCByYW5rXG4gICAgICAgIGZvciAodmFyIGtrID0gMCwga2tMZW4gPSBjb21wb3NpdGVGYWN0b3JNYXN0ZXJBcnJheS5sZW5ndGg7IGtrIDwga2tMZW47IGtrKyspIHtcbiAgICAgICAgICAgIC8vIHNvcnQgYnkgc3RhdGVtZW50IG51bWJlclxuICAgICAgICAgICAgY29tcG9zaXRlRmFjdG9yTWFzdGVyQXJyYXlba2tdXG4gICAgICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYVswXSA9PT0gYlswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGFbMF0gPCBiWzBdKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGluc2VydCB6U2NvcmVcbiAgICAgICAgICAgIGZvciAodmFyIGlpID0gMCwgaWlMZW4gPSBjb21wb3NpdGVGYWN0b3JNYXN0ZXJBcnJheVtra10ubGVuZ3RoOyBpaSA8IGlpTGVuOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBac2NvcmUgPSBldmVuUm91bmQoY29tcG9zaXRlRmFjdG9yTWFzdGVyQXJyYXlba2tdW2lpXVsyXSwgMik7XG4gICAgICAgICAgICAgICAgZmFjdG9yU2NvcmVSYW5rc0FycmF5W2lpXS5wdXNoKHRlbXBac2NvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmUtc29ydCBieSBsYXRlc3QgcHVzaGVkIHpTY29yZVxuICAgICAgICAgICAgLy8gdmFyIHBsYWNlU2V0dGVyID0gZmFjdG9yU2NvcmVSYW5rc0FycmF5WzBdLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YXIgcGxhY2VTZXR0ZXIgPSAyO1xuICAgICAgICAgICAgY29tcG9zaXRlRmFjdG9yTWFzdGVyQXJyYXlba2tdLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIGlmIChhW3BsYWNlU2V0dGVyXSA9PT0gYltwbGFjZVNldHRlcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChiW3BsYWNlU2V0dGVyXSA8IGFbcGxhY2VTZXR0ZXJdKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciByciA9IDAsIHJyTGVuID0gY29tcG9zaXRlRmFjdG9yTWFzdGVyQXJyYXlba2tdLmxlbmd0aDsgcnIgPCByckxlbjsgcnIrKykge1xuICAgICAgICAgICAgICAgIHZhciBSYW5rVmFsdWUyID0gKHJyICsgMSk7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRlRmFjdG9yTWFzdGVyQXJyYXlba2tdW3JyXS5wdXNoKFJhbmtWYWx1ZTIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZS1zb3J0IHRvIHN0YXRlbWVudCBudW1iZXJcbiAgICAgICAgICAgIGNvbXBvc2l0ZUZhY3Rvck1hc3RlckFycmF5W2trXVxuICAgICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFbMF0gPT09IGJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhWzBdIDwgYlswXSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGdldCBhbmQgcHVzaCByYW5raW5nIG51bWJlcnNcbiAgICAgICAgICAgIGZvciAodmFyIHBwID0gMCwgcHBMZW4gPSBjb21wb3NpdGVGYWN0b3JNYXN0ZXJBcnJheVtra10ubGVuZ3RoOyBwcCA8IHBwTGVuOyBwcCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIFJhbmtWYWx1ZTMgPSBjb21wb3NpdGVGYWN0b3JNYXN0ZXJBcnJheVtra11bcHBdLnBvcCgpO1xuICAgICAgICAgICAgICAgIGZhY3RvclNjb3JlUmFua3NBcnJheVtwcF0ucHVzaChSYW5rVmFsdWUzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBsYWNlU2V0dGVyID0gcGxhY2VTZXR0ZXIgKyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwYWNlciA9IFtcIlwiLCBcIlwiXTtcbiAgICAgICAgdmFyIHRlbXBBcnJheUhlYWRlciA9IFtcIlwiLCBhcHBlbmRUZXh0Nl07XG4gICAgICAgIHZhciB0ZW1wQXJyYXlIZWFkZXIyID0gW2FwcGVuZFRleHQzLCBhcHBlbmRUZXh0NCwgYXBwZW5kVGV4dDNdO1xuICAgICAgICB2YXIgdGVtcFN1YkhlYWRlciA9IFtcIlwiLCBcIlwiLCBcIlwiXTtcbiAgICAgICAgZm9yICh2YXIgeXkgPSAwLCB5eUxlbiA9IHVzZXJTZWxlY3RlZEZhY3RvcnMubGVuZ3RoOyB5eSA8IHl5TGVuOyB5eSsrKSB7XG4gICAgICAgICAgICB0ZW1wQXJyYXlIZWFkZXIyLnB1c2godXNlclNlbGVjdGVkRmFjdG9yc1t5eV0sIHVzZXJTZWxlY3RlZEZhY3RvcnNbeXldKTtcbiAgICAgICAgICAgIHRlbXBTdWJIZWFkZXIucHVzaChcIlotc2NvcmVcIiwgXCJSYW5rXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmFjdG9yU2NvcmVSYW5rc0FycmF5LnVuc2hpZnQoc3BhY2VyLCB0ZW1wQXJyYXlIZWFkZXIsIHNwYWNlciwgdGVtcEFycmF5SGVhZGVyMiwgdGVtcFN1YkhlYWRlcik7XG4gICAgICAgIG91dHB1dERhdGEucHVzaChmYWN0b3JTY29yZVJhbmtzQXJyYXkpO1xuXG4gICAgICAgIC8vIHNldHVwIHRoZSBhcnJheSBvZiByYW5rZWQgc3RhdGVtZW50c1xuICAgICAgICB2YXIgZmFjdG9yU2NvcmVDb21wYXJpc29uQXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayA9IDAsIGtMZW4gPSBzeW5GYWN0b3JBcnJheTFbMF0ubGVuZ3RoOyBrIDwga0xlbjsgaysrKSB7XG4gICAgICAgICAgICByYW5raW5nVGVtcEFycmF5ID0gW107XG4gICAgICAgICAgICB0ZW1wQXJyYXkxID0ge307XG4gICAgICAgICAgICB0ZW1wQXJyYXkxLk51bTEgPSBzeW5GYWN0b3JBcnJheTFbMF1ba11bYXBwZW5kVGV4dDNdO1xuICAgICAgICAgICAgdGVtcEFycmF5MS5TdGF0ZW1lbnQgPSBzeW5GYWN0b3JBcnJheTFbMF1ba11bYXBwZW5kVGV4dDRdO1xuICAgICAgICAgICAgdGVtcEFycmF5MS5OdW0yID0gc3luRmFjdG9yQXJyYXkxWzBdW2tdW2FwcGVuZFRleHQzXTtcbiAgICAgICAgICAgIHRlbXBBcnJheTEuWnNjb3JlMSA9IHN5bkZhY3RvckFycmF5MVswXVtrXVthcHBlbmRUZXh0NV07XG4gICAgICAgICAgICB2YXIgcmFuazEgPSBzeW5GYWN0b3JBcnJheTFbMF1ba11bYXBwZW5kVGV4dDddO1xuICAgICAgICAgICAgdGVtcEFycmF5MS5SYW5rMSA9IHJhbmsxO1xuICAgICAgICAgICAgdmFyIHRlbXBTb3J0VmFsdWUgPSBzeW5GYWN0b3JBcnJheTFbMF1ba11bYXBwZW5kVGV4dDhdO1xuICAgICAgICAgICAgcmFua2luZ1RlbXBBcnJheS5wdXNoKHRlbXBTb3J0VmFsdWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDEsIG1MZW4gPSBzeW5GYWN0b3JBcnJheTEubGVuZ3RoOyBtIDwgbUxlbjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1tID0gbSArIDE7XG4gICAgICAgICAgICAgICAgdGVtcEFycmF5MVtcIlpzY29yZVwiICsgbW1dID0gc3luRmFjdG9yQXJyYXkxW21dW2tdW2FwcGVuZFRleHQ1XTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxW1wiUmFua1wiICsgbW1dID0gc3luRmFjdG9yQXJyYXkxW21dW2tdW2FwcGVuZFRleHQ3XTtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcFNvcnRWYWx1ZTIgPSBzeW5GYWN0b3JBcnJheTFbbV1ba11bYXBwZW5kVGV4dDhdO1xuICAgICAgICAgICAgICAgIHJhbmtpbmdUZW1wQXJyYXkucHVzaCh0ZW1wU29ydFZhbHVlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmYWN0b3JTY29yZUNvbXBhcmlzb25BcnJheS5wdXNoKHRlbXBBcnJheTEpO1xuICAgICAgICAgICAgc3RhdGVtZW50UmFua2luZ0FycmF5LnB1c2gocmFua2luZ1RlbXBBcnJheSk7XG4gICAgICAgIH1cblxuICAgICAgICBRQVYuc2V0U3RhdGUoXCJzdGF0ZW1lbnRSYW5raW5nQXJyYXlcIiwgc3RhdGVtZW50UmFua2luZ0FycmF5KTtcblxuICAgICAgICBwdXNoRmFjdG9yU2NvcmVDb3JyZWxhdGlvbnNUb091dHB1dEFycmF5KHNoZWV0TmFtZXMsIG91dHB1dCwgb3V0cHV0RGF0YSwgc2hlZXROYW1lc1hsc3gsIGNvbFNpemVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXNoRmFjdG9yU2NvcmVDb3JyZWxhdGlvbnNUb091dHB1dEFycmF5KHNoZWV0TmFtZXMsIG91dHB1dCwgb3V0cHV0RGF0YSwgc2hlZXROYW1lc1hsc3gsIGNvbFNpemVzKSB7XG5cbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJGYWN0b3Igc2NvcmUgY29ycmVsYXRpb25zXCJdO1xuXG4gICAgICAgIHNoZWV0TmFtZXNYbHN4LnB1c2goYXBwZW5kVGV4dDEpO1xuXG4gICAgICAgIHZhciBhbmFseXNpc091dHB1dCA9IFFBVi5nZXRTdGF0ZShcImFuYWx5c2lzT3V0cHV0XCIpO1xuICAgICAgICB2YXIgdXNlclNlbGVjdGVkRmFjdG9ycyA9IFFBVi5nZXRTdGF0ZShcInVzZXJTZWxlY3RlZEZhY3RvcnNcIik7XG4gICAgICAgIHZhciBhbmFseXNpc091dHB1dDIgPSBfLmNsb25lRGVlcChhbmFseXNpc091dHB1dCk7XG4gICAgICAgIHZhciBmYWN0b3JTY29yZXNDb3JyZWxhdGlvbkFycmF5MiA9IFtdO1xuICAgICAgICB2YXIgdGVtcDEsIHRlbXAyLCB0ZW1wQXJyYXk7XG5cbiAgICAgICAgdmFyIGNvbHVtbnMgPSBbe1xuICAgICAgICAgICAgd2NoOiA3XG4gICAgICAgIH1dO1xuICAgICAgICBmb3IgKHZhciBzcyA9IDAsIHNzTGVuID0gKHVzZXJTZWxlY3RlZEZhY3RvcnMubGVuZ3RoKTsgc3MgPCBzc0xlbjsgc3MrKykge1xuICAgICAgICAgICAgY29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB3Y2g6IDdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbFNpemVzLnB1c2goY29sdW1ucyk7XG5cbiAgICAgICAgLy8gaSBsb29wIHRocm91Z2ggc2VsZWN0ZWQgZmFjdG9ycywgaiBsb29wIHRocm91Z2ggc29ydHMgdG8gZ2V0IG5ldyBhcnJheSBvZiB6LXNjb3Jlc1xuICAgICAgICAvLyB0b2RvIC0gYWRkZWQgYWZ0ZXIgb3RoZXIgY2FsY3VsYXRpb25zLCBzbyBub3cgcmVwZWF0cyB3aXRoIGZhY3RvciBkb3dubG9hZCBzaGVldHMgLSBkcnkgb3V0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlclNlbGVjdGVkRmFjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcDIgPSB1c2VyU2VsZWN0ZWRGYWN0b3JzW2ldO1xuICAgICAgICAgICAgdGVtcEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFuYWx5c2lzT3V0cHV0MltpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRlbXAxID0gYW5hbHlzaXNPdXRwdXQyW2ldW2pdLnpTY29yZTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkucHVzaCh0ZW1wMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmYWN0b3JTY29yZXNDb3JyZWxhdGlvbkFycmF5Mi5wdXNoKHRlbXBBcnJheSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2RvIC0gY29udmVydGluZyB0byBpbnRlZ2VyIGdpdmVzIGxvdHMgdmFyaWF0aW9uIHdpdGggUFFtZXRob2QgLSB1c2UgZXZlblJvdW5kP1xuICAgICAgICB2YXIgZmFjdG9yU2NvcmVzQ29ycmVsYXRpb25BcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IGZhY3RvclNjb3Jlc0NvcnJlbGF0aW9uQXJyYXkyLmxlbmd0aDsgcSsrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcDExID0gXy5tYXAoZmFjdG9yU2NvcmVzQ29ycmVsYXRpb25BcnJheTJbcV0sIGV2ZW5Sb3VuZEZ1bmMpO1xuICAgICAgICAgICAgZmFjdG9yU2NvcmVzQ29ycmVsYXRpb25BcnJheS5wdXNoKHRlbXAxMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBldmVuUm91bmRGdW5jKG4pIHtcbiAgICAgICAgICAgIHZhciB0ZW1wMSA9IGV2ZW5Sb3VuZCgobiksIDUpO1xuICAgICAgICAgICAgcmV0dXJuIHRlbXAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHB1bGxYO1xuICAgICAgICB2YXIgY29ycmVsYXRpb25UYWJsZUFycmF5RnJhZ21lbnQgPSBbXTtcbiAgICAgICAgdmFyIGNvcnJlbGF0aW9uVGFibGVBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGZhY3RvclNjb3Jlc0NvcnJlbGF0aW9uQXJyYXkubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHB1bGxYID0gZmFjdG9yU2NvcmVzQ29ycmVsYXRpb25BcnJheVtrXTtcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uVGFibGVBcnJheUZyYWdtZW50ID0gZmFjdG9yU2NvcmVzQ29ycmVsYXRpb25zSGVscGVyKGZhY3RvclNjb3Jlc0NvcnJlbGF0aW9uQXJyYXksIHB1bGxYKTtcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uVGFibGVBcnJheS5wdXNoKGNvcnJlbGF0aW9uVGFibGVBcnJheUZyYWdtZW50KTtcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uVGFibGVBcnJheUZyYWdtZW50ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmYWN0b3JTY29yZXNDb3JyZWxhdGlvbnNIZWxwZXIoZmFjdG9yU2NvcmVzQ29ycmVsYXRpb25BcnJheSwgcHVsbFgpIHtcblxuICAgICAgICAgICAgdmFyIGNvcnJlbGF0aW9uSG9sZGVyLFxuICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSG9sZGVyMjtcbiAgICAgICAgICAgIHZhciBjb3JyZWxhdGlvblRhYmxlQXJyYXlGcmFnbWVudCA9IFtdO1xuXG4gICAgICAgICAgICBfKGZhY3RvclNjb3Jlc0NvcnJlbGF0aW9uQXJyYXkpLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSG9sZGVyMiA9IENPUlIuZ2V0UHFtZXRob2RDb3JyZWxhdGlvbihwdWxsWCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgY29ycmVsYXRpb25Ib2xkZXIgPSBldmVuUm91bmQoKGNvcnJlbGF0aW9uSG9sZGVyMlswXSksIDQpO1xuICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uVGFibGVBcnJheUZyYWdtZW50LnB1c2goY29ycmVsYXRpb25Ib2xkZXIpO1xuICAgICAgICAgICAgfSkudmFsdWUoKTtcbiAgICAgICAgICAgIHJldHVybiBjb3JyZWxhdGlvblRhYmxlQXJyYXlGcmFnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBmYWN0b3IgbmFtZXMgdG8gZmlyc3QgY29sdW1uXG4gICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgY29ycmVsYXRpb25UYWJsZUFycmF5Lmxlbmd0aDsgbSsrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcDggPSB1c2VyU2VsZWN0ZWRGYWN0b3JzW21dO1xuICAgICAgICAgICAgY29ycmVsYXRpb25UYWJsZUFycmF5W21dLnVuc2hpZnQodGVtcDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRlbXBBcnJheTMgPSBbXTtcbiAgICAgICAgdGVtcEFycmF5My5wdXNoKFwiXCIpO1xuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHVzZXJTZWxlY3RlZEZhY3RvcnMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHZhciB0ZW1wOSA9IHVzZXJTZWxlY3RlZEZhY3RvcnNbcF07XG4gICAgICAgICAgICB0ZW1wQXJyYXkzLnB1c2godGVtcDkpO1xuICAgICAgICB9XG4gICAgICAgIGNvcnJlbGF0aW9uVGFibGVBcnJheS51bnNoaWZ0KHRlbXBBcnJheTMpO1xuXG4gICAgICAgIFFBVi5zZXRTdGF0ZShcImNvcnJlbGF0aW9uVGFibGVBcnJheUhvbGRlclwiLCBjb3JyZWxhdGlvblRhYmxlQXJyYXkpO1xuICAgICAgICBvdXRwdXQucHVzaChjb3JyZWxhdGlvblRhYmxlQXJyYXkpO1xuXG4gICAgICAgIC8vdmFyIGNvcnJlbGF0aW9uVGFibGVBcnJheTIgPSBfLmNsb25lRGVlcChjb3JyZWxhdGlvblRhYmxlQXJyYXkpO1xuICAgICAgICBjb3JyZWxhdGlvblRhYmxlQXJyYXkudW5zaGlmdChbXG4gICAgICAgICAgICBcIlwiLCBcIlwiXG4gICAgICAgIF0sIFthcHBlbmRUZXh0MV0sIFtcIlwiLCBcIlwiXSk7XG5cbiAgICAgICAgb3V0cHV0RGF0YS5wdXNoKGNvcnJlbGF0aW9uVGFibGVBcnJheSk7XG5cbiAgICAgICAgLy8gcHVzaEZhY3RvcnNUb091dHB1dEFycmF5KHNoZWV0TmFtZXMsIG91dHB1dCk7XG4gICAgICAgIGluc2VydEZhY3RvcnNJbnRvT3V0cHV0QXJyYXkoc2hlZXROYW1lcywgb3V0cHV0LCBhbmFseXNpc091dHB1dCwgb3V0cHV0RGF0YSwgc2hlZXROYW1lc1hsc3gsIGNvbFNpemVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNlcnRGYWN0b3JzSW50b091dHB1dEFycmF5KHNoZWV0TmFtZXMsIG91dHB1dCwgYW5hbHlzaXNPdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcykge1xuXG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDEgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiU29ydHMgV2VpZ2h0XCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDIgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiU29ydHMgQ29yclwiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQzID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlN0YXRlbWVudCBOdW1iZXJcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uU3RhdGVtZW50O1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDUgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiWi1zY29yZVwiXTtcbiAgICAgICAgLy8gdmFyIGFwcGVuZFRleHQ2ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlNvcnQgVmFsdWVzXCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDcgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiUmF3IFNvcnRcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0OCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJTb3J0IFZhbHVlc1wiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQ5ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlNvcnRzIENvcnJlbGF0aW9uc1wiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQxMCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJGYWN0b3IgU2NvcmVzIGZvciBcIl07XG5cbiAgICAgICAgdmFyIHNoZWV0TmFtZXNIb2xkZXIxID0gUUFWLmdldFN0YXRlKFwic2hlZXROYW1lc0hvbGRlcjFcIik7XG4gICAgICAgIHZhciBzaGVldE5hbWVzSG9sZGVyMiA9IFFBVi5nZXRTdGF0ZShcInNoZWV0TmFtZXNIb2xkZXIyXCIpO1xuICAgICAgICB2YXIgc2hlZXROYW1lc0hvbGRlcjMgPSBRQVYuZ2V0U3RhdGUoXCJzaGVldE5hbWVzSG9sZGVyM1wiKTtcblxuICAgICAgICB2YXIgZmFjdG9yV2VpZ2h0RmFjdG9yQXJyYXkgPSBRQVYuZ2V0U3RhdGUoXCJmYWN0b3JXZWlnaHRGYWN0b3JBcnJheUhvbGRlclwiKTtcbiAgICAgICAgdmFyIG1pbmlDb3JyZWxhdGlvbkFycmF5ID0gUUFWLmdldFN0YXRlKFwibWluaUNvcnJlbGF0aW9uQXJyYXlIb2xkZXJcIik7XG4gICAgICAgIHZhciBzeW5GYWN0b3JBcnJheTEgPSBRQVYuZ2V0U3RhdGUoXCJzeW5GYWN0b3JBcnJheTFIb2xkZXJcIik7XG4gICAgICAgIHZhciBjb21wb3NpdGVGYWN0b3JNYXN0ZXJBcnJheSA9IFFBVi5nZXRTdGF0ZShcImNvbXBvc2l0ZUZhY3Rvck1hc3RlckFycmF5XCIpO1xuICAgICAgICB2YXIgdXNlclNlbGVjdGVkRmFjdG9ycyA9IFFBVi5nZXRTdGF0ZShcInVzZXJTZWxlY3RlZEZhY3RvcnNcIik7XG4gICAgICAgIHZhciBzaWdTb3J0c0FycmF5ID0gUUFWLmdldFN0YXRlKFwic2lnU29ydHNBcnJheVwiKTtcbiAgICAgICAgdmFyIG1heFN0YXRlbWVudExlbmd0aCA9IFFBVi5nZXRTdGF0ZShcIm1heFN0YXRlbWVudExlbmd0aFwiKTtcbiAgICAgICAgdmFyIHNwYWNlciA9IFtcIlwiLCBcIlwiXTtcblxuICAgICAgICBmb3IgKHZhciBpaSA9IDAsIGlpTGVuID0gdXNlclNlbGVjdGVkRmFjdG9ycy5sZW5ndGg7IGlpIDwgaWlMZW47IGlpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNoZWV0SGVhZGVyQXJyYXlQYXJ0aWFsID0gW2FwcGVuZFRleHQzLCBhcHBlbmRUZXh0NCwgYXBwZW5kVGV4dDUsIGFwcGVuZFRleHQ4XTtcblxuICAgICAgICAgICAgLy8gc2V0IHdlaWdodHMgbmFtZVxuICAgICAgICAgICAgc2hlZXROYW1lc1hsc3gucHVzaCgoc2hlZXROYW1lc0hvbGRlcjFbaWldLnNoZWV0aWQpKTtcblxuICAgICAgICAgICAgLy8gc2V0IHdlaWdodHMgY29sdW1uc1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBbe1xuICAgICAgICAgICAgICAgIHdjaDogOFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHdjaDogOFxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBjb2xTaXplcy5wdXNoKGNvbHVtbnMpO1xuXG4gICAgICAgICAgICAvLyBzZXQgd2VpZ2h0cyBzaGVldFxuICAgICAgICAgICAgZmFjdG9yV2VpZ2h0RmFjdG9yQXJyYXlbaWldLnVuc2hpZnQoc3BhY2VyLCBbdXNlclNlbGVjdGVkRmFjdG9yc1tpaV0sIGFwcGVuZFRleHQxXSwgc3BhY2VyKTtcbiAgICAgICAgICAgIG91dHB1dERhdGEucHVzaChmYWN0b3JXZWlnaHRGYWN0b3JBcnJheVtpaV0pO1xuXG4gICAgICAgICAgICAvLyBzZXQgc29ydHMgY29yciBuYW1lXG4gICAgICAgICAgICBzaGVldE5hbWVzWGxzeC5wdXNoKChzaGVldE5hbWVzSG9sZGVyMltpaV0uc2hlZXRpZCkpO1xuXG4gICAgICAgICAgICAvLyBzZXQgc29ydHMgY29yciBjb2xzXG4gICAgICAgICAgICB2YXIgY29sdW1uczIgPSBbe1xuICAgICAgICAgICAgICAgIHdjaDogOFxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBmb3IgKHZhciBzcyA9IDAsIHNzTGVuID0gKHVzZXJTZWxlY3RlZEZhY3RvcnMubGVuZ3RoKTsgc3MgPCBzc0xlbjsgc3MrKykge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB3Y2g6IDhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbFNpemVzLnB1c2goY29sdW1uczIpO1xuXG4gICAgICAgICAgICAvLyBzZXQgc29ydHMgY29yciBzaGVldFxuICAgICAgICAgICAgbWluaUNvcnJlbGF0aW9uQXJyYXlbaWldLnVuc2hpZnQoc3BhY2VyLCBbdXNlclNlbGVjdGVkRmFjdG9yc1tpaV0sIGFwcGVuZFRleHQ5XSwgc3BhY2VyKTtcbiAgICAgICAgICAgIG91dHB1dERhdGEucHVzaChtaW5pQ29ycmVsYXRpb25BcnJheVtpaV0pO1xuXG4gICAgICAgICAgICAvLyBzZXQgZmFjdG9yIHNoZWV0IG5hbWVcbiAgICAgICAgICAgIHNoZWV0TmFtZXNYbHN4LnB1c2goKHNoZWV0TmFtZXNIb2xkZXIzW2lpXS5zaGVldGlkKSk7XG5cbiAgICAgICAgICAgIC8vIHNldCBmYWN0b3Igc2hlZXQgY29sc1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMzID0gW3tcbiAgICAgICAgICAgICAgICB3Y2g6IDhcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB3Y2g6IG1heFN0YXRlbWVudExlbmd0aFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHdjaDogOVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHdjaDogMTJcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgZm9yICh2YXIgdHQgPSAwLCB0dExlbiA9IHNpZ1NvcnRzQXJyYXlbaWldLlNpZ1NvcnRzLmxlbmd0aDsgdHQgPCB0dExlbjsgdHQrKykge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB3Y2g6IDEyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xTaXplcy5wdXNoKGNvbHVtbnMzKTtcblxuICAgICAgICAgICAgLy8gc2V0IGZhY3RvciBzaGVldHNcbiAgICAgICAgICAgIC8vIHJlLXNvcnQgdG8gelNjb3JlXG4gICAgICAgICAgICBjb21wb3NpdGVGYWN0b3JNYXN0ZXJBcnJheVtpaV0uc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbMl0gPT09IGJbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhWzBdIDwgYlswXSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGJbMl0gPCBhWzJdKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqaiA9IDAsIGpqTGVuID0gc2lnU29ydHNBcnJheVtpaV0uU2lnU29ydHMubGVuZ3RoOyBqaiA8IGpqTGVuOyBqaisrKSB7XG4gICAgICAgICAgICAgICAgc2hlZXRIZWFkZXJBcnJheVBhcnRpYWwucHVzaChhcHBlbmRUZXh0NyArIFwiIFwiICsgc2lnU29ydHNBcnJheVtpaV0uU2lnU29ydHNbampdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvc2l0ZUZhY3Rvck1hc3RlckFycmF5W2lpXS51bnNoaWZ0KHNwYWNlciwgW1wiXCIsIGFwcGVuZFRleHQxMCArIFwiIFwiICsgdXNlclNlbGVjdGVkRmFjdG9yc1tpaV1dLCBzcGFjZXIsIHNoZWV0SGVhZGVyQXJyYXlQYXJ0aWFsKTtcbiAgICAgICAgICAgIG91dHB1dERhdGEucHVzaChjb21wb3NpdGVGYWN0b3JNYXN0ZXJBcnJheVtpaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBmYWN0b3JXZWlnaHRGYWN0b3JBcnJheS5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHNoZWV0TmFtZXMucHVzaChzaGVldE5hbWVzSG9sZGVyMVtpXSk7XG4gICAgICAgICAgICBzaGVldE5hbWVzLnB1c2goc2hlZXROYW1lc0hvbGRlcjJbaV0pO1xuICAgICAgICAgICAgc2hlZXROYW1lcy5wdXNoKHNoZWV0TmFtZXNIb2xkZXIzW2ldKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGZhY3RvcldlaWdodEZhY3RvckFycmF5W2ldKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKG1pbmlDb3JyZWxhdGlvbkFycmF5W2ldKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHN5bkZhY3RvckFycmF5MVtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBwdXNoRmFjdG9yUG93ZXJTZXREaWZmc1RvT3V0cHV0QXJyYXkoc2hlZXROYW1lcywgb3V0cHV0LCBhbmFseXNpc091dHB1dCwgb3V0cHV0RGF0YSwgc2hlZXROYW1lc1hsc3gsIGNvbFNpemVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXNoRmFjdG9yUG93ZXJTZXREaWZmc1RvT3V0cHV0QXJyYXkoc2hlZXROYW1lcywgb3V0cHV0LCBhbmFseXNpc091dHB1dCwgb3V0cHV0RGF0YSwgc2hlZXROYW1lc1hsc3gsIGNvbFNpemVzKSB7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICB2YXIgY2hhcnRUZXh0MSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uRGlmZjtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDIgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLkRpZmZlcmVuY2U7XG4gICAgICAgIHZhciBjaGFydFRleHQzID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlN0YXRlbWVudCBOdW1iZXJcIl07XG4gICAgICAgIHZhciBjaGFydFRleHQ0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5TdGF0ZW1lbnQ7XG4gICAgICAgIHZhciBjaGFydFRleHQ1ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIkRlc2NlbmRpbmcgQXJyYXkgb2YgRGlmZmVyZW5jZXMgQmV0d2VlblwiXTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDYgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLmFuZDtcbiAgICAgICAgdmFyIG9uZUZhY3RvciwgYW5vdGhlckZhY3RvcjtcbiAgICAgICAgdmFyIG1heFN0YXRlbWVudExlbmd0aCA9IFFBVi5nZXRTdGF0ZShcIm1heFN0YXRlbWVudExlbmd0aFwiKTtcbiAgICAgICAgdmFyIHNwYWNlciA9IFtcIlwiLCBcIlwiXTtcblxuICAgICAgICB2YXIgZmFjdG9yUGFpcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmFseXNpc091dHB1dC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgYW5hbHlzaXNPdXRwdXQubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yUGFpcnMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIGFuYWx5c2lzT3V0cHV0W2ldLFxuICAgICAgICAgICAgICAgICAgICBhbmFseXNpc091dHB1dFtqICsgMV1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlmZkFycmF5U29ydGVkO1xuICAgICAgICB2YXIgbmFtZXNDb21ib0FycmF5ID0gW107XG4gICAgICAgIHZhciBzaGVldEhlYWRlcjFBcnJheSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZmFjdG9yUGFpcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lc0NvbWJvQXJyYXlGcmFnID0gW107XG4gICAgICAgICAgICB2YXIgc2hlZXRIZWFkZXIxID0gW2NoYXJ0VGV4dDMsIGNoYXJ0VGV4dDRdO1xuICAgICAgICAgICAgb25lRmFjdG9yID0gZmFjdG9yUGFpcnNba11bMF1bMF0uZmFjdG9yO1xuICAgICAgICAgICAgYW5vdGhlckZhY3RvciA9IGZhY3RvclBhaXJzW2tdWzFdWzBdLmZhY3RvcjtcbiAgICAgICAgICAgIG5hbWVzQ29tYm9BcnJheUZyYWcucHVzaChvbmVGYWN0b3IsIGFub3RoZXJGYWN0b3IpO1xuICAgICAgICAgICAgdmFyIHRlbXAxID0ge307XG4gICAgICAgICAgICB0ZW1wMS5zaGVldGlkID0gY2hhcnRUZXh0MSArIG9uZUZhY3RvciArIFwiIFwiICsgYW5vdGhlckZhY3RvcjtcbiAgICAgICAgICAgIHRlbXAxLmhlYWRlciA9IHRydWU7XG4gICAgICAgICAgICBzaGVldE5hbWVzLnB1c2godGVtcDEpO1xuICAgICAgICAgICAgbmFtZXNDb21ib0FycmF5LnB1c2gobmFtZXNDb21ib0FycmF5RnJhZyk7XG4gICAgICAgICAgICBzaGVldE5hbWVzWGxzeC5wdXNoKGNoYXJ0VGV4dDEgKyBvbmVGYWN0b3IgKyBcIiBcIiArIGFub3RoZXJGYWN0b3IpO1xuXG4gICAgICAgICAgICBzaGVldEhlYWRlcjEucHVzaChvbmVGYWN0b3IsIGFub3RoZXJGYWN0b3IsIGNoYXJ0VGV4dDIpO1xuICAgICAgICAgICAgc2hlZXRIZWFkZXIxQXJyYXkucHVzaChzaGVldEhlYWRlcjEpO1xuXG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IFt7XG4gICAgICAgICAgICAgICAgd2NoOiA4XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgd2NoOiBtYXhTdGF0ZW1lbnRMZW5ndGhcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB3Y2g6IDhcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB3Y2g6IDhcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB3Y2g6IDEwXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIGNvbFNpemVzLnB1c2goY29sdW1ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwdXNoIGVhY2ggcGFpciB0byBvdXRwdXRcbiAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBmYWN0b3JQYWlycy5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgdmFyIGRpZmZBcnJheSA9IFtdO1xuICAgICAgICAgICAgdmFyIGRpZmZBcnJheVhsc3ggPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgZmFjdG9yUGFpcnNbbV1bMF0ubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcEFycmF5ID0gW107XG5cbiAgICAgICAgICAgICAgICB2YXIgdGVtcDFhID0gZmFjdG9yUGFpcnNbbV1bMF1bcF0uc3RhdGVtZW50O1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wMWIgPSBmYWN0b3JQYWlyc1ttXVswXVtwXS5zb3J0U3RhdGVtZW50O1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wMWMgPSBmYWN0b3JQYWlyc1ttXVswXVtwXS56U2NvcmU7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAxZCA9IGZhY3RvclBhaXJzW21dWzFdW3BdLnpTY29yZTtcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yc0RpZmYgPSBldmVuUm91bmQoKChmYWN0b3JQYWlyc1ttXVswXVtwXS56U2NvcmUpIC0gKGZhY3RvclBhaXJzW21dWzFdW3BdLnpTY29yZSkpLCAzKTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkucHVzaCh0ZW1wMWEsIHRlbXAxYiwgdGVtcDFjLCB0ZW1wMWQsIGZhY3RvcnNEaWZmKTtcbiAgICAgICAgICAgICAgICBkaWZmQXJyYXlYbHN4LnB1c2godGVtcEFycmF5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlmZkFycmF5WGxzeC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYVs0XSA9PT0gYls0XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGJbNF0gPCBhWzRdKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlmZkFycmF5WGxzeC51bnNoaWZ0KHNwYWNlciwgW2NoYXJ0VGV4dDUgKyBcIiBcIiArIG5hbWVzQ29tYm9BcnJheVttXVswXSArIFwiIFwiICsgY2hhcnRUZXh0NiArIFwiIFwiICsgbmFtZXNDb21ib0FycmF5W21dWzFdXSwgc3BhY2VyLCBzaGVldEhlYWRlcjFBcnJheVttXSk7XG4gICAgICAgICAgICBvdXRwdXREYXRhLnB1c2goZGlmZkFycmF5WGxzeCk7XG4gICAgICAgIH1cblxuICAgICAgICBwdXNoQ29uc2Vuc3VzU3RhdGVtZW50c1RvT3V0cHV0KHNoZWV0TmFtZXMsIG91dHB1dCwgYW5hbHlzaXNPdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaENvbnNlbnN1c1N0YXRlbWVudHNUb091dHB1dChzaGVldE5hbWVzLCBvdXRwdXQsIGFuYWx5c2lzT3V0cHV0LCBvdXRwdXREYXRhLCBzaGVldE5hbWVzWGxzeCwgY29sU2l6ZXMpIHtcblxuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDEgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiWi1TY29yZSBWYXJpYW5jZVwiXTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDIgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiQ29uc2Vuc3VzLURpc2FncmVlbWVudFwiXTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDMgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiU3RhdGVtZW50IE51bWJlclwiXTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDQgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLlN0YXRlbWVudDtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDUgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiWi1TY29yZSBWYXJpYW5jZVwiXTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDYgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiRmFjdG9yIFEtc29ydCBWYWx1ZXMgZm9yIFN0YXRlbWVudHMgc29ydGVkIGJ5IENvbnNlbnN1cyB2cy4gRGlzYWdyZWVtZW50XCJdO1xuXG4gICAgICAgIHZhciBzaWdGYWN0b3JOdW1iZXJzQXJyYXkgPSBRQVYuZ2V0U3RhdGUoXCJzaWdGYWN0b3JOdW1iZXJzQXJyYXlcIik7XG4gICAgICAgIHZhciB1c2VyU2VsZWN0ZWRGYWN0b3JzID0gUUFWLmdldFN0YXRlKFwidXNlclNlbGVjdGVkRmFjdG9yc1wiKTtcbiAgICAgICAgdmFyIG1heFN0YXRlbWVudExlbmd0aCA9IFFBVi5nZXRTdGF0ZShcIm1heFN0YXRlbWVudExlbmd0aFwiKTtcbiAgICAgICAgdmFyIHNwYWNlciA9IFtcIlwiLCBcIlwiXTtcblxuICAgICAgICBzaWdGYWN0b3JOdW1iZXJzQXJyYXkuc29ydCgpO1xuXG4gICAgICAgIHZhciB0YWJsZUhlYWRlciA9IFtjaGFydFRleHQzLCBjaGFydFRleHQ0XTtcbiAgICAgICAgdmFyIHRhYmxlSGVhZGVyMiA9IHRhYmxlSGVhZGVyLmNvbmNhdCh1c2VyU2VsZWN0ZWRGYWN0b3JzKTtcbiAgICAgICAgdGFibGVIZWFkZXIyLnB1c2goY2hhcnRUZXh0NSk7XG5cbiAgICAgICAgc2hlZXROYW1lc1hsc3gucHVzaChjaGFydFRleHQyKTtcblxuICAgICAgICAvLyBzZXQgZmFjdG9yIHNoZWV0IGNvbHNcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBbe1xuICAgICAgICAgICAgd2NoOiA4XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHdjaDogbWF4U3RhdGVtZW50TGVuZ3RoXG4gICAgICAgIH1dO1xuICAgICAgICBmb3IgKHZhciB0dCA9IDAsIHR0TGVuID0gdXNlclNlbGVjdGVkRmFjdG9ycy5sZW5ndGg7IHR0IDwgdHRMZW47IHR0KyspIHtcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgd2NoOiA4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgd2NoOiAxNVxuICAgICAgICB9KTtcbiAgICAgICAgY29sU2l6ZXMucHVzaChjb2x1bW5zKTtcblxuICAgICAgICB2YXIgY29uc2Vuc3VzRGlzYWdyZWVBcnJheSA9IFtdO1xuICAgICAgICB2YXIgelNjb3JlQXJyYXlGb3JTdGF0ZW1lbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5hbHlzaXNPdXRwdXRbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZW1wQXJyYXkxYSA9IFtdO1xuICAgICAgICAgICAgdGVtcEFycmF5MWEucHVzaChhbmFseXNpc091dHB1dFswXVtpXS5zdGF0ZW1lbnQsIGFuYWx5c2lzT3V0cHV0WzBdW2ldLnNvcnRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgdmFyIHRlbXBBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbmFseXNpc091dHB1dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wMSA9IHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtqXTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxYS5wdXNoKGFuYWx5c2lzT3V0cHV0W2pdW2ldLnNvcnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGVtcEFycmF5LnB1c2goYW5hbHlzaXNPdXRwdXRbal1baV0uelNjb3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB6U2NvcmVWYXJpYW5jZSA9IGV2ZW5Sb3VuZCgoVVRJTC52YXJpYW5jZSh0ZW1wQXJyYXkpKSwgMyk7XG4gICAgICAgICAgICB0ZW1wQXJyYXkxYS5wdXNoKHpTY29yZVZhcmlhbmNlKTtcbiAgICAgICAgICAgIGNvbnNlbnN1c0Rpc2FncmVlQXJyYXkucHVzaCh0ZW1wQXJyYXkxYSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYXRvciA9IHVzZXJTZWxlY3RlZEZhY3RvcnMubGVuZ3RoICsgMjtcbiAgICAgICAgY29uc2Vuc3VzRGlzYWdyZWVBcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhW2xvY2F0b3JdID09PSBiW2xvY2F0b3JdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYVtsb2NhdG9yXSA8IGJbbG9jYXRvcl0pID9cbiAgICAgICAgICAgICAgICAgICAgLTEgOlxuICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc2Vuc3VzRGlzYWdyZWVBcnJheS51bnNoaWZ0KHNwYWNlciwgW2NoYXJ0VGV4dDZdLCBzcGFjZXIsIHRhYmxlSGVhZGVyMik7XG4gICAgICAgIG91dHB1dERhdGEucHVzaChjb25zZW5zdXNEaXNhZ3JlZUFycmF5KTtcblxuICAgICAgICBwdXNoRmFjdG9yQ2hhcmFjdGVyaXN0aWNzVG9PdXRwdXQoc2hlZXROYW1lcywgb3V0cHV0LCBhbmFseXNpc091dHB1dCwgc2lnRmFjdG9yTnVtYmVyc0FycmF5LCBvdXRwdXREYXRhLCBzaGVldE5hbWVzWGxzeCwgY29sU2l6ZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hGYWN0b3JDaGFyYWN0ZXJpc3RpY3NUb091dHB1dChzaGVldE5hbWVzLCBvdXRwdXQsIGFuYWx5c2lzT3V0cHV0LCBzaWdGYWN0b3JOdW1iZXJzQXJyYXksIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcykge1xuXG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFFBVi5nZXRTdGF0ZShcImxhbmd1YWdlXCIpO1xuICAgICAgICB2YXIgY2hhcnRUZXh0MSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJGYWN0b3IgQ2hhcmFjdGVyaXN0aWNzXCJdO1xuICAgICAgICB2YXIgY2hhcnRUZXh0MiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJGYWN0b3IgTnVtYmVyXCJdO1xuICAgICAgICB2YXIgY2hhcnRUZXh0MyA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJOby4gb2YgRGVmaW5pbmcgVmFyaWFibGVzXCJdO1xuICAgICAgICB2YXIgY2hhcnRUZXh0NCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJBdmcuIFJlbC4gQ29lZi5cIl07XG4gICAgICAgIHZhciBjaGFydFRleHQ1ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIkNvbXBvc2l0ZSBSZWxpYWJpbGl0eVwiXTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDYgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiUy5FLiBvZiBGYWN0b3IgWi1zY29yZXNcIl07XG4gICAgICAgIHZhciB1c2VyU2VsZWN0ZWRGYWN0b3JzID0gUUFWLmdldFN0YXRlKFwidXNlclNlbGVjdGVkRmFjdG9yc1wiKTtcbiAgICAgICAgdmFyIHNpZ1NvcnRzQXJyYXkgPSBRQVYuZ2V0U3RhdGUoXCJzaWdTb3J0c0FycmF5XCIpO1xuICAgICAgICB2YXIgc3BhY2VyID0gW1wiXCIsIFwiXCJdO1xuXG4gICAgICAgIHNoZWV0TmFtZXNYbHN4LnB1c2goY2hhcnRUZXh0MSk7XG5cbiAgICAgICAgLy8gc2V0IGZhY3RvciBzaGVldCBjb2wgd2lkdGhzXG4gICAgICAgIHZhciBjb2x1bW5zID0gW3tcbiAgICAgICAgICAgIHdjaDogMjBcbiAgICAgICAgfV07XG4gICAgICAgIGZvciAodmFyIHR0ID0gMCwgdHRMZW4gPSB1c2VyU2VsZWN0ZWRGYWN0b3JzLmxlbmd0aDsgdHQgPCB0dExlbjsgdHQrKykge1xuICAgICAgICAgICAgY29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB3Y2g6IDhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbFNpemVzLnB1c2goY29sdW1ucyk7XG5cbiAgICAgICAgdmFyIGZhY3RvckNoYXJhY3RlcmlzdGljc1NoZWV0QXJyYXkgPSBbXTtcblxuICAgICAgICAvLyBsaW5lIDEgLSBmYWN0b3IgbGFiZWxzXG4gICAgICAgIHZhciBsaW5lMUFycmF5ID0gW1wiXCJdO1xuICAgICAgICB2YXIgbGluZTFBcnJheWIgPSBsaW5lMUFycmF5LmNvbmNhdCh1c2VyU2VsZWN0ZWRGYWN0b3JzKTtcbiAgICAgICAgZmFjdG9yQ2hhcmFjdGVyaXN0aWNzU2hlZXRBcnJheS5wdXNoKGxpbmUxQXJyYXliKTtcblxuXG4gICAgICAgIC8vIGxpbmUgMiAtIE5vLiBvZiBEZWZpbmluZyBWYXJpYWJsZXNcbiAgICAgICAgdmFyIGxpbmUyQXJyYXkgPSBbY2hhcnRUZXh0M107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2lnU29ydHNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGluZTJBcnJheS5wdXNoKHNpZ1NvcnRzQXJyYXlbal0uU2lnU29ydHMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmYWN0b3JDaGFyYWN0ZXJpc3RpY3NTaGVldEFycmF5LnB1c2gobGluZTJBcnJheSk7XG5cbiAgICAgICAgLy8gbGluZSAzIC0gQXZnLiBSZWwuIENvZWYuXG4gICAgICAgIC8vIHRvZG8gLSAhaW1wb3J0YW50IC0gY2hhbmdlIHRoaXMgZm9yIHVucmVzdHJhaW5lZCB1bmZvcmNlZCBzb3J0IHBhdHRlcm5zP1xuICAgICAgICB2YXIgbGluZTNBcnJheSA9IFtjaGFydFRleHQ0XTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaWdTb3J0c0FycmF5Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBsaW5lM0FycmF5LnB1c2goMC44MDApO1xuICAgICAgICB9XG4gICAgICAgIGZhY3RvckNoYXJhY3RlcmlzdGljc1NoZWV0QXJyYXkucHVzaChsaW5lM0FycmF5KTtcblxuICAgICAgICAvLyBsaW5lIDQgLSBDb21wb3NpdGUgUmVsaWFiaWxpdHlcbiAgICAgICAgdmFyIGxpbmU0QXJyYXkgPSBbY2hhcnRUZXh0NV07XG4gICAgICAgIHZhciBuU29ydHMsXG4gICAgICAgICAgICBjb21wb3NpdGVSZWw7XG4gICAgICAgIHZhciBjb21wb3NSZWxBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IHNpZ1NvcnRzQXJyYXkubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgIG5Tb3J0cyA9IHNpZ1NvcnRzQXJyYXlbbV0uU2lnU29ydHMubGVuZ3RoO1xuICAgICAgICAgICAgY29tcG9zaXRlUmVsID0gZXZlblJvdW5kKCgoblNvcnRzICogMC44MDApIC8gKDEgKyAoKG5Tb3J0cyAtIDEpICogMC44MDApKSksIDMpO1xuICAgICAgICAgICAgY29tcG9zUmVsQXJyYXkucHVzaChjb21wb3NpdGVSZWwpO1xuICAgICAgICAgICAgbGluZTRBcnJheS5wdXNoKGNvbXBvc2l0ZVJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjdG9yQ2hhcmFjdGVyaXN0aWNzU2hlZXRBcnJheS5wdXNoKGxpbmU0QXJyYXkpO1xuXG4gICAgICAgIC8vIGxpbmUgNSAtIFMuRS4gb2YgRmFjdG9yIFotc2NvcmVzXG4gICAgICAgIHZhciBsaW5lNUFycmF5ID0gW2NoYXJ0VGV4dDZdO1xuICAgICAgICB2YXIgc3RuZEVycm9yQXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBzaWdTb3J0c0FycmF5Lmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICB2YXIgc3RuZEVycm9yID0gZXZlblJvdW5kKE1hdGguc3FydChNYXRoLmFicygxLjAgLSBjb21wb3NSZWxBcnJheVtwXSkpLCAzKTtcbiAgICAgICAgICAgIHN0bmRFcnJvckFycmF5LnB1c2goc3RuZEVycm9yKTtcbiAgICAgICAgICAgIGxpbmU1QXJyYXkucHVzaChzdG5kRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGZhY3RvckNoYXJhY3RlcmlzdGljc1NoZWV0QXJyYXkucHVzaChsaW5lNUFycmF5KTtcbiAgICAgICAgZmFjdG9yQ2hhcmFjdGVyaXN0aWNzU2hlZXRBcnJheS51bnNoaWZ0KHNwYWNlciwgW2NoYXJ0VGV4dDFdLCBzcGFjZXIpO1xuXG4gICAgICAgIG91dHB1dERhdGEucHVzaChmYWN0b3JDaGFyYWN0ZXJpc3RpY3NTaGVldEFycmF5KTtcblxuICAgICAgICBwdXNoU3RhbmRhcmRFcnJvcnNEaWZmZXJlbmNlc1RvT3V0cHV0KHNoZWV0TmFtZXMsIG91dHB1dCwgc3RuZEVycm9yQXJyYXksIGFuYWx5c2lzT3V0cHV0LCBzaWdGYWN0b3JOdW1iZXJzQXJyYXksIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaFN0YW5kYXJkRXJyb3JzRGlmZmVyZW5jZXNUb091dHB1dChzaGVldE5hbWVzLCBvdXRwdXQsIHN0bmRFcnJvckFycmF5LCBhbmFseXNpc091dHB1dCwgc2lnRmFjdG9yTnVtYmVyc0FycmF5LCBvdXRwdXREYXRhLCBzaGVldE5hbWVzWGxzeCwgY29sU2l6ZXMpIHtcblxuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDEgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiU3RhbmRhcmQgRXJyb3JzIGZvciBEaWZmc1wiXTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDIgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiU3RhbmRhcmQgRXJyb3JzIGZvciBEaWZmZXJlbmNlcyBpbiBGYWN0b3IgWi1zY29yZXNcIl07XG4gICAgICAgIHZhciBzaWdTb3J0c0FycmF5ID0gUUFWLmdldFN0YXRlKFwic2lnU29ydHNBcnJheVwiKTtcbiAgICAgICAgdmFyIHVzZXJTZWxlY3RlZEZhY3RvcnMgPSBRQVYuZ2V0U3RhdGUoXCJ1c2VyU2VsZWN0ZWRGYWN0b3JzXCIpO1xuICAgICAgICB2YXIgc3BhY2VyID0gW1wiXCIsIFwiXCJdO1xuXG4gICAgICAgIHNoZWV0TmFtZXNYbHN4LnB1c2goY2hhcnRUZXh0MSk7XG5cbiAgICAgICAgLy8gc2V0IGZhY3RvciBzaGVldCBjb2wgd2lkdGhzXG4gICAgICAgIHZhciBjb2x1bW5zID0gW3tcbiAgICAgICAgICAgIHdjaDogOFxuICAgICAgICB9XTtcbiAgICAgICAgZm9yICh2YXIgdHQgPSAwLCB0dExlbiA9IHVzZXJTZWxlY3RlZEZhY3RvcnMubGVuZ3RoOyB0dCA8IHR0TGVuOyB0dCsrKSB7XG4gICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHdjaDogOFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29sU2l6ZXMucHVzaChjb2x1bW5zKTtcblxuICAgICAgICB2YXIgc3RhbmRhcmRFcnJvckRpZmZTaGVldEFycmF5ID0gW107XG5cbiAgICAgICAgLy8gbGluZSAxXG4gICAgICAgIHZhciBsaW5lMUFycmF5ID0gW1wiXCJdO1xuICAgICAgICB2YXIgbGluZTFBcnJheWIgPSBsaW5lMUFycmF5LmNvbmNhdCh1c2VyU2VsZWN0ZWRGYWN0b3JzKTtcbiAgICAgICAgc3RhbmRhcmRFcnJvckRpZmZTaGVldEFycmF5LnB1c2gobGluZTFBcnJheWIpO1xuXG4gICAgICAgIHZhciBzdG5kRXJyb3JEaWZmQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIHN0bmRFcnJvckRpZmZEYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIHN0bmRFcnJvckRpZmZEYXRhRGlzdGluZ0FycmF5ID0gW107XG5cbiAgICAgICAgdmFyIHN0bmRFcnJvcjEsIHN0bmRFcnJvcjIsIHN0bmRFcnJvcjM7XG5cbiAgICAgICAgLy8gbGluZXMgMiB0byBlbmRcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaWdTb3J0c0FycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5MSA9IFtdO1xuICAgICAgICAgICAgdGVtcEFycmF5MS5wdXNoKHNpZ1NvcnRzQXJyYXlbal1bXCJGYWN0b3IgTnVtYmVyXCJdKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaWdTb3J0c0FycmF5Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0bmRFcnJvckRpZmZEYXRhQXJyYXlUZW1wMSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wQXJyYXkyID0gW107XG4gICAgICAgICAgICAgICAgc3RuZEVycm9yRGlmZkRhdGFBcnJheVRlbXAxLnB1c2goXCJGYWN0b3IgXCIgKyBzaWdTb3J0c0FycmF5W2pdW1wiRmFjdG9yIE51bWJlclwiXSk7XG4gICAgICAgICAgICAgICAgdGVtcEFycmF5Mi5wdXNoKHNpZ1NvcnRzQXJyYXlbal1bXCJGYWN0b3IgTnVtYmVyXCJdKTtcbiAgICAgICAgICAgICAgICBzdG5kRXJyb3JEaWZmRGF0YUFycmF5VGVtcDEucHVzaChcIkZhY3RvciBcIiArIHNpZ1NvcnRzQXJyYXlba11bXCJGYWN0b3IgTnVtYmVyXCJdKTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkyLnB1c2goc2lnU29ydHNBcnJheVtrXVtcIkZhY3RvciBOdW1iZXJcIl0pO1xuICAgICAgICAgICAgICAgIHN0bmRFcnJvcjEgPSBzdG5kRXJyb3JBcnJheVtqXTtcbiAgICAgICAgICAgICAgICBzdG5kRXJyb3IyID0gc3RuZEVycm9yQXJyYXlba107XG4gICAgICAgICAgICAgICAgc3RuZEVycm9yMyA9IGV2ZW5Sb3VuZCgoTWF0aC5zcXJ0KChzdG5kRXJyb3IxICogc3RuZEVycm9yMSkgKyAoc3RuZEVycm9yMiAqIHN0bmRFcnJvcjIpKSksIDMpO1xuICAgICAgICAgICAgICAgIHN0bmRFcnJvckRpZmZEYXRhQXJyYXlUZW1wMS5wdXNoKHN0bmRFcnJvcjMpO1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheTIucHVzaChzdG5kRXJyb3IzKTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxLnB1c2goc3RuZEVycm9yMyk7XG4gICAgICAgICAgICAgICAgc3RuZEVycm9yRGlmZkRhdGFBcnJheS5wdXNoKHN0bmRFcnJvckRpZmZEYXRhQXJyYXlUZW1wMSk7XG4gICAgICAgICAgICAgICAgc3RuZEVycm9yRGlmZkRhdGFEaXN0aW5nQXJyYXkucHVzaCh0ZW1wQXJyYXkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YW5kYXJkRXJyb3JEaWZmU2hlZXRBcnJheS5wdXNoKHRlbXBBcnJheTEpO1xuICAgICAgICB9XG4gICAgICAgIHN0YW5kYXJkRXJyb3JEaWZmU2hlZXRBcnJheS51bnNoaWZ0KHNwYWNlciwgW2NoYXJ0VGV4dDJdLCBzcGFjZXIpO1xuICAgICAgICBvdXRwdXREYXRhLnB1c2goc3RhbmRhcmRFcnJvckRpZmZTaGVldEFycmF5KTtcblxuICAgICAgICBwdXNoRGlzdGluZ3Vpc2hpbmdTdGF0ZW1lbnRzVG9PdXRwdXQoc2hlZXROYW1lcywgb3V0cHV0LCBzaWdTb3J0c0FycmF5LCBhbmFseXNpc091dHB1dCwgc3RuZEVycm9yRGlmZkRhdGFBcnJheSwgc3RuZEVycm9yRGlmZkRhdGFEaXN0aW5nQXJyYXksIHNpZ0ZhY3Rvck51bWJlcnNBcnJheSwgb3V0cHV0RGF0YSwgc2hlZXROYW1lc1hsc3gsIGNvbFNpemVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXNoRGlzdGluZ3Vpc2hpbmdTdGF0ZW1lbnRzVG9PdXRwdXQoc2hlZXROYW1lcywgb3V0cHV0LCBzaWdTb3J0c0FycmF5LCBhbmFseXNpc091dHB1dCwgc3RuZEVycm9yRGlmZkRhdGFBcnJheSwgc3RuZEVycm9yRGlmZkRhdGFEaXN0aW5nQXJyYXksIHNpZ0ZhY3Rvck51bWJlcnNBcnJheSwgb3V0cHV0RGF0YSwgc2hlZXROYW1lc1hsc3gsIGNvbFNpemVzKSB7XG5cbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBjaGFydFRleHQxID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIkRpc3QgU3RhdGVcIl07XG4gICAgICAgIHZhciBjaGFydFRleHQyID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIkNvbnNlbnN1cyBTdGF0ZW1lbnRzXCJdO1xuICAgICAgICB2YXIgbWF4U3RhdGVtZW50TGVuZ3RoID0gUUFWLmdldFN0YXRlKFwibWF4U3RhdGVtZW50TGVuZ3RoXCIpO1xuICAgICAgICB2YXIgdXNlclNlbGVjdGVkRmFjdG9ycyA9IFFBVi5nZXRTdGF0ZShcInVzZXJTZWxlY3RlZEZhY3RvcnNcIik7XG5cbiAgICAgICAgLy8gcHJvcGVydHkgdG8gY291bnQgbG9vcCBpdGVyYXRpb25zIGZvciBhc3NpZ25pbmcgc2lnbmlmaWNhbmNlICogaW4gZGlzdGluZyBmYWN0b3Igb3V0cHV0XG4gICAgICAgIGZvcm1hdERpc3RpbmdBcnJheUZvckRvd25sb2FkLmNhbGxlZFRpbWVzID0gMDtcblxuICAgICAgICAvLyBsb29wIHRvIHNldCB1cCB3b3Jrc2hlZXQgbmFtZXMgYW5kIHB1c2ggaW50byBvdXRwdXQgYXJyYXlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdTb3J0c0FycmF5Lmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIHNoZWV0TmFtZXNYbHN4LnB1c2goY2hhcnRUZXh0MSArIHNpZ1NvcnRzQXJyYXlbaV1bXCJGYWN0b3IgTnVtYmVyXCJdKTtcblxuICAgICAgICAgICAgLy8gc2V0IHVwIGNvbCB3aWR0aHMgZm9yIGV4Y2VsIG91dHB1dCAtIHRvZG8gLSBjaGFuZ2UgbWF4U3RhdGVtZW50TGVuZ3RoP1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBbe1xuICAgICAgICAgICAgICAgIHdjaDogOFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHdjaDogbWF4U3RhdGVtZW50TGVuZ3RoXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgd2NoOiA4XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIGZvciAodmFyIHR0ID0gMCwgdHRMZW4gPSB1c2VyU2VsZWN0ZWRGYWN0b3JzLmxlbmd0aDsgdHQgPCB0dExlbjsgdHQrKykge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHdjaDogOFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgd2NoOiA4XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB3Y2g6IDhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbFNpemVzLnB1c2goY29sdW1ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdGFydGluZyBjYWxjcyBmb3IgZGlzdGluZ3Vpc2hpbmcgZmFjdG9yc1xuICAgICAgICB2YXIgc2VkQ29tcGFyaXNvblZhbHVlLCBqLCBrLCBtO1xuICAgICAgICB2YXIgY29uc2Vuc3VzU3RhdGVtZW50Q29tcGFyaXNvbkFycmF5MDUgPSBbXTtcbiAgICAgICAgdmFyIGNvbnNlbnN1c1N0YXRlbWVudENvbXBhcmlzb25BcnJheTAxID0gW107XG4gICAgICAgIHZhciBkaXN0U3RhdGVtZW50RGF0YVZpekFycmF5ID0gW107XG4gICAgICAgIHZhciBtYXN0ZXJEaXN0aW5nU3RhdGVtZW50TnVtYmVyc0FycmF5MDUgPSBbXTtcbiAgICAgICAgdmFyIG1hc3RlckRpc3RpbmdTdGF0ZW1lbnROdW1iZXJzQXJyYXkwMSA9IFtdO1xuXG4gICAgICAgIC8vIGxvb3BpbmcgdGhyb3VnaCBhbGwgZmFjdG9ycyB0byBkZXRlcm1pbmUgaWYgZGlzdGluZ3Vpc2hpbmchXG4gICAgICAgIC8vIHRvZG8gLSBjcmVhdGUgaWYgc3RhdGVtZW50IGZvciBjYXNlIG9mIG9ubHkgdHdvIHNpZyBmYWN0b3JzLWJ5cGFzcyBwcm9jZXNzaW5nIG9mIHNlY29uZCBjIDQ4OTRcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHNpZ1NvcnRzQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIC8vIGZhY3RvciBqXG4gICAgICAgICAgICAvLyBsb29waW5nIHRocm91Z2ggYWxsIHN0YXRlbWVudHMgaW4gZWFjaCBqIGZhY3RvclxuICAgICAgICAgICAgdmFyIGRpc3RpbmdTdGF0ZW1lbnRzVHJhbnNmZXJBcnJheTA1ID0gW107XG4gICAgICAgICAgICB2YXIgZGlzdGluZ1N0YXRlbWVudHNUcmFuc2ZlckFycmF5MDEgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb25zZW5zdXNTdGF0ZW1lbnRUcmFuc2ZlckFycmF5MDUgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb25zZW5zdXNTdGF0ZW1lbnRUcmFuc2ZlckFycmF5MDEgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGFuYWx5c2lzT3V0cHV0WzBdLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9vcGluZyB0aHJvdWdoIGVhY2ggc3RhdGVtZW50J3Mgb3RoZXIgZmFjdG9yIHpTY29yZXMgdG8gY29tcGFyZVxuICAgICAgICAgICAgICAgIC8vIGFsc28gZ3JhYmJpbmcgdGhlIGFwcHJvcHJpYXRlIFNFRCB2YWx1ZSBmb3IgZWFjaCBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgdmFyIHNpZzA1ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHNpZzA1QXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgc2lnMDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgc2lnMDFBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBuZXdTdGF0ZW1lbnROdW07XG5cbiAgICAgICAgICAgICAgICBmb3IgKG0gPSAwOyBtIDwgc2lnU29ydHNBcnJheS5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWN0b3IgbVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0byBhdm9pZCBjb21wYXJpc29uIHdpdGggc2VsZlxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5hbHlzaXNPdXRwdXRbal1ba10uZmFjdG9yID09PSBhbmFseXNpc091dHB1dFttXVtrXS5mYWN0b3IpIHt9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIFNFRCBhcnJheSB0byBmaW5kIGNvbXBhcmlzb24gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZENvbXBhcmlzb25WYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgc3RuZEVycm9yRGlmZkRhdGFEaXN0aW5nQXJyYXkubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VhcmNoVmFsMSA9IHN0bmRFcnJvckRpZmZEYXRhRGlzdGluZ0FycmF5W3BdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2hWYWwyID0gc3RuZEVycm9yRGlmZkRhdGFEaXN0aW5nQXJyYXlbcF1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9ySlNoaWZ0ID0gc2lnRmFjdG9yTnVtYmVyc0FycmF5W2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvck1TaGlmdCA9IHNpZ0ZhY3Rvck51bWJlcnNBcnJheVttXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hWYWwxID09PSBpdGVyYXRvckpTaGlmdCAmJiBzZWFyY2hWYWwyID09PSBpdGVyYXRvck1TaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWRDb21wYXJpc29uVmFsdWUgPSBzdG5kRXJyb3JEaWZmRGF0YURpc3RpbmdBcnJheVtwXVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhhbmFseXNpc091dHB1dFtqXVtrXS56U2NvcmUgLSBhbmFseXNpc091dHB1dFttXVtrXS56U2NvcmUpID49IChzZWRDb21wYXJpc29uVmFsdWUgKiAxLjk2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuYWx5c2lzT3V0cHV0W2pdW2tdLnpTY29yZSA9IGV2ZW5Sb3VuZCgoYW5hbHlzaXNPdXRwdXRbal1ba10uelNjb3JlKSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnMDUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZzA1QXJyYXkucHVzaChzaWcwNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhhbmFseXNpc091dHB1dFtqXVtrXS56U2NvcmUgLSBhbmFseXNpc091dHB1dFttXVtrXS56U2NvcmUpID49IChzZWRDb21wYXJpc29uVmFsdWUgKiAyLjU4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuYWx5c2lzT3V0cHV0W2pdW2tdLnpTY29yZSA9IGV2ZW5Sb3VuZCgoYW5hbHlzaXNPdXRwdXRbal1ba10uelNjb3JlKSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnMDEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZzAxQXJyYXkucHVzaChzaWcwMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdTdGF0ZW1lbnROdW0gPSBrICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChzaWcwNUFycmF5Lmxlbmd0aCA9PT0gKHNpZ0ZhY3Rvck51bWJlcnNBcnJheS5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0aW5nU3RhdGVtZW50c1RyYW5zZmVyQXJyYXkwNS5wdXNoKG5ld1N0YXRlbWVudE51bSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNpZzAxQXJyYXkubGVuZ3RoID09PSAoc2lnRmFjdG9yTnVtYmVyc0FycmF5Lmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RpbmdTdGF0ZW1lbnRzVHJhbnNmZXJBcnJheTAxLnB1c2gobmV3U3RhdGVtZW50TnVtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2lnMDVBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc2Vuc3VzU3RhdGVtZW50VHJhbnNmZXJBcnJheTA1LnB1c2gobmV3U3RhdGVtZW50TnVtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2lnMDFBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc2Vuc3VzU3RhdGVtZW50VHJhbnNmZXJBcnJheTAxLnB1c2gobmV3U3RhdGVtZW50TnVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXN0aW5nU3RhdGVtZW50c1RyYW5zZmVyQXJyYXkwNWIgPSBfLnVuaXEoZGlzdGluZ1N0YXRlbWVudHNUcmFuc2ZlckFycmF5MDUsIHRydWUpO1xuICAgICAgICAgICAgdmFyIGRpc3RpbmdTdGF0ZW1lbnRzVHJhbnNmZXJBcnJheTAxYiA9IF8udW5pcShkaXN0aW5nU3RhdGVtZW50c1RyYW5zZmVyQXJyYXkwMSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgZGlzdGluZ1N0YXRlbWVudHNUcmFuc2ZlckFycmF5MDVjID0gXy5kaWZmZXJlbmNlKGRpc3RpbmdTdGF0ZW1lbnRzVHJhbnNmZXJBcnJheTA1YiwgZGlzdGluZ1N0YXRlbWVudHNUcmFuc2ZlckFycmF5MDFiKTtcblxuICAgICAgICAgICAgbWFzdGVyRGlzdGluZ1N0YXRlbWVudE51bWJlcnNBcnJheTA1LnB1c2goZGlzdGluZ1N0YXRlbWVudHNUcmFuc2ZlckFycmF5MDVjKTtcbiAgICAgICAgICAgIG1hc3RlckRpc3RpbmdTdGF0ZW1lbnROdW1iZXJzQXJyYXkwMS5wdXNoKGRpc3RpbmdTdGF0ZW1lbnRzVHJhbnNmZXJBcnJheTAxYik7XG5cbiAgICAgICAgICAgIGNvbnNlbnN1c1N0YXRlbWVudENvbXBhcmlzb25BcnJheTA1LnB1c2goY29uc2Vuc3VzU3RhdGVtZW50VHJhbnNmZXJBcnJheTA1KTtcbiAgICAgICAgICAgIGNvbnNlbnN1c1N0YXRlbWVudENvbXBhcmlzb25BcnJheTAxLnB1c2goY29uc2Vuc3VzU3RhdGVtZW50VHJhbnNmZXJBcnJheTAxKTtcblxuICAgICAgICAgICAgdmFyIGZhY3Rvck51bWJlciA9IHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtqXTtcblxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZERpc3RpbmdTdGF0ZW1lbnRzID0gZm9ybWF0RGlzdGluZ0FycmF5Rm9yRG93bmxvYWQoZGlzdGluZ1N0YXRlbWVudHNUcmFuc2ZlckFycmF5MDFiLCBkaXN0aW5nU3RhdGVtZW50c1RyYW5zZmVyQXJyYXkwNWMsIGZhY3Rvck51bWJlciwgYW5hbHlzaXNPdXRwdXQsIHNpZ0ZhY3Rvck51bWJlcnNBcnJheSk7XG5cbiAgICAgICAgICAgIGRpc3RTdGF0ZW1lbnREYXRhVml6QXJyYXkucHVzaChmb3JtYXR0ZWREaXN0aW5nU3RhdGVtZW50c1swXSk7XG5cbiAgICAgICAgICAgIG91dHB1dERhdGEucHVzaChmb3JtYXR0ZWREaXN0aW5nU3RhdGVtZW50c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBRQVYuc2V0U3RhdGUoXCJtYXN0ZXJEaXN0aW5nU3RhdGVtZW50TnVtYmVyc0FycmF5MDFcIiwgbWFzdGVyRGlzdGluZ1N0YXRlbWVudE51bWJlcnNBcnJheTAxKTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwibWFzdGVyRGlzdGluZ1N0YXRlbWVudE51bWJlcnNBcnJheTA1XCIsIG1hc3RlckRpc3RpbmdTdGF0ZW1lbnROdW1iZXJzQXJyYXkwNSk7XG5cbiAgICAgICAgLy8gKioqKioqXG4gICAgICAgIC8vIGRldmVsb3AgY29uc2Vuc3VzIHN0YXRlbWVudCBkYXRhXG4gICAgICAgIC8vICoqKioqKlxuICAgICAgICAvL3ZhciBvdXRwdXRGb3JEYXRhVml6ID0gXy5jbG9uZURlZXAoYW5hbHlzaXNPdXRwdXQpO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJkaXN0U3RhdGVtZW50RGF0YVZpekFycmF5XCIsIGRpc3RTdGF0ZW1lbnREYXRhVml6QXJyYXkpO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJvdXRwdXRGb3JEYXRhVml6XCIsIGFuYWx5c2lzT3V0cHV0KTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zZW5zdXNTdGF0ZW1lbnRDb21wYXJpc29uQXJyYXkwNSA9IHJlZHVjZURpc3RpbmdBcnJheShjb25zZW5zdXNTdGF0ZW1lbnRDb21wYXJpc29uQXJyYXkwNSk7XG4gICAgICAgIH0gd2hpbGUgKGNvbnNlbnN1c1N0YXRlbWVudENvbXBhcmlzb25BcnJheTA1Lmxlbmd0aCA+IDEpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnNlbnN1c1N0YXRlbWVudENvbXBhcmlzb25BcnJheTAxID0gcmVkdWNlRGlzdGluZ0FycmF5KGNvbnNlbnN1c1N0YXRlbWVudENvbXBhcmlzb25BcnJheTAxKTtcbiAgICAgICAgfSB3aGlsZSAoY29uc2Vuc3VzU3RhdGVtZW50Q29tcGFyaXNvbkFycmF5MDEubGVuZ3RoID4gMSk7XG5cbiAgICAgICAgdmFyIGNvbnNlbnN1czA1ID0gXy5mbGF0dGVuKGNvbnNlbnN1c1N0YXRlbWVudENvbXBhcmlzb25BcnJheTA1KTtcbiAgICAgICAgdmFyIGNvbnNlbnN1c1N0YXRlbWVudENvbXBhcmlzb25BcnJheTAxYiA9IF8uZmxhdHRlbihjb25zZW5zdXNTdGF0ZW1lbnRDb21wYXJpc29uQXJyYXkwMSk7XG5cbiAgICAgICAgdmFyIGNvbnNlbnN1czAxID0gXy54b3IoY29uc2Vuc3VzMDUsIGNvbnNlbnN1c1N0YXRlbWVudENvbXBhcmlzb25BcnJheTAxYik7XG5cbiAgICAgICAgUUFWLnNldFN0YXRlKFwiY29uc2Vuc3VzMDVTdGF0ZW1lbnRzXCIsIGNvbnNlbnN1czA1KTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwiY29uc2Vuc3VzMDFTdGF0ZW1lbnRzXCIsIGNvbnNlbnN1czAxKTtcblxuICAgICAgICBzaGVldE5hbWVzWGxzeC5wdXNoKGNoYXJ0VGV4dDIpO1xuXG4gICAgICAgIC8vIHNldCB1cCBjb2wgd2lkdGhzIGZvciBleGNlbCBvdXRwdXRcbiAgICAgICAgdmFyIGNvbHVtbnMyID0gW3tcbiAgICAgICAgICAgIHdjaDogMTJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgd2NoOiAxMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB3Y2g6IG1heFN0YXRlbWVudExlbmd0aFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB3Y2g6IDEyXG4gICAgICAgIH1dO1xuICAgICAgICBmb3IgKHZhciB0dHQgPSAwLCB0dHRMZW4gPSB1c2VyU2VsZWN0ZWRGYWN0b3JzLmxlbmd0aDsgdHR0IDwgdHR0TGVuOyB0dHQrKykge1xuICAgICAgICAgICAgY29sdW1uczIucHVzaCh7XG4gICAgICAgICAgICAgICAgd2NoOiAxMlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHdjaDogMTVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB3Y2g6IDE1XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb2xTaXplcy5wdXNoKGNvbHVtbnMyKTtcblxuICAgICAgICB2YXIgZm9ybWF0dGVkQ29uc2Vuc3VzU3RhdGVtZW50cyA9IGZvcm1hdENvbnNlbnN1c0FycmF5Rm9yRG93bmxvYWQoY29uc2Vuc3VzMDUsIGNvbnNlbnN1czAxLCBhbmFseXNpc091dHB1dCwgc2lnRmFjdG9yTnVtYmVyc0FycmF5KTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwiZm9ybWF0dGVkQ29uc2Vuc3VzU3RhdGVtZW50c1wiLCBmb3JtYXR0ZWRDb25zZW5zdXNTdGF0ZW1lbnRzWzBdKTtcblxuICAgICAgICBvdXRwdXREYXRhLnB1c2goZm9ybWF0dGVkQ29uc2Vuc3VzU3RhdGVtZW50c1sxXSk7XG5cbiAgICAgICAgcHVzaENyaWJTaGVldHNUb091dHB1dChzaGVldE5hbWVzLCBvdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaENyaWJTaGVldHNUb091dHB1dChzaGVldE5hbWVzLCBvdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcykge1xuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQxID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIiBSZWwuIFJhbmtzXCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDIgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiUmVsYXRpdmUgUmFua2luZyBvZiBTdGF0ZW1lbnRzIGluIFwiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQzID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlN0YXRlbWVudCBOdW1iZXJcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJaLXNjb3JlXCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDkgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLkRpc3Rpbmd1aXNoaW5nO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDggPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uLkNvbnNlbnN1cztcbiAgICAgICAgdmFyIGFwcGVuZFRleHRIZWFkZXIxID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIkhpZ2hlc3QgUmFua2VkIFN0YXRlbWVudHNcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0SGVhZGVyMmEgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiUG9zaXRpdmUgU3RhdGVtZW50cyBSYW5rZWQgSGlnaGVyIGluIFwiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHRIZWFkZXIyYiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJBcnJheSB0aGFuIGluIE90aGVyIEZhY3RvciBBcnJheXNcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0SGVhZGVyM2EgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiTmVnYXRpdmUgU3RhdGVtZW50cyBSYW5rZWQgTG93ZXIgaW4gXCJdO1xuICAgICAgICB2YXIgYXBwZW5kVGV4dEhlYWRlcjNiID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIkFycmF5IHRoYW4gaW4gT3RoZXIgRmFjdG9yIEFycmF5c0JcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0SGVhZGVyNCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJMb3dlc3QgUmFua2VkIFN0YXRlbWVudHNcIl07XG4gICAgICAgIHZhciBtYXhTdGF0ZW1lbnRMZW5ndGggPSBRQVYuZ2V0U3RhdGUoXCJtYXhTdGF0ZW1lbnRMZW5ndGhcIik7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uU3RhdGVtZW50O1xuICAgICAgICB2YXIgYXBwZW5kVGV4dDcgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiU29ydCBWYWx1ZXNcIl07XG4gICAgICAgIC8vIHZhciBhcHBlbmRUZXh0OCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJOb3RlOiBcIl07XG5cbiAgICAgICAgdmFyIHN0YXRlbWVudFJhbmtpbmdBcnJheSA9IFFBVi5nZXRTdGF0ZShcInN0YXRlbWVudFJhbmtpbmdBcnJheVwiKTtcbiAgICAgICAgdmFyIHVzZXJTZWxlY3RlZEZhY3RvcnMgPSBRQVYuZ2V0U3RhdGUoXCJ1c2VyU2VsZWN0ZWRGYWN0b3JzXCIpO1xuICAgICAgICB2YXIgZmFjdG9ySW5mb3JtYXRpb24sXG4gICAgICAgICAgICBsb3dlc3RSYW5rU3RhdGVtZW50cyxcbiAgICAgICAgICAgIHRlbXBPYmoxLFxuICAgICAgICAgICAgY3JpYkFycmF5ID0gW107XG4gICAgICAgIHZhciBjcmliQXJyYXkyID0gW107XG4gICAgICAgIHZhciBoaWdoZXN0UmFua1N0YXRlbWVudHMsXG4gICAgICAgICAgICB0ZW1wT2JqMixcbiAgICAgICAgICAgIHRlbXBPYmozLFxuICAgICAgICAgICAgdGVtcE9iajQ7XG4gICAgICAgIHZhciBtYXhSYW5rVmFsdWUsXG4gICAgICAgICAgICBtaW5SYW5rVmFsdWUsXG4gICAgICAgICAgICBjb21wb3NpdGVTb3J0VmFsdWUsXG4gICAgICAgICAgICBjb21wb3NpdGVTb3J0VmFsdWUyO1xuICAgICAgICB2YXIgY3VycmVudFJhbmssXG4gICAgICAgICAgICBjdXJyZW50UmFuazI7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBudW1iZXIgb2Ygc3RhdGVtZW50cyBpbiB0aGUgZXh0cmVtZSBjb2x1bW5zXG4gICAgICAgIHZhciBzb3J0VHJpYW5nbGVTaGFwZSA9IFFBVi5nZXRTdGF0ZShcInFhdlNvcnRUcmlhbmdsZVNoYXBlXCIpO1xuICAgICAgICB2YXIgc3luRmFjdG9yQXJyYXkxSG9sZGVyID0gUUFWLmdldFN0YXRlKFwic3luRmFjdG9yQXJyYXkxSG9sZGVyXCIpO1xuXG4gICAgICAgIHZhciBhcnJheU1heCA9ICsoXy5tYXgoc29ydFRyaWFuZ2xlU2hhcGUpKTtcbiAgICAgICAgdmFyIGFycmF5TWluID0gKyhfLm1pbihzb3J0VHJpYW5nbGVTaGFwZSkpO1xuICAgICAgICB2YXIgdHJpYW5nbGVDb3VudHMgPSBfLmNvdW50Qnkoc29ydFRyaWFuZ2xlU2hhcGUsIF8uaWRlbnRpdHkpO1xuXG4gICAgICAgIHZhciBtYXhDb3VudHMgPSB0cmlhbmdsZUNvdW50c1thcnJheU1heF07XG4gICAgICAgIHZhciBtaW5Db3VudHMgPSB0cmlhbmdsZUNvdW50c1thcnJheU1pbl07XG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGZhY3RvcnNcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSB1c2VyU2VsZWN0ZWRGYWN0b3JzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuXG4gICAgICAgICAgICBzaGVldE5hbWVzWGxzeC5wdXNoKHVzZXJTZWxlY3RlZEZhY3RvcnNbal0gKyBhcHBlbmRUZXh0MSk7XG5cbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gW3tcbiAgICAgICAgICAgICAgICB3Y2g6IDhcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB3Y2g6IDgwXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgd2NoOiA4XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgd2NoOiAxMlxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBjb2xTaXplcy5wdXNoKGNvbHVtbnMpO1xuXG4gICAgICAgICAgICBjcmliQXJyYXkgPSBbXG4gICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGNyaWJBcnJheTIgPSBbXG4gICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGZhY3RvckluZm9ybWF0aW9uID0gXy5jbG9uZURlZXAoc3luRmFjdG9yQXJyYXkxSG9sZGVyW2pdKTtcblxuICAgICAgICAgICAgLy8gc29ydCBieSBzdGF0ZW1lbnQgbnVtYmVyXG4gICAgICAgICAgICBmYWN0b3JJbmZvcm1hdGlvbi5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVthcHBlbmRUZXh0M10gLSBiW2FwcGVuZFRleHQzXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGZhY3RvckluZm9ybWF0aW9uKSk7XG5cbiAgICAgICAgICAgIC8vIGFwcGVuZCB0aGUgcmFua2luZyBhcnJheXNcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrTGVuID0gZmFjdG9ySW5mb3JtYXRpb24ubGVuZ3RoOyBrIDwga0xlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9ySW5mb3JtYXRpb25ba10ucmFua0FycmF5ID0gc3RhdGVtZW50UmFua2luZ0FycmF5W2tdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXNvcnQgYmFjayB0byBoaWdoIHRvIGxvdyB6LXNjb3JlIHNvcnRcbiAgICAgICAgICAgIGZhY3RvckluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYlthcHBlbmRUZXh0NV0gPT09IGFbYXBwZW5kVGV4dDVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVthcHBlbmRUZXh0M10gLSBiW2FwcGVuZFRleHQzXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiW2FwcGVuZFRleHQ1XSAtIGFbYXBwZW5kVGV4dDVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHB1c2ggaGlnaGVzdCB0byBjcmliQXJyYXlcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbWluQ291bnRzOyBtKyspIHtcbiAgICAgICAgICAgICAgICAvLyB0ZW1wT2JqMSA9IHt9O1xuICAgICAgICAgICAgICAgIGhpZ2hlc3RSYW5rU3RhdGVtZW50cyA9IGZhY3RvckluZm9ybWF0aW9uLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlTnVtMCA9IGhpZ2hlc3RSYW5rU3RhdGVtZW50c1thcHBlbmRUZXh0M107XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlbWVudDAgPSBoaWdoZXN0UmFua1N0YXRlbWVudHNbYXBwZW5kVGV4dDZdO1xuICAgICAgICAgICAgICAgIHZhciBjaGVja0lmRGlzT3JDb24wID0gY2hlY2tJZkRpc3Rpbmd1aXNoaW5nT3JDb25zZW5zdXMoc3RhdGVOdW0wLCBqKTtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9zaXRlU29ydFZhbHVlMCA9IGhpZ2hlc3RSYW5rU3RhdGVtZW50c1thcHBlbmRUZXh0N107XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyVmFsdWVzID0gXy5jbG9uZShoaWdoZXN0UmFua1N0YXRlbWVudHMucmFua0FycmF5KTtcbiAgICAgICAgICAgICAgICBvdGhlclZhbHVlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5MCA9IFtzdGF0ZU51bTAsIHN0YXRlbWVudDAsIGNvbXBvc2l0ZVNvcnRWYWx1ZTAsIGNoZWNrSWZEaXNPckNvbjBdO1xuICAgICAgICAgICAgICAgIHZhciBhcnJheTBhID0gYXJyYXkwLmNvbmNhdChvdGhlclZhbHVlcyk7XG4gICAgICAgICAgICAgICAgY3JpYkFycmF5MlswXS5wdXNoKGFycmF5MGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwdXNoIGxvd2VzdCB0byBjcmliQXJyYXlcbiAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgbWF4Q291bnRzOyBwKyspIHtcbiAgICAgICAgICAgICAgICAvLyB0ZW1wT2JqMiA9IHt9O1xuICAgICAgICAgICAgICAgIGxvd2VzdFJhbmtTdGF0ZW1lbnRzID0gZmFjdG9ySW5mb3JtYXRpb24ucG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlTnVtMyA9IGxvd2VzdFJhbmtTdGF0ZW1lbnRzW2FwcGVuZFRleHQzXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVtZW50MyA9IGxvd2VzdFJhbmtTdGF0ZW1lbnRzW2FwcGVuZFRleHQ2XTtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tJZkRpc09yQ29uMyA9IGNoZWNrSWZEaXN0aW5ndWlzaGluZ09yQ29uc2Vuc3VzKHN0YXRlTnVtMywgaik7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvc2l0ZVNvcnRWYWx1ZTMgPSBsb3dlc3RSYW5rU3RhdGVtZW50c1thcHBlbmRUZXh0N107XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyVmFsdWVzMyA9IF8uY2xvbmUobG93ZXN0UmFua1N0YXRlbWVudHMucmFua0FycmF5KTtcbiAgICAgICAgICAgICAgICBvdGhlclZhbHVlczMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIHZhciBhcnJheTMgPSBbc3RhdGVOdW0zLCBzdGF0ZW1lbnQzLCBjb21wb3NpdGVTb3J0VmFsdWUzLCBjaGVja0lmRGlzT3JDb24zXTtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkzYSA9IGFycmF5My5jb25jYXQob3RoZXJWYWx1ZXMzKTtcblxuICAgICAgICAgICAgICAgIGNyaWJBcnJheTJbM10udW5zaGlmdChhcnJheTNhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbG9vayBmb3IgaGlnaGVyIHJlbGF0aXZlIHN0YXRlbWVudHMgYW5kIHB1c2ggdG8gY3JpYkFycmF5XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMCwgckxlbiA9IGZhY3RvckluZm9ybWF0aW9uLmxlbmd0aDsgciA8IHJMZW47IHIrKykge1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVNvcnRWYWx1ZSA9IGZhY3RvckluZm9ybWF0aW9uW3JdW2FwcGVuZFRleHQ3XTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRlU29ydFZhbHVlID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4UmFua1ZhbHVlID0gXy5tYXgoZmFjdG9ySW5mb3JtYXRpb25bcl0ucmFua0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvc2l0ZVNvcnRWYWx1ZSA9PT0gbWF4UmFua1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJWYWx1ZXMyID0gXy5jbG9uZShmYWN0b3JJbmZvcm1hdGlvbltyXS5yYW5rQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJWYWx1ZXMyLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZU51bSA9IGZhY3RvckluZm9ybWF0aW9uW3JdW2FwcGVuZFRleHQzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGVja0lmRGlzT3JDb24gPSBjaGVja0lmRGlzdGluZ3Vpc2hpbmdPckNvbnNlbnN1cyhzdGF0ZU51bSwgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcEFycmF5MjIgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVOdW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZhY3RvckluZm9ybWF0aW9uW3JdW2FwcGVuZFRleHQ2XSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBvc2l0ZVNvcnRWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tJZkRpc09yQ29uXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbWJpbmVkQXJyYXkxID0gdGVtcEFycmF5MjIuY29uY2F0KG90aGVyVmFsdWVzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmliQXJyYXkyWzFdLnB1c2goY29tYmluZWRBcnJheTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wb3NpdGVTb3J0VmFsdWUgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblJhbmtWYWx1ZSA9IF8ubWluKGZhY3RvckluZm9ybWF0aW9uW3JdLnJhbmtBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5rMiA9IGZhY3RvckluZm9ybWF0aW9uW3JdLnJhbmtBcnJheVtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvc2l0ZVNvcnRWYWx1ZSA9PT0gbWluUmFua1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJWYWx1ZXNMb3dlciA9IF8uY2xvbmUoZmFjdG9ySW5mb3JtYXRpb25bcl0ucmFua0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyVmFsdWVzTG93ZXIuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlTnVtMiA9IGZhY3RvckluZm9ybWF0aW9uW3JdW2FwcGVuZFRleHQzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGVja0lmRGlzT3JDb24yID0gY2hlY2tJZkRpc3Rpbmd1aXNoaW5nT3JDb25zZW5zdXMoc3RhdGVOdW0yLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wQXJyYXkzMyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU51bTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZhY3RvckluZm9ybWF0aW9uW3JdW2FwcGVuZFRleHQ2XSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBvc2l0ZVNvcnRWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tJZkRpc09yQ29uMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21iaW5lZEFycmF5MiA9IHRlbXBBcnJheTMzLmNvbmNhdChvdGhlclZhbHVlc0xvd2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyaWJBcnJheTJbMl0ucHVzaChjb21iaW5lZEFycmF5Mik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzcGFjZXJBcnJheSA9IFtcIlwiLCBcIlwiXTtcblxuICAgICAgICAgICAgLy8gY29uc3RydWN0IGhlYWRlcnMgZm9yIHN0YXRlbWVudCBncm91cHNcbiAgICAgICAgICAgIHZhciBmYWNOYW1lID0gdXNlclNlbGVjdGVkRmFjdG9yc1tqXTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGNvbHVtbiBoZWFkZXJzIGZvciBvdGhlciBmYWN0b3JzXG4gICAgICAgICAgICB2YXIgb3RoZXJGYWN0b3JOYW1lcyA9IF8uY2xvbmUodXNlclNlbGVjdGVkRmFjdG9ycyk7XG4gICAgICAgICAgICBvdGhlckZhY3Rvck5hbWVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgIHZhciBoaWdoZXJSYW5rZWRIZWFkZXIgPSBbXG4gICAgICAgICAgICAgICAgXCJcIiwgYXBwZW5kVGV4dEhlYWRlcjJhICsgZmFjTmFtZSArIGFwcGVuZFRleHRIZWFkZXIyYlxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcjEgPSBbXG4gICAgICAgICAgICAgICAgXCJcIiwgYXBwZW5kVGV4dDIgKyBmYWNOYW1lXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGhlYWRlcjAgPSBbXCJcIiwgYXBwZW5kVGV4dEhlYWRlcjEsIGZhY05hbWUsIGFwcGVuZFRleHQ5XS5jb25jYXQob3RoZXJGYWN0b3JOYW1lcyk7XG4gICAgICAgICAgICBjcmliQXJyYXkyWzBdLnVuc2hpZnQoc3BhY2VyQXJyYXksIGhlYWRlcjEsIFtcbiAgICAgICAgICAgICAgICBcIlwiLCBcIlwiLCBcIlwiLCBhcHBlbmRUZXh0OFxuICAgICAgICAgICAgXSwgaGVhZGVyMCk7XG5cbiAgICAgICAgICAgIGNyaWJBcnJheTJbMV0udW5zaGlmdChzcGFjZXJBcnJheSwgaGlnaGVyUmFua2VkSGVhZGVyKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcjMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlcjMuc3RhdGVOdW0gPSBcIlwiO1xuICAgICAgICAgICAgaGVhZGVyMy5zdGF0ZW1lbnQgPSBhcHBlbmRUZXh0SGVhZGVyM2EgKyBmYWNOYW1lICsgYXBwZW5kVGV4dEhlYWRlcjNiO1xuICAgICAgICAgICAgaGVhZGVyMy5zb3J0VmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgY3JpYkFycmF5MlsyXS51bnNoaWZ0KHNwYWNlckFycmF5LCBbXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgICAgICAoYXBwZW5kVGV4dEhlYWRlcjNhICsgZmFjTmFtZSArIGFwcGVuZFRleHRIZWFkZXIzYiksXG4gICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXI0ID0ge307XG4gICAgICAgICAgICBoZWFkZXI0LnN0YXRlTnVtID0gXCJcIjtcbiAgICAgICAgICAgIGhlYWRlcjQuc3RhdGVtZW50ID0gYXBwZW5kVGV4dEhlYWRlcjQ7XG4gICAgICAgICAgICBoZWFkZXI0LnNvcnRWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBjcmliQXJyYXkyWzNdLnVuc2hpZnQoc3BhY2VyQXJyYXksIFtcIlwiLCAoYXBwZW5kVGV4dEhlYWRlcjQpLCBcIlwiXSk7XG5cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKF8uZmxhdHRlbkRlZXAoY3JpYkFycmF5KSk7XG4gICAgICAgICAgICBvdXRwdXREYXRhLnB1c2goXy5mbGF0dGVuKGNyaWJBcnJheTIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhlbHBlciBmdW5jdGlvblxuICAgICAgICBmdW5jdGlvbiBjaGVja0lmRGlzdGluZ3Vpc2hpbmdPckNvbnNlbnN1cyhzdGF0ZW1lbnROdW1iZXIsIGxvb3BOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBtYXN0ZXJEaXN0aW5nU3RhdGVtZW50TnVtYmVyc0FycmF5MDEgPSBRQVYuZ2V0U3RhdGUoXCJtYXN0ZXJEaXN0aW5nU3RhdGVtZW50TnVtYmVyc0FycmF5MDFcIik7XG4gICAgICAgICAgICB2YXIgbWFzdGVyRGlzdGluZ1N0YXRlbWVudE51bWJlcnNBcnJheTA1ID0gUUFWLmdldFN0YXRlKFwibWFzdGVyRGlzdGluZ1N0YXRlbWVudE51bWJlcnNBcnJheTA1XCIpO1xuICAgICAgICAgICAgdmFyIGNvbnNlbnN1czA1ID0gUUFWLmdldFN0YXRlKFwiY29uc2Vuc3VzMDVTdGF0ZW1lbnRzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnNlbnN1czAxID0gUUFWLmdldFN0YXRlKFwiY29uc2Vuc3VzMDFTdGF0ZW1lbnRzXCIpO1xuICAgICAgICAgICAgaWYgKF8uY29udGFpbnMobWFzdGVyRGlzdGluZ1N0YXRlbWVudE51bWJlcnNBcnJheTA1W2xvb3BOdW1iZXJdLCBzdGF0ZW1lbnROdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiICBEXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uY29udGFpbnMoY29uc2Vuc3VzMDEsIHN0YXRlbWVudE51bWJlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIgIENcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5jb250YWlucyhtYXN0ZXJEaXN0aW5nU3RhdGVtZW50TnVtYmVyc0FycmF5MDFbbG9vcE51bWJlcl0sIHN0YXRlbWVudE51bWJlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIgIEQqXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uY29udGFpbnMoY29uc2Vuc3VzMDUsIHN0YXRlbWVudE51bWJlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIgIEMqXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1c2hTZXR0aW5nc1RvT3V0cHV0KHNoZWV0TmFtZXMsIG91dHB1dCwgb3V0cHV0RGF0YSwgc2hlZXROYW1lc1hsc3gsIGNvbFNpemVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXNoU2V0dGluZ3NUb091dHB1dChzaGVldE5hbWVzLCBvdXRwdXQsIG91dHB1dERhdGEsIHNoZWV0TmFtZXNYbHN4LCBjb2xTaXplcykge1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJvdXRwdXRDb21wbGV0ZVwiLCBcInRydWVcIik7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcIm91dHB1dFNwcmVhZHNoZWV0QXJyYXlcIiwgb3V0cHV0KTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwib3V0cHV0U3ByZWFkc2hlZXRTaGVldE5hbWVzQXJyYXlcIiwgc2hlZXROYW1lcyk7XG5cbiAgICAgICAgLy8gZm9yIG91dHB1dCB0ZXN0aW5nIC0gZG8gbm90IGRlbGV0ZSFcbiAgICAgICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkob3V0cHV0KSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHNoZWV0TmFtZXMpKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShvdXRwdXREYXRhKSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHNoZWV0TmFtZXNYbHN4KSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGNvbFNpemVzKSk7XG5cbiAgICAgICAgUUFWLnNldFN0YXRlKFwiZGF0YVhsc3hcIiwgb3V0cHV0RGF0YSk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInNoZWV0TmFtZXNYbHN4XCIsIHNoZWV0TmFtZXNYbHN4KTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwiY29sU2l6ZXNcIiwgY29sU2l6ZXMpO1xuICAgIH1cblxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vKioqKioqKiogIEhFTFBFUiBGVU5DVElPTlMgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBkaXN0aW5ndWlzaGluZyBzdGF0ZW1lbnRzIGFycmF5XG4gICAgZnVuY3Rpb24gZm9ybWF0Q29uc2Vuc3VzQXJyYXlGb3JEb3dubG9hZChjb25zZW5zdXMwNSwgY29uc2Vuc3VzMDEsIGFuYWx5c2lzT3V0cHV0LCBzaWdGYWN0b3JOdW1iZXJzQXJyYXkpIHtcblxuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDEgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiQ29uc2Vuc3VzIFN0YXRlbWVudHNcIl07XG4gICAgICAgIHZhciBjaGFydFRleHQyID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlRob3NlIFRoYXQgRG8gTm90IERpc3Rpbmd1aXNoIEJldHdlZW4gQU5ZIFBhaXIgb2YgRmFjdG9yc1wiXTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDMgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiQWxsIExpc3RlZCBTdGF0ZW1lbnRzIGFyZSBOb24tU2lnbmlmaWNhbnQgYXQgUCA+IDAuMDEsIGFuZCBUaG9zZSBGbGFnZ2VkIHdpdGggYW4gKiBhcmUgYWxzbyBOb24tU2lnbmlmaWNhbnQgYXQgUCA+IDAuMDUpXCJdO1xuICAgICAgICB2YXIgY2hhcnRUZXh0NCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uU2lnbmlmaWNhbmNlO1xuICAgICAgICB2YXIgY2hhcnRUZXh0NSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uU3RhdGVtZW50O1xuICAgICAgICB2YXIgY2hhcnRUZXh0NiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uTnVtO1xuICAgICAgICB2YXIgY2hhcnRUZXh0NyA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJTdGF0ZW1lbnQgTnVtYmVyXCJdO1xuICAgICAgICB2YXIgY2hhcnRUZXh0OCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJaLXNjb3JlXCJdO1xuICAgICAgICB2YXIgc3BhY2VyID0gW1wiXCIsIFwiXCJdO1xuICAgICAgICB2YXIgb3V0cHV0TGVuZ3RoID0gYW5hbHlzaXNPdXRwdXQubGVuZ3RoO1xuICAgICAgICB2YXIgY29uc2Vuc3VzMDVMZW5ndGggPSBjb25zZW5zdXMwNS5sZW5ndGg7XG4gICAgICAgIHZhciBjb25zZW5zdXMwMUxlbmd0aCA9IGNvbnNlbnN1czAxLmxlbmd0aDtcblxuICAgICAgICB2YXIgcHJpbnRBcnJheSA9IFtdO1xuICAgICAgICB2YXIgcHJpbnRBcnJheTIgPSBbXTtcbiAgICAgICAgdmFyIGNvbnNlbnN1c1NoZWV0QXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGNvbnNlbnN1c1NoZWV0QXJyYXkyID0gW107XG5cbiAgICAgICAgLy8gcHVzaCBoZWFkZXJzXG4gICAgICAgIHZhciBlbXB0eUxpbmVPYmogPSB7fTtcbiAgICAgICAgZW1wdHlMaW5lT2JqW1wiTm8uXCJdID0gXCIgXCI7XG4gICAgICAgIGVtcHR5TGluZU9ialtcIlNJRyBcIl0gPSBcIiBcIjtcbiAgICAgICAgZW1wdHlMaW5lT2JqW1wiU3RhdGVtZW50IFwiXSA9IFwiIFwiO1xuICAgICAgICBlbXB0eUxpbmVPYmpbXCJOdW0gXCJdID0gXCIgXCI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZW1wdHlMaW5lT2JqW1wiUS1TVi1cIiArIHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtpXV0gPSBcIiBcIjtcbiAgICAgICAgICAgIGVtcHR5TGluZU9ialtcIlotU0NSLVwiICsgc2lnRmFjdG9yTnVtYmVyc0FycmF5W2ldXSA9IFwiIFwiO1xuICAgICAgICAgICAgZW1wdHlMaW5lT2JqW1wiU0lHXCIgKyBzaWdGYWN0b3JOdW1iZXJzQXJyYXlbaV1dID0gXCIgXCI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zZW5zdXNTaGVldEFycmF5LnB1c2goc3BhY2VyLCBbY2hhcnRUZXh0MSArIFwiIC0tIFwiICsgY2hhcnRUZXh0Ml0sIHNwYWNlciwgW2NoYXJ0VGV4dDNdLCBzcGFjZXIsIHNwYWNlcik7XG5cbiAgICAgICAgdmFyIGxpbmUzQXJyYXkgPSBbXTtcbiAgICAgICAgcHJpbnRBcnJheS5wdXNoKGVtcHR5TGluZU9iaik7XG4gICAgICAgIHZhciBwcmludEhlYWRlck9iajEgPSB7fTtcbiAgICAgICAgcHJpbnRIZWFkZXJPYmoxW1wiTm8uXCJdID0gY2hhcnRUZXh0MSArIFwiIC0tIFwiICsgY2hhcnRUZXh0MjtcbiAgICAgICAgcHJpbnRBcnJheS5wdXNoKHByaW50SGVhZGVyT2JqMSk7XG4gICAgICAgIHByaW50QXJyYXkucHVzaChlbXB0eUxpbmVPYmopO1xuICAgICAgICB2YXIgcHJpbnRIZWFkZXJPYmoyID0ge307XG4gICAgICAgIHByaW50SGVhZGVyT2JqMltcIk5vLlwiXSA9IGNoYXJ0VGV4dDM7XG4gICAgICAgIHByaW50QXJyYXkucHVzaChwcmludEhlYWRlck9iajIpO1xuICAgICAgICBwcmludEFycmF5LnB1c2goZW1wdHlMaW5lT2JqKTtcbiAgICAgICAgcHJpbnRBcnJheS5wdXNoKGVtcHR5TGluZU9iaik7XG4gICAgICAgIHZhciBwcmludEhlYWRlck9iajQgPSB7fTtcbiAgICAgICAgcHJpbnRIZWFkZXJPYmo0W1wiTm8uXCJdID0gY2hhcnRUZXh0NztcbiAgICAgICAgcHJpbnRIZWFkZXJPYmo0W1wiU0lHIFwiXSA9IGNoYXJ0VGV4dDQ7XG4gICAgICAgIHByaW50SGVhZGVyT2JqNFtcIlN0YXRlbWVudCBcIl0gPSBjaGFydFRleHQ1O1xuICAgICAgICBwcmludEhlYWRlck9iajRbXCJOdW0gXCJdID0gY2hhcnRUZXh0NztcblxuICAgICAgICBsaW5lM0FycmF5LnB1c2goY2hhcnRUZXh0NywgY2hhcnRUZXh0NCwgY2hhcnRUZXh0NSwgY2hhcnRUZXh0Nyk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRwdXRMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgcHJpbnRIZWFkZXJPYmo0W1wiUS1TVi1cIiArIHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtqXV0gPSBzaWdGYWN0b3JOdW1iZXJzQXJyYXlbal0gKyBcIiBRLVNWXCI7XG4gICAgICAgICAgICBwcmludEhlYWRlck9iajRbXCJaLVNDUi1cIiArIHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtqXV0gPSBzaWdGYWN0b3JOdW1iZXJzQXJyYXlbal0gKyBcIiBcIiArIGNoYXJ0VGV4dDg7XG4gICAgICAgICAgICBsaW5lM0FycmF5LnB1c2goKHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtqXSArIFwiIFEtU1ZcIiksIChzaWdGYWN0b3JOdW1iZXJzQXJyYXlbal0gKyBcIiBcIiArIGNoYXJ0VGV4dDgpKTtcbiAgICAgICAgfVxuICAgICAgICBwcmludEFycmF5LnB1c2gocHJpbnRIZWFkZXJPYmo0KTtcbiAgICAgICAgY29uc2Vuc3VzU2hlZXRBcnJheS5wdXNoKGxpbmUzQXJyYXkpO1xuXG4gICAgICAgIHZhciB0ZW1wT2JqLFxuICAgICAgICAgICAgdGVtcE9iajIsXG4gICAgICAgICAgICBrU2hpZnQsXG4gICAgICAgICAgICBwU2hpZnQ7XG5cbiAgICAgICAgLy8gcHVzaCAwNSBzdGF0ZW1lbnRzXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY29uc2Vuc3VzMDVMZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdGVtcE9iaiA9IHt9O1xuICAgICAgICAgICAgdmFyIHRlbXBBcnJheSA9IFtdO1xuICAgICAgICAgICAga1NoaWZ0ID0gY29uc2Vuc3VzMDVba107XG5cbiAgICAgICAgICAgIC8vIGN5Y2xlIHRocm91Z2ggc3RhdGVtZW50IG51bWJlcnMgYW5kIGdldCBzdGF0ZW1lbnQsIGZhY3RvcnMgcSBzY29yZSBhbmQgc29ydCB2YWx1ZSBmcm9tIHJlc3VsdHMgb2JqZWN0IGFuZCBzZXQgc2lnIGxldmVsIHRvIFwiXCJcbiAgICAgICAgICAgIHRlbXBPYmpbXCJOby5cIl0gPSBrU2hpZnQ7XG4gICAgICAgICAgICAvLyBbXCJOby5cIl0gPSBrU2hpZnQ7XG4gICAgICAgICAgICB0ZW1wT2JqW1wiU0lHIFwiXSA9IFwiKlwiO1xuICAgICAgICAgICAgdGVtcE9ialtcIlN0YXRlbWVudCBcIl0gPSBhbmFseXNpc091dHB1dFswXVsoa1NoaWZ0IC0gMSldLnNvcnRTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0ZW1wT2JqW1wiTnVtIFwiXSA9IGtTaGlmdDtcblxuICAgICAgICAgICAgdGVtcEFycmF5LnB1c2goa1NoaWZ0LCBcIipcIiwgKGFuYWx5c2lzT3V0cHV0WzBdWyhrU2hpZnQgLSAxKV0uc29ydFN0YXRlbWVudCksIGtTaGlmdCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgb3V0cHV0TGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqW1wiUS1TVi1cIiArIHNpZ0ZhY3Rvck51bWJlcnNBcnJheVttXV0gPSBhbmFseXNpc091dHB1dFttXVsoa1NoaWZ0IC0gMSldLnNvcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqW1wiWi1TQ1ItXCIgKyBzaWdGYWN0b3JOdW1iZXJzQXJyYXlbbV1dID0gYW5hbHlzaXNPdXRwdXRbbV1bKGtTaGlmdCAtIDEpXS56U2NvcmU7XG4gICAgICAgICAgICAgICAgdGVtcEFycmF5LnB1c2goKGFuYWx5c2lzT3V0cHV0W21dWyhrU2hpZnQgLSAxKV0uc29ydFZhbHVlKSwgKGFuYWx5c2lzT3V0cHV0W21dWyhrU2hpZnQgLSAxKV0uelNjb3JlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmludEFycmF5Mi5wdXNoKHRlbXBPYmopO1xuICAgICAgICAgICAgY29uc2Vuc3VzU2hlZXRBcnJheTIucHVzaCh0ZW1wQXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3ljbGUgdGhyb3VnaCBzdGF0ZW1lbnQgbnVtYmVycyBhbmQgZ2V0IHN0YXRlbWVudCwgZmFjdG9ycyBxIHNjb3JlIGFuZCBzb3J0IHZhbHVlIGZyb20gcmVzdWx0cyBvYmplY3QgYW5kIHNldCBzaWcgbGV2ZWwgdG8gXCIqXCJcbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBjb25zZW5zdXMwMUxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5MiA9IFtdO1xuICAgICAgICAgICAgdGVtcE9iajIgPSB7fTtcbiAgICAgICAgICAgIHBTaGlmdCA9IGNvbnNlbnN1czAxW3BdO1xuXG4gICAgICAgICAgICB0ZW1wT2JqMltcIk5vLlwiXSA9IHBTaGlmdDtcbiAgICAgICAgICAgIHRlbXBPYmoyW1wiU0lHIFwiXSA9IFwiXCI7XG4gICAgICAgICAgICB0ZW1wT2JqMltcIlN0YXRlbWVudCBcIl0gPSBhbmFseXNpc091dHB1dFswXVsocFNoaWZ0IC0gMSldLnNvcnRTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0ZW1wT2JqMltcIk51bSBcIl0gPSBwU2hpZnQ7XG5cbiAgICAgICAgICAgIHRlbXBBcnJheTIucHVzaChwU2hpZnQsIFwiXCIsIChhbmFseXNpc091dHB1dFswXVsocFNoaWZ0IC0gMSldLnNvcnRTdGF0ZW1lbnQpLCBwU2hpZnQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IG91dHB1dExlbmd0aDsgcSsrKSB7XG4gICAgICAgICAgICAgICAgdGVtcE9iajJbXCJRLVNWLVwiICsgc2lnRmFjdG9yTnVtYmVyc0FycmF5W3FdXSA9IGFuYWx5c2lzT3V0cHV0W3FdWyhwU2hpZnQgLSAxKV0uc29ydFZhbHVlO1xuICAgICAgICAgICAgICAgIHRlbXBPYmoyW1wiWi1TQ1ItXCIgKyBzaWdGYWN0b3JOdW1iZXJzQXJyYXlbcV1dID0gYW5hbHlzaXNPdXRwdXRbcV1bKHBTaGlmdCAtIDEpXS56U2NvcmU7XG4gICAgICAgICAgICAgICAgdGVtcEFycmF5Mi5wdXNoKChhbmFseXNpc091dHB1dFtxXVsocFNoaWZ0IC0gMSldLnNvcnRWYWx1ZSksIChhbmFseXNpc091dHB1dFtxXVsocFNoaWZ0IC0gMSldLnpTY29yZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJpbnRBcnJheTIucHVzaCh0ZW1wT2JqMik7XG4gICAgICAgICAgICBjb25zZW5zdXNTaGVldEFycmF5Mi5wdXNoKHRlbXBBcnJheTIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByaW50QXJyYXkzID0gcHJpbnRBcnJheTIuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYVtcIk5vLlwiXSAtIGJbXCJOby5cIl07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNlbnN1c1NoZWV0QXJyYXkyLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgaWYgKGFbMF0gPT09IGJbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhWzBdIDwgYlswXSkgP1xuICAgICAgICAgICAgICAgICAgICAtMSA6XG4gICAgICAgICAgICAgICAgICAgIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmaW5hbEFycmF5ID0gY29uc2Vuc3VzU2hlZXRBcnJheS5jb25jYXQoY29uc2Vuc3VzU2hlZXRBcnJheTIpO1xuXG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcHJpbnRBcnJheTMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgIHByaW50QXJyYXkucHVzaChwcmludEFycmF5M1tyXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtwcmludEFycmF5LCBmaW5hbEFycmF5XTtcbiAgICB9XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIGRpc3Rpbmd1aXNoaW5nIGFycmF5c1xuICAgIGZ1bmN0aW9uIHJlZHVjZURpc3RpbmdBcnJheShhcnJheSkge1xuICAgICAgICB2YXIgcmVkdWNlZEFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgYXJyYXkubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnQzID0gciArIDE7XG4gICAgICAgICAgICB2YXIgY29tbW9uU2V0MiA9IF8uaW50ZXJzZWN0aW9uKGFycmF5W3JdLCBhcnJheVtpbmNyZW1lbnQzXSk7XG4gICAgICAgICAgICByZWR1Y2VkQXJyYXkucHVzaChjb21tb25TZXQyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVkdWNlZEFycmF5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJlZHVjZWRBcnJheS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVkdWNlZEFycmF5O1xuICAgIH1cblxuICAgIC8qXG4gICAgICogaGVscGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0RGlzdGluZ0FycmF5Rm9yRG93bmxvYWQoZGlzdGluZ1N0YXRlbWVudHNUcmFuc2ZlckFycmF5MDEsIGRpc3RpbmdTdGF0ZW1lbnRzVHJhbnNmZXJBcnJheTA1LCBmYWN0b3JOdW1iZXIsIGFuYWx5c2lzT3V0cHV0LCBzaWdGYWN0b3JOdW1iZXJzQXJyYXkpIHtcblxuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIGNoYXJ0VGV4dDEgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiRGlzdGluZ3Vpc2hpbmcgU3RhdGVtZW50cyBmb3JcIl07XG4gICAgICAgIHZhciBjaGFydFRleHQyID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIihQIDwgLjA1IDogQXN0ZXJpc2sgKCopIEluZGljYXRlcyBTaWduaWZpY2FuY2UgYXQgUCA8IC4wMSlcIl07XG4gICAgICAgIHZhciBjaGFydFRleHQzID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIkJvdGggdGhlIEZhY3RvciBRLVNvcnQgVmFsdWUgYW5kIHRoZSBaLVNjb3JlIChaLVNDUikgYXJlIFNob3duXCJdO1xuICAgICAgICB2YXIgY2hhcnRUZXh0NCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uU2lnbmlmaWNhbmNlO1xuICAgICAgICB2YXIgY2hhcnRUZXh0NSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uU3RhdGVtZW50O1xuICAgICAgICB2YXIgY2hhcnRUZXh0NiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uTnVtO1xuICAgICAgICB2YXIgY2hhcnRUZXh0NyA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJTdGF0ZW1lbnQgTnVtYmVyXCJdO1xuICAgICAgICB2YXIgY2hhcnRUZXh0OCA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJaLXNjb3JlXCJdO1xuXG4gICAgICAgIHZhciBvdXRwdXRMZW5ndGggPSBhbmFseXNpc091dHB1dC5sZW5ndGg7XG4gICAgICAgIHZhciBkaXN0aW5nMDVMZW5ndGggPSBkaXN0aW5nU3RhdGVtZW50c1RyYW5zZmVyQXJyYXkwNS5sZW5ndGg7XG4gICAgICAgIHZhciBkaXN0aW5nMDFMZW5ndGggPSBkaXN0aW5nU3RhdGVtZW50c1RyYW5zZmVyQXJyYXkwMS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHByaW50QXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIHByaW50QXJyYXkyID0gW107XG4gICAgICAgIHZhciBzcGFjZXIgPSBbXCJcIiwgXCJcIl07XG5cbiAgICAgICAgdmFyIGRpc3Rpbmd1aXNoaW5nU2hlZXRBcnJheSA9IFtdO1xuXG4gICAgICAgIC8vIGxpbmUgMVxuICAgICAgICB2YXIgbGluZTFBcnJheSA9IFtjaGFydFRleHQxICsgZmFjdG9yTnVtYmVyXTtcbiAgICAgICAgZGlzdGluZ3Vpc2hpbmdTaGVldEFycmF5LnB1c2goc3BhY2VyLCBsaW5lMUFycmF5KTtcblxuICAgICAgICAvLyBsaW5lIDJcbiAgICAgICAgZGlzdGluZ3Vpc2hpbmdTaGVldEFycmF5LnB1c2goc3BhY2VyLCBbY2hhcnRUZXh0Ml0pO1xuXG4gICAgICAgIC8vIGxpbmUgM1xuICAgICAgICBkaXN0aW5ndWlzaGluZ1NoZWV0QXJyYXkucHVzaChzcGFjZXIsIFtjaGFydFRleHQzXSwgc3BhY2VyLCBzcGFjZXIpO1xuXG4gICAgICAgIC8vIGxpbmUgNCAtIGhlYWRlcnNcbiAgICAgICAgdmFyIGxpbmU0QXJyYXkgPSBbY2hhcnRUZXh0NywgY2hhcnRUZXh0NSwgY2hhcnRUZXh0N107XG5cbiAgICAgICAgLy8gcHVzaCBoZWFkZXJzXG4gICAgICAgIHZhciBlbXB0eUxpbmVPYmogPSB7fTtcbiAgICAgICAgZW1wdHlMaW5lT2JqW1wiTm8uXCJdID0gXCIgXCI7XG4gICAgICAgIGVtcHR5TGluZU9ialtcIlN0YXRlbWVudCBcIl0gPSBcIiBcIjtcbiAgICAgICAgZW1wdHlMaW5lT2JqW1wiTnVtIFwiXSA9IFwiIFwiO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGVtcHR5TGluZU9ialtcIlEtU1YtXCIgKyBzaWdGYWN0b3JOdW1iZXJzQXJyYXlbaV1dID0gXCIgXCI7XG4gICAgICAgICAgICBlbXB0eUxpbmVPYmpbXCJaLVNDUi1cIiArIHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtpXV0gPSBcIiBcIjtcbiAgICAgICAgICAgIGVtcHR5TGluZU9ialtcIlNJR1wiICsgc2lnRmFjdG9yTnVtYmVyc0FycmF5W2ldXSA9IFwiIFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJpbnRBcnJheS5wdXNoKGVtcHR5TGluZU9iaik7XG4gICAgICAgIHZhciBwcmludEhlYWRlck9iajEgPSB7fTtcbiAgICAgICAgcHJpbnRIZWFkZXJPYmoxW1wiTm8uXCJdID0gY2hhcnRUZXh0MSArIGZhY3Rvck51bWJlcjtcbiAgICAgICAgcHJpbnRBcnJheS5wdXNoKHByaW50SGVhZGVyT2JqMSk7XG4gICAgICAgIHByaW50QXJyYXkucHVzaChlbXB0eUxpbmVPYmopO1xuICAgICAgICB2YXIgcHJpbnRIZWFkZXJPYmoyID0ge307XG4gICAgICAgIHByaW50SGVhZGVyT2JqMltcIk5vLlwiXSA9IGNoYXJ0VGV4dDI7XG4gICAgICAgIHByaW50QXJyYXkucHVzaChwcmludEhlYWRlck9iajIpO1xuICAgICAgICBwcmludEFycmF5LnB1c2goZW1wdHlMaW5lT2JqKTtcbiAgICAgICAgdmFyIHByaW50SGVhZGVyT2JqMyA9IHt9O1xuICAgICAgICBwcmludEhlYWRlck9iajNbXCJOby5cIl0gPSBjaGFydFRleHQzO1xuICAgICAgICBwcmludEFycmF5LnB1c2gocHJpbnRIZWFkZXJPYmozKTtcbiAgICAgICAgcHJpbnRBcnJheS5wdXNoKGVtcHR5TGluZU9iaik7XG4gICAgICAgIHByaW50QXJyYXkucHVzaChlbXB0eUxpbmVPYmopO1xuICAgICAgICB2YXIgcHJpbnRIZWFkZXJPYmo0ID0ge307XG4gICAgICAgIHByaW50SGVhZGVyT2JqNFtcIk5vLlwiXSA9IGNoYXJ0VGV4dDc7XG4gICAgICAgIHByaW50SGVhZGVyT2JqNFtcIlN0YXRlbWVudCBcIl0gPSBjaGFydFRleHQ1O1xuICAgICAgICBwcmludEhlYWRlck9iajRbXCJOdW0gXCJdID0gY2hhcnRUZXh0NztcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG91dHB1dExlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBwcmludEhlYWRlck9iajRbXCJRLVNWLVwiICsgc2lnRmFjdG9yTnVtYmVyc0FycmF5W2pdXSA9IHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtqXSArIFwiIFEtU1ZcIjtcbiAgICAgICAgICAgIHByaW50SGVhZGVyT2JqNFtcIlotU0NSLVwiICsgc2lnRmFjdG9yTnVtYmVyc0FycmF5W2pdXSA9IHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtqXSArIFwiIFwiICsgY2hhcnRUZXh0ODtcbiAgICAgICAgICAgIHByaW50SGVhZGVyT2JqNFtcIlNJR1wiICsgc2lnRmFjdG9yTnVtYmVyc0FycmF5W2pdXSA9IGNoYXJ0VGV4dDQ7XG5cbiAgICAgICAgICAgIGxpbmU0QXJyYXkucHVzaCgoc2lnRmFjdG9yTnVtYmVyc0FycmF5W2pdICsgXCIgUS1TVlwiKSwgKHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtqXSArIFwiIFwiICsgY2hhcnRUZXh0OCksIGNoYXJ0VGV4dDQpO1xuXG4gICAgICAgIH1cbiAgICAgICAgcHJpbnRBcnJheS5wdXNoKHByaW50SGVhZGVyT2JqNCk7XG4gICAgICAgIGRpc3Rpbmd1aXNoaW5nU2hlZXRBcnJheS5wdXNoKGxpbmU0QXJyYXkpO1xuXG4gICAgICAgIHZhciB0ZW1wT2JqLFxuICAgICAgICAgICAgdGVtcE9iajIsXG4gICAgICAgICAgICBrU2hpZnQsXG4gICAgICAgICAgICBwU2hpZnQ7XG5cbiAgICAgICAgLy8gbGluZSA1XG4gICAgICAgIHZhciBkaXN0aW5ndWlzaGluZ1NoZWV0QXJyYXkyID0gW107XG5cbiAgICAgICAgLy8gcHVzaCAwNSBzdGF0ZW1lbnRzXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGlzdGluZzA1TGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5lNUFycmF5ID0gW107XG4gICAgICAgICAgICB0ZW1wT2JqID0ge307XG4gICAgICAgICAgICBrU2hpZnQgPSBkaXN0aW5nU3RhdGVtZW50c1RyYW5zZmVyQXJyYXkwNVtrXTtcblxuICAgICAgICAgICAgLy8gY3ljbGUgdGhyb3VnaCBzdGF0ZW1lbnQgbnVtYmVycyBhbmQgZ2V0IHN0YXRlbWVudCwgZmFjdG9ycyBxIHNjb3JlIGFuZCBzb3J0IHZhbHVlIGZyb20gcmVzdWx0cyBvYmplY3QgYW5kIHNldCBzaWcgbGV2ZWwgdG8gXCJcIlxuICAgICAgICAgICAgdGVtcE9ialtcIk5vLlwiXSA9IGtTaGlmdDtcbiAgICAgICAgICAgIGxpbmU1QXJyYXkucHVzaChrU2hpZnQpO1xuXG4gICAgICAgICAgICB0ZW1wT2JqW1wiU3RhdGVtZW50IFwiXSA9IGFuYWx5c2lzT3V0cHV0WzBdWyhrU2hpZnQgLSAxKV0uc29ydFN0YXRlbWVudDtcbiAgICAgICAgICAgIGxpbmU1QXJyYXkucHVzaChhbmFseXNpc091dHB1dFswXVsoa1NoaWZ0IC0gMSldLnNvcnRTdGF0ZW1lbnQsIGtTaGlmdCk7XG5cbiAgICAgICAgICAgIHRlbXBPYmpbXCJOdW0gXCJdID0ga1NoaWZ0O1xuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBvdXRwdXRMZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgICAgIHRlbXBPYmpbXCJRLVNWLVwiICsgc2lnRmFjdG9yTnVtYmVyc0FycmF5W21dXSA9IGFuYWx5c2lzT3V0cHV0W21dWyhrU2hpZnQgLSAxKV0uc29ydFZhbHVlO1xuICAgICAgICAgICAgICAgIHRlbXBPYmpbXCJaLVNDUi1cIiArIHNpZ0ZhY3Rvck51bWJlcnNBcnJheVttXV0gPSBhbmFseXNpc091dHB1dFttXVsoa1NoaWZ0IC0gMSldLnpTY29yZTtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqW1wiU0lHXCIgKyBzaWdGYWN0b3JOdW1iZXJzQXJyYXlbbV1dID0gXCJcIjtcbiAgICAgICAgICAgICAgICBsaW5lNUFycmF5LnB1c2goKGFuYWx5c2lzT3V0cHV0W21dWyhrU2hpZnQgLSAxKV0uc29ydFZhbHVlKSwgKGFuYWx5c2lzT3V0cHV0W21dWyhrU2hpZnQgLSAxKV0uelNjb3JlKSwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmludEFycmF5Mi5wdXNoKHRlbXBPYmopO1xuICAgICAgICAgICAgZGlzdGluZ3Vpc2hpbmdTaGVldEFycmF5Mi5wdXNoKGxpbmU1QXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3ljbGUgdGhyb3VnaCBzdGF0ZW1lbnQgbnVtYmVycyBhbmQgZ2V0IHN0YXRlbWVudCwgZmFjdG9ycyBxIHNjb3JlIGFuZCBzb3J0IHZhbHVlIGZyb20gcmVzdWx0cyBvYmplY3QgYW5kIHNldCBzaWcgbGV2ZWwgdG8gXCIqXCJcbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBkaXN0aW5nMDFMZW5ndGg7IHArKykge1xuICAgICAgICAgICAgdmFyIGxpbmU2QXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHRlbXBPYmoyID0ge307XG4gICAgICAgICAgICBwU2hpZnQgPSBkaXN0aW5nU3RhdGVtZW50c1RyYW5zZmVyQXJyYXkwMVtwXTtcblxuICAgICAgICAgICAgdGVtcE9iajJbXCJOby5cIl0gPSBwU2hpZnQ7XG4gICAgICAgICAgICB0ZW1wT2JqMltcIlN0YXRlbWVudCBcIl0gPSBhbmFseXNpc091dHB1dFswXVsocFNoaWZ0IC0gMSldLnNvcnRTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0ZW1wT2JqMltcIk51bSBcIl0gPSBwU2hpZnQ7XG5cbiAgICAgICAgICAgIGxpbmU2QXJyYXkucHVzaChwU2hpZnQsIChhbmFseXNpc091dHB1dFswXVsocFNoaWZ0IC0gMSldLnNvcnRTdGF0ZW1lbnQpLCBwU2hpZnQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IG91dHB1dExlbmd0aDsgcSsrKSB7XG4gICAgICAgICAgICAgICAgdGVtcE9iajJbXCJRLVNWLVwiICsgc2lnRmFjdG9yTnVtYmVyc0FycmF5W3FdXSA9IGFuYWx5c2lzT3V0cHV0W3FdWyhwU2hpZnQgLSAxKV0uc29ydFZhbHVlO1xuICAgICAgICAgICAgICAgIHRlbXBPYmoyW1wiWi1TQ1ItXCIgKyBzaWdGYWN0b3JOdW1iZXJzQXJyYXlbcV1dID0gYW5hbHlzaXNPdXRwdXRbcV1bKHBTaGlmdCAtIDEpXS56U2NvcmU7XG5cbiAgICAgICAgICAgICAgICBsaW5lNkFycmF5LnB1c2goKGFuYWx5c2lzT3V0cHV0W3FdWyhwU2hpZnQgLSAxKV0uc29ydFZhbHVlKSwgKGFuYWx5c2lzT3V0cHV0W3FdWyhwU2hpZnQgLSAxKV0uelNjb3JlKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocSA9PT0gZm9ybWF0RGlzdGluZ0FycmF5Rm9yRG93bmxvYWQuY2FsbGVkVGltZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcE9iajJbXCJTSUdcIiArIHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtxXV0gPSBcIipcIjtcbiAgICAgICAgICAgICAgICAgICAgbGluZTZBcnJheS5wdXNoKFwiKlwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wT2JqMltcIlNJR1wiICsgc2lnRmFjdG9yTnVtYmVyc0FycmF5W3FdXSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU2QXJyYXkucHVzaChcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmludEFycmF5Mi5wdXNoKHRlbXBPYmoyKTtcbiAgICAgICAgICAgIGRpc3Rpbmd1aXNoaW5nU2hlZXRBcnJheTIucHVzaChsaW5lNkFycmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb29rdXBWYWx1ZSA9IHNpZ0ZhY3Rvck51bWJlcnNBcnJheVtmb3JtYXREaXN0aW5nQXJyYXlGb3JEb3dubG9hZC5jYWxsZWRUaW1lc107XG5cbiAgICAgICAgdmFyIHNvcnRGYWN0b3JWYWx1ZSA9IFwiWi1TQ1ItXCIgKyBsb29rdXBWYWx1ZTtcblxuICAgICAgICAvLyBzb3J0IGRlc2NcbiAgICAgICAgdmFyIHByaW50QXJyYXkzID0gcHJpbnRBcnJheTIuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYltzb3J0RmFjdG9yVmFsdWVdIC0gYVtzb3J0RmFjdG9yVmFsdWVdO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHByaW50QXJyYXkzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICBwcmludEFycmF5LnB1c2gocHJpbnRBcnJheTNbcl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvb2t1cFZhbHVlMiA9IGZvcm1hdERpc3RpbmdBcnJheUZvckRvd25sb2FkLmNhbGxlZFRpbWVzO1xuXG4gICAgICAgIHZhciBtb2RpZmllZEluZGV4VmFsdWUgPSBbXG4gICAgICAgICAgICA0LFxuICAgICAgICAgICAgNyxcbiAgICAgICAgICAgIDEwLFxuICAgICAgICAgICAgMTMsXG4gICAgICAgICAgICAxNixcbiAgICAgICAgICAgIDE5LFxuICAgICAgICAgICAgMjIsXG4gICAgICAgICAgICAyNVxuICAgICAgICBdO1xuXG4gICAgICAgIHZhciBpbmRleGVyID0gbW9kaWZpZWRJbmRleFZhbHVlW2xvb2t1cFZhbHVlMl07XG5cbiAgICAgICAgZGlzdGluZ3Vpc2hpbmdTaGVldEFycmF5Mi5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhW2luZGV4ZXJdID09PSBiW2luZGV4ZXJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYltpbmRleGVyXSA8IGFbaW5kZXhlcl0pID9cbiAgICAgICAgICAgICAgICAgICAgLTEgOlxuICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZmluYWxTaGVldEFycmF5ID0gZGlzdGluZ3Vpc2hpbmdTaGVldEFycmF5LmNvbmNhdChkaXN0aW5ndWlzaGluZ1NoZWV0QXJyYXkyKTtcblxuICAgICAgICBmb3JtYXREaXN0aW5nQXJyYXlGb3JEb3dubG9hZC5jYWxsZWRUaW1lcysrO1xuXG4gICAgICAgIHJldHVybiBbcHJpbnRBcnJheSwgZmluYWxTaGVldEFycmF5XTtcbiAgICB9XG5cbiAgICAvLyB0b2RvIC0gZXZlblJvdW5kIHRoZSBzZWQgY29tcGFyaXNvbiB2YWx1ZXMgaW4gZGlzdGluZyBzdGF0ZW1lbnRzIGZ1bmN0aW9uXG4gICAgLy8gdG9kbyAtIGNoZWNrIHRvIGdldCByaWQgb2Ygb3V0cHV0Y29tcGxldGUgY2hlY2sgLSBubyBsb25nZXIgbmVlZGVkIGkgdGhpbmsgYnkgaGlkaW5nIGRvd25sb2FkIGJ1dHRvblxuXG4gICAgT1VUUFVULmRvd25sb2FkRXhjZWxPdXRwdXRGaWxlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGRhdGEgPSBRQVYuZ2V0U3RhdGUoXCJkYXRhWGxzeFwiKTtcbiAgICAgICAgdmFyIHdzX25hbWUgPSBRQVYuZ2V0U3RhdGUoXCJzaGVldE5hbWVzWGxzeFwiKTtcbiAgICAgICAgdmFyIHdzY29scyA9IFFBVi5nZXRTdGF0ZShcImNvbFNpemVzXCIpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNoZWV0X2Zyb21fYXJyYXlfb2ZfYXJyYXlzKGRhdGEsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciB3cyA9IHt9O1xuICAgICAgICAgICAgdmFyIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYzogMTAwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIHI6IDEwMDAwMDAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlOiB7XG4gICAgICAgICAgICAgICAgICAgIGM6IDAsXG4gICAgICAgICAgICAgICAgICAgIHI6IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgUiA9IDA7IFIgIT0gZGF0YS5sZW5ndGg7ICsrUikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIEMgPSAwOyBDICE9IGRhdGFbUl0ubGVuZ3RoOyArK0MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnMuciA+IFIpXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zLnIgPSBSO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2Uucy5jID4gQylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnMuYyA9IEM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lLnIgPCBSKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZS5yID0gUjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmUuYyA8IEMpXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5lLmMgPSBDO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHY6IGRhdGFbUl1bQ11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwudiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbF9yZWYgPSBYTFNYXG4gICAgICAgICAgICAgICAgICAgICAgICAudXRpbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbmNvZGVfY2VsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzogQyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiBSXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNlbGwudiA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnQgPSAnbic7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjZWxsLnYgPT09ICdib29sZWFuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwudCA9ICdiJztcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2VsbC52IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC50ID0gJ24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC56ID0gWExTWC5TU0YuX3RhYmxlWzE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwudiA9IGRhdGVudW0oY2VsbC52KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnQgPSAncyc7XG5cbiAgICAgICAgICAgICAgICAgICAgd3NbY2VsbF9yZWZdID0gY2VsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmFuZ2Uucy5jIDwgMTAwMDAwMDApXG4gICAgICAgICAgICAgICAgd3NbJyFyZWYnXSA9IFhMU1gudXRpbHMuZW5jb2RlX3JhbmdlKHJhbmdlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHdzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gV29ya2Jvb2soKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV29ya2Jvb2spKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV29ya2Jvb2soKTtcbiAgICAgICAgICAgIHRoaXMuU2hlZXROYW1lcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5TaGVldHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBjb2x1bW4gd2lkdGhzIGV4YW1wbGVcbiAgICAgICAgLy8gdmFyIHdzY29scyA9IFt7XG4gICAgICAgIC8vICAgICAgICAgd2NoOiA2XG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIHdjaDogN1xuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICB3Y2g6IDEwXG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIHdjaDogNTBcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gXTtcblxuICAgICAgICB2YXIgd2IgPSBuZXcgV29ya2Jvb2soKTtcblxuICAgICAgICAvKiBhZGQgd29ya3NoZWV0IHRvIHdvcmtib29rICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3NfbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHdzID0gc2hlZXRfZnJvbV9hcnJheV9vZl9hcnJheXMoZGF0YVtpXSk7XG4gICAgICAgICAgICB3c1snIWNvbHMnXSA9IHdzY29sc1tpXTtcbiAgICAgICAgICAgIHdiXG4gICAgICAgICAgICAgICAgLlNoZWV0TmFtZXNcbiAgICAgICAgICAgICAgICAucHVzaCh3c19uYW1lW2ldKTtcbiAgICAgICAgICAgIHdiLlNoZWV0c1t3c19uYW1lW2ldXSA9IHdzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdib3V0ID0gWExTWC53cml0ZSh3Yiwge1xuICAgICAgICAgICAgYm9va1R5cGU6ICd4bHN4JyxcbiAgICAgICAgICAgIGJvb2tTU1Q6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiAnYmluYXJ5J1xuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBzMmFiKHMpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIocy5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT0gcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB2aWV3W2ldID0gcy5jaGFyQ29kZUF0KGkpICYgMHhGRjtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGltZVN0YW1wID0gVVRJTC5jdXJyZW50RGF0ZTEoKSArIFwiX1wiICsgVVRJTC5jdXJyZW50VGltZTEoKTtcbiAgICAgICAgdmFyIHByb2plY3ROYW1lID0gUUFWLmdldFN0YXRlKFwicWF2UHJvamVjdE5hbWVcIik7XG4gICAgICAgIHZhciBuYW1lRmlsZSA9ICdLZW5RX291dHB1dF8nICsgcHJvamVjdE5hbWUgKyAnXycgKyB0aW1lU3RhbXAgKyAnLnhsc3gnO1xuXG4gICAgICAgIHNhdmVBcyhuZXcgQmxvYihbczJhYih3Ym91dCldLCB7XG4gICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgICAgIH0pLCBuYW1lRmlsZSk7XG4gICAgfTtcblxuXG4gICAgT1VUUFVULmRvd25sb2FkQ3N2T3V0cHV0RmlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IFFBVi5nZXRTdGF0ZShcImRhdGFYbHN4XCIpO1xuXG4gICAgICAgIHZhciBzcGFjZXIgPSBbXCJcIiwgXCJcIiwgXCJcIl07XG5cbiAgICAgICAgdmFyIG5ld0RhdGFBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IGRhdGFbaV0ubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF0YUFycmF5LnB1c2goZGF0YVtpXVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdEYXRhQXJyYXkucHVzaChzcGFjZXIsIHNwYWNlciwgc3BhY2VyLCBzcGFjZXIsIHNwYWNlciwgc3BhY2VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0RhdGFBcnJheS5zaGlmdCgpO1xuXG4gICAgICAgIHZhciB0aW1lU3RhbXAgPSBVVElMLmN1cnJlbnREYXRlMSgpICsgXCJfXCIgKyBVVElMLmN1cnJlbnRUaW1lMSgpO1xuICAgICAgICB2YXIgcHJvamVjdE5hbWUgPSBRQVYuZ2V0U3RhdGUoXCJxYXZQcm9qZWN0TmFtZVwiKTtcbiAgICAgICAgdmFyIG5hbWVGaWxlID0gJ0tlblFfb3V0cHV0XycgKyBwcm9qZWN0TmFtZSArICdfJyArIHRpbWVTdGFtcCArIFwiLmNzdlwiO1xuXG4gICAgICAgIFVUSUwuZXhwb3J0VG9Dc3YobmFtZUZpbGUsIG5ld0RhdGFBcnJheSk7XG4gICAgfTtcblxufSh3aW5kb3cuT1VUUFVUID0gd2luZG93Lk9VVFBVVCB8fCB7fSwgUUFWKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9PVVRQVVQuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSA5Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')}});