!function(I){function g(t){if(C[t])return C[t].exports;var A=C[t]={i:t,l:!1,exports:{}};return I[t].call(A.exports,A,A.exports,g),A.l=!0,A.exports}var C={};g.m=I,g.c=C,g.i=function(I){return I},g.d=function(I,C,t){g.o(I,C)||Object.defineProperty(I,C,{configurable:!1,enumerable:!0,get:t})},g.n=function(I){var C=I&&I.__esModule?function(){return I.default}:function(){return I};return g.d(C,"a",C),C},g.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},g.p="",g(g.s=4)}({4:function(module,exports){eval('//Ken-Q Analysis\n//Copyright (C) 2016 Shawn Banasick\n//\n//    This program is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, either version 3 of the License, or\n//    (at your option) any later version.\n\n\n// JSlint declarations\n/* global window, resources, saveAs, Blob, QAV, $, INPUT, d3, localStorage, VIEW, FileReader, XLSX, UTIL, _ */\n\n(function (EXCEL, QAV, undefined) {\n    \'use strict\';\n    //\n    // **************************************************************************  model\n    // ***** Exporting Sorts to PQMethod ***********************************************\n    // *********************************************************************************\n\n    // todo - dry out by refactoring inputNewData functions\n    EXCEL.exportExcelSortsPQM = function () {\n\n        var output = [];\n        $("#existingDatabaseRespondentList li").each(function () {\n            var temp21 = ($(this).text());\n            output.push(temp21);\n        });\n\n        // export file line #1 - calculate number of respondents\n        var temp1, temp1a, temp2, temp3, temp3a, temp3b;\n        temp1 = output.length;\n        temp1a = String(UTIL.threeDigitPadding(temp1));\n\n\n        // grab Project Name\n        temp2 = QAV.getState("qavProjectName");\n\n        // get max range numbers\n        var temp5 = QAV.getState("qavSortTriangleShape");\n        var temp5b = _.min(temp5);\n        var temp5c = _.max(temp5);\n        var temp5d = String(UTIL.threeDigitPadding(+temp5b));\n        var temp5e = String(UTIL.threeDigitPadding(+temp5c));\n\n\n        // get triange shape\n        var temp6 = QAV.getState("multiplierArray");\n        var temp6a = "";\n        var temp6b = "";\n        for (var i = 0; i < 20; i++) {\n            temp6a = String(UTIL.threeDigitPadding(temp6[i]));\n            temp6b += temp6a;\n        }\n\n        // calculating the number of statements\n        temp3 = QAV.getState("qavCurrentStatements");\n        if (temp3.length === 0) {\n            temp3a = temp5.length;\n        } else {\n            temp3a = temp3.length;\n        }\n        temp3b = String(UTIL.threeDigitPadding(temp3a));\n\n        // set PQMethod DAT file line 2\n        var line2 = temp5d + temp5e + temp6b;\n        $("#excelSortExportBox").append("  0" + temp1a + temp3b + " " + temp2);\n        $("#excelSortExportBox").append("\\n");\n        $("#excelSortExportBox").append(line2);\n        $("#excelSortExportBox").append("\\n");\n\n        for (var j = 0; j < output.length; j++) {\n            var temp8 = output[j].split(",");\n\n            var respondentName = temp8[0];\n            var temp8a = INPUT.sanitizeRespondentName(respondentName);\n\n            var temp8c = temp8.slice(1, temp8.length);\n\n            var temp8d = temp8c.toString();\n\n            var testForButtonText = temp8d.slice(-4);\n            if (testForButtonText === "sort") {\n                temp8d = temp8d.replace(/delete sort/g, "");\n            }\n\n            var temp8e = temp8d.replace(/,/g, " ");\n            var temp8f = temp8e.replace(/ -/g, "-");\n            var temp8g = temp8f.replace(/[\\[\\]\']+/g, \'\');\n\n            if (+temp8[1] < 0) {\n                temp8g = "  " + temp8g;\n            } else {\n                temp8g = "   " + temp8g;\n            }\n            var temp9 = temp8a + temp8g;\n            $("#excelSortExportBox").append(temp9);\n            $("#excelSortExportBox").append("\\n");\n        }\n\n        // todo - add check to match statements.length with pyramid sort entry sum\n\n        // pull all data from hidden export prep box\n        var exportData = $(\'#excelSortExportBox\').val();\n\n        var timeStamp = UTIL.currentDate1() + "-" + UTIL.currentTime1();\n\n        var blob = new Blob([exportData], {\n            type: "text/plain;charset=us-ascii"\n        });\n        saveAs(blob, "Ken-Q_PQMethod_Export_" + timeStamp + ".DAT");\n\n        // clear the hidden export box\n        $("#excelSortExportBox").html("");\n    };\n\n    EXCEL.exportStatementsToPqmethod = function () {\n        var temp = QAV.getState("qavCurrentStatements");\n        var $exportBox = $("#excelSortExportBox");\n        for (var i = 0; i < temp.length; i++) {\n            $exportBox.append(temp[i], "\\n");\n        }\n        var exportData = $exportBox.val();\n\n        var timeStamp = UTIL.currentDate1() + "-" + UTIL.currentTime1();\n\n        var blob = new Blob([exportData], {\n            type: "text/plain;charset=us-ascii"\n        });\n        saveAs(blob, "Ken-Q_PQMethod_Statements_" + timeStamp + ".STA");\n\n        // clear the hidden export box\n        $("#excelSortExportBox").html("");\n    };\n\n\n\n    //\n    // **************************************************************************\n    // ***** Import Type 1 or Type 2 Files **************************************\n    // **************************************************************************\n    EXCEL.filePicked = function (e) {\n        var filetype = QAV.getState("typeOfExcelFile");\n        var files = e.target.files[0];\n        var reader = new FileReader();\n        var tester, tester2, tester3, tester4;\n        var tempArray = [];\n        var allWorksheets = [];\n        var data, workbook, worksheet, sheet_name_list;\n        var hasSortsWorksheet = false;\n        var hasStatementsWorksheet = false;\n        var $errorPanel = $("#genericErrorModal .errorPanel");\n        reader.onload = function (e) {\n            data = e.target.result;\n\n            workbook = XLSX.read(data, {\n                type: \'binary\'\n            });\n\n            // iterate through every sheet and pull values\n            sheet_name_list = workbook.SheetNames;\n            sheet_name_list.forEach(function (y) { /* iterate through sheets */\n\n                worksheet = workbook.Sheets[y];\n                if (y === "sorts") {\n                    hasSortsWorksheet = true;\n                    tester = XLSX.utils.sheet_to_csv(worksheet);\n                    tester2 = tester.split(/\\n/);\n\n                    if (filetype === "user-input") {\n                        for (var i = 1; i < 200; i++) {\n                            tester3 = tester2[i].split(\',\');\n                            tempArray.push(tester3);\n                        }\n                    } else if (filetype === "unforced") {\n                        tester3 = tester2.filter(Boolean);\n                        tempArray.push(tester3);\n                    }\n\n                } else if (y === "statements") {\n                    hasStatementsWorksheet = true;\n                    tempArray = [];\n                    tester4 = XLSX.utils.sheet_to_json(worksheet);\n                    tempArray.push(tester4);\n                }\n                allWorksheets.push(tempArray);\n            }); // end iteration of for each\n            if (hasSortsWorksheet === false) {\n                $errorPanel.empty();\n                $errorPanel.append("<p>Can\'t find the \'sorts\' worksheet. Please check your file\'s worksheet names and try again.</p><br>");\n                VIEW.showGenericErrorModal();\n            }\n            if (hasStatementsWorksheet === false) {\n                $errorPanel.empty();\n                $errorPanel.append("<p>Can\'t find the \'statements\' worksheet. Please check your file\'s worksheet names and try again.</p><br>");\n                VIEW.showGenericErrorModal();\n            }\n            if (filetype === "user-input") {\n                formatUploadForDisplay(allWorksheets);\n            } else if (filetype === "unforced") {\n                formatUnforcedUploadForDisplay(allWorksheets);\n            }\n        };\n        reader.readAsBinaryString(files);\n    };\n\n\n    //\n    // ***************************************************************\n    // ***** Import Type 3 - KEN-Q OUTPUT File ***********************\n    // ***************************************************************\n    EXCEL.filePickedKenq = function (e) {\n        var language = QAV.getState("language");\n        var localText1 = resources[language].translation["Project Overview"];\n        var localText2 = resources[language].translation.Statements;\n        var errorPanel = $("#genericErrorModal .errorPanel");\n\n        var files = e.target.files[0];\n        var reader = new FileReader();\n        reader.onload = function (e) {\n            var data = e.target.result;\n\n            var workbook = XLSX.read(data, {\n                type: \'binary\'\n            });\n\n            // iterate through every sheet and pull values\n            var hasSortsWorksheet = false;\n            var hasStatementsWorksheet = false;\n            var hasSortsWorksheetFromKenQ = false;\n            var allWorksheets = [];\n            var sheet_name_list = workbook.SheetNames;\n            sheet_name_list.forEach(function (y) { /* iterate through sheets */\n\n                var worksheet = workbook.Sheets[y];\n\n                var tempArray;\n\n                if (y === localText1) {\n                    tempArray = [];\n                    var tester6 = XLSX.utils.sheet_to_json(worksheet);\n                    tempArray.push(tester6);\n\n                } else if (y === "Q-sorts") {\n                    hasSortsWorksheetFromKenQ = true;\n                    var tester = XLSX.utils.sheet_to_csv(worksheet);\n                    var tester2 = tester.split(/\\n/);\n                    tempArray = [];\n                    tester2.forEach(function (entry) {\n                        var tester3 = entry.split(\',\');\n                        tempArray.push(tester3);\n                    });\n                } else if (y === localText2) {\n                    hasStatementsWorksheet = true;\n                    tempArray = [];\n                    var tester4 = XLSX.utils.sheet_to_json(worksheet);\n                    tempArray.push(tester4);\n                }\n                allWorksheets.push(tempArray);\n            }); // end iteration for each\n            if (hasSortsWorksheetFromKenQ === false) {\n                errorPanel.empty();\n                errorPanel.append("<p>Can\'t find Q-sorts. Please check your file\'s formatting and try again.</p><br>");\n                VIEW.showGenericErrorModal();\n            }\n            if (hasStatementsWorksheet === false) {\n                errorPanel.empty();\n                errorPanel.append("<p>Can\'t find sort statements. Please check your file\'s formatting and try again.</p><br>");\n                VIEW.showGenericErrorModal();\n            }\n            formatKenqUploadForDisplay(allWorksheets);\n        };\n        reader.readAsBinaryString(files);\n    };\n\n\n    //\n    // ***************************************************************  model\n    // ***** Format Type 1 Hand-Coded File for Display **********************\n    // **********************************************************************\n\n    function formatUploadForDisplay(data) {\n        var language = QAV.getState("language");\n        var errorText1 = resources[language].translation["has missing statement numbers"];\n        var errorText2 = resources[language].translation["has an incorrect statement number"];\n        var errorText3 = resources[language].translation["The number of statements in the statments sheet of the Excel file does not match the number of statements in the sorts sheet"];\n        var isNumberOfStatementsCorrect, areThereErrors;\n\n        // QAV #1\n        var qavProjectName = data[0][0][1];\n        QAV.setState("qavProjectName", qavProjectName);\n\n        // // QAV #2  -  todo - fix loop function\n        var inputData1 = data[0];\n        var createMultiplierArrayAndTriangleShape = EXCEL.createMultiplierArrayAndTriangleShape(inputData1);\n        var multiplierArray = createMultiplierArrayAndTriangleShape[0];\n        var qavSortTriangleShape = createMultiplierArrayAndTriangleShape[1];\n        QAV.setState("qavSortTriangleShape", qavSortTriangleShape);\n        QAV.setState("multiplierArray", multiplierArray);\n\n\n        // QAV #3\n        var qavOriginalSortSize = qavSortTriangleShape.length; // number of statements\n        QAV.setState("qavOriginalSortSize", qavOriginalSortSize);\n        // todo - fix qavOriginalSortSize and qavTotalStatements are same - symmetry check functions\n        QAV.setState("qavTotalStatements", qavOriginalSortSize);\n        QAV.setState("originalSortSize", qavOriginalSortSize);\n        // creates array of objects with sort value and statement number\n        var sortData = EXCEL.prepInputData(inputData1, qavOriginalSortSize);\n\n\n        // QAV #4\n\n        var namesData = sortData.shift();\n        var qavRespondentNames = EXCEL.getRespondentNames(namesData);\n        // todo - fix double coverage of res names\n        QAV.setState("qavRespondentNames", qavRespondentNames);\n        QAV.setState("respondentNames", qavRespondentNames);\n\n\n        // QAV #5\n        var qavTotalNumberSorts = qavRespondentNames.length;\n        QAV.setState("qavTotalNumberSorts", qavTotalNumberSorts);\n        QAV.setState("totalNumberSorts", qavTotalNumberSorts);\n\n        // QAV #6   respondent sorts\n        var respondentDataSortsPrep = EXCEL.getRespondentSorts(sortData);\n        var respondentDataSorts3 = respondentDataSortsPrep[0];\n        var statementNumArray = respondentDataSortsPrep[1];\n        QAV.setState("qavRespondentSortsFromDbStored", respondentDataSorts3);\n        var qavRespondentSortsFromDbStored = _.cloneDeep(respondentDataSorts3);\n        var symmData = _.cloneDeep(respondentDataSorts3);\n\n        // QAV #7   project statements\n        var statementData1 = data[1];\n        var qavCurrentStatements = EXCEL.getStatements(statementData1);\n        QAV.setState("qavCurrentStatements", qavCurrentStatements);\n        var statementNumberTestValue = qavCurrentStatements.length;\n\n        // //\n        // // SYMMETRY TESTING\n        // //\n        var checkForNonSymmetry = EXCEL.testSymmetryOfSorts(qavSortTriangleShape, symmData, statementNumArray, statementNumberTestValue);\n        areThereErrors = checkForNonSymmetry[0];\n        isNumberOfStatementsCorrect = checkForNonSymmetry[1];\n\n\n        // Display respondents and sorts OR error messages\n\n        var respondentSorts = [];\n        if (areThereErrors.length === 0 && isNumberOfStatementsCorrect === "true") {\n            for (var qq = 0; qq < qavCurrentStatements.length; qq++) {\n                var sortStatement = qavCurrentStatements[qq];\n                $("#existingDatabaseStatementList").append("<li>" + sortStatement + "</li>");\n            }\n            for (var rr = 0; rr < qavRespondentSortsFromDbStored.length; rr++) {\n                var sortItem = qavRespondentSortsFromDbStored[rr];\n                var sortItem2 = sortItem.join();\n                var sortItem3 = sortItem2.replace(/,/g, " ").replace(/ -/g, "-");\n                if (sortItem3.charAt(0) !== "-") {\n                    sortItem3 = " " + sortItem3;\n                }\n                respondentSorts.push((sortItem3));\n                var respondent = qavRespondentNames[rr];\n                $("#existingDatabaseRespondentList").append("<li>" + respondent + "," + sortItem + "</li>");\n            }\n            // display the download button for PQMethod export - todo - change naming for class\n            $(".jsonDownloadPQ").show();\n        } else {\n            $("#genericErrorModal .errorPanel").empty();\n            for (var t = 0; t < areThereErrors.length; t++) {\n                $("#genericErrorModal .errorPanel").append("<p>" + qavRespondentNames[areThereErrors[t][0]] + " " + areThereErrors[t][1] + "</p><br>");\n            }\n\n            if (isNumberOfStatementsCorrect === "false") {\n                $("#genericErrorModal .errorPanel").append("<h6>" + errorText3 + "</h6>");\n            }\n\n            VIEW.showGenericErrorModal();\n        }\n        QAV.setState("qavRespondentSortsFromDbStored", respondentSorts);\n    }\n\n    EXCEL.testSymmetryOfSorts = function (qavSortTriangleShape, symmData, statementNumArray, statementNumberTestValue) {\n        var language = QAV.getState("language");\n        var errorText1 = resources[language].translation["has missing statement numbers"];\n        var errorText2 = resources[language].translation["has an incorrect Q-sort value"];\n        var testSortTriangleShapeArray = _.cloneDeep(qavSortTriangleShape);\n        var isNumberOfStatementsCorrect, areThereErrors = [];\n\n        // Use D3.js to generate range array to test against\n        var rangeTestArray = d3.range(1, (testSortTriangleShapeArray.length + 1));\n\n        // test for missing values / consistent length\n        var testMax = _.max(rangeTestArray);\n        var testMin = _.min(rangeTestArray);\n        var min, max, testSym;\n        for (var kk = 0; kk < symmData.length; kk++) {\n            max = _.max(statementNumArray[kk]);\n            min = _.min(statementNumArray[kk]);\n            if (max > testMax || min < testMin) {\n                areThereErrors.push([kk, errorText2]);\n            } else {\n                testSym = checkQsortValueMatch(statementNumArray[kk], rangeTestArray);\n                if (testSym > 0) {\n                    areThereErrors.push([kk, errorText1]);\n                }\n            }\n        }\n\n        // check to see if number of statements in statements tab matches number calculated statements\n        if (statementNumberTestValue !== testSortTriangleShapeArray.length) {\n            isNumberOfStatementsCorrect = "false";\n        } else {\n            isNumberOfStatementsCorrect = "true";\n        }\n        // var returnedValue = [areThereErrors, isNumberOfStatementsCorrect];\n        return [areThereErrors, isNumberOfStatementsCorrect];\n    };\n\n\n    EXCEL.getStatements = function (statementData1) {\n        var qavCurrentStatements = [];\n        for (var s = 0, sLen = statementData1[0].length; s < sLen; s++) {\n            var temp12 = statementData1[0][s].Statements;\n            if (temp12 === "" || temp12 === undefined || temp12 === null) {} else {\n                qavCurrentStatements.push(temp12);\n            }\n        }\n        return qavCurrentStatements;\n    };\n\n    EXCEL.getRespondentSorts = function (sortData) {\n        var sortDataTransposed = _.zip.apply(_, sortData);\n        var data2 = [];\n        for (var p = 0; p < sortDataTransposed.length; p++) {\n            var sortedArray1 = _.sortBy(sortDataTransposed[p], function (obj) {\n                return obj.statementNum;\n            });\n            data2.push(sortedArray1);\n        }\n        var statementNumArray = [];\n        var temp2, temp2a;\n        var respondentDataSorts3 = [];\n        for (var q = 0; q < data2.length; q++) {\n            var temp11 = data2[q];\n            var tempArray3 = [];\n            var tempArray33 = [];\n            for (var r = 0; r < temp11.length; r++) {\n                temp2 = temp11[r].sortValue;\n                temp2a = temp11[r].statementNum;\n                tempArray3.push(temp2);\n                tempArray33.push(temp2a);\n            }\n            respondentDataSorts3.push(tempArray3);\n            statementNumArray.push(tempArray33);\n        }\n        var returnedValue = [respondentDataSorts3, statementNumArray];\n        return [respondentDataSorts3, statementNumArray];\n    };\n\n    EXCEL.getRespondentNames = function (namesData) {\n        var qavRespondentNames = [];\n        for (var m = 0, mLen = namesData.length; m < mLen; m++) {\n            var temp1 = namesData[m].statementNum;\n            if (temp1 !== "") {\n                qavRespondentNames.push(temp1);\n            }\n        }\n        qavRespondentNames = UTIL.checkUniqueName(qavRespondentNames);\n        return qavRespondentNames;\n    };\n\n    EXCEL.prepInputData = function (inputData1, qavOriginalSortSize) {\n        var sortData = [];\n        var sortLength = 29 + qavOriginalSortSize;\n        var counter = (inputData1[28].length) - 1;\n\n        for (var k = 28; k < sortLength; k++) {\n            var key = inputData1[k][0];\n            var value;\n            var tempArray1 = [];\n            var j = 1;\n            var tempObj1;\n\n            for (var kr = 0; kr < counter; kr++) {\n                value = inputData1[k][j];\n\n                // catch the respondent names first\n                if (k === 28 && value !== "") {\n                    tempObj1 = {};\n                    tempObj1.sortValue = key;\n                    tempObj1.statementNum = value;\n                    tempArray1.push(tempObj1);\n                } else {\n                    if (value !== "") {\n                        tempObj1 = {};\n                        tempObj1.sortValue = +key;\n                        tempObj1.statementNum = +value;\n                        tempArray1.push(tempObj1);\n                    }\n                }\n                j = j + 1;\n            }\n            sortData.push(tempArray1);\n        }\n        return sortData;\n    };\n\n    EXCEL.createMultiplierArrayAndTriangleShape = function (inputData1) {\n        console.log(inputData1);\n        var qavSortTriangleShape = [];\n        var multiplierArray = [];\n        for (var i = 4; i < 24; i++) {\n            var testValue = +inputData1[i][1];\n            if (testValue < 1 || isNaN(testValue)) {\n                multiplierArray.push(0);\n            } else {\n                var multiplier = +inputData1[i][1];\n                multiplierArray.push(multiplier);\n                var sortValue = +inputData1[i][0];\n                for (var j = 0, jLen = multiplier; j < jLen; j++) {\n                    qavSortTriangleShape.push(sortValue);\n                }\n            }\n        }\n        return [multiplierArray, qavSortTriangleShape];\n    };\n\n\n    //\n    // ********************************************************************  model\n    // ***** Format Type 2 Excel file (Unforced) for Display *********************\n    // ***************************************************************************\n\n    function formatUnforcedUploadForDisplay(data) {\n        var language = QAV.getState("language");\n        var errorText1 = resources[language].translation["has missing Q-sort values"];\n        var errorText2 = resources[language].translation["has an incorrect Q-sort value"];\n        var nonSymSortsDivHeader = resources[language].translation["Non-Symmetric Q-sorts"];\n        var prev;\n        var multiplierArray = [];\n\n        // QAV #1\n        var qavProjectName1 = data[0][0][1];\n        var qavProjectName = qavProjectName1.toString().replace(/,/g, \'\');\n        QAV.setState("qavProjectName", qavProjectName);\n\n        // QAV #2 - calculate sort design array\n        var calcSortTriangleT2 = EXCEL.calcSortTriangleShapeT2(data[0][0][3]);\n        var copyTriangleShape = calcSortTriangleT2[0];\n        var testSortTriangleShapeArray = calcSortTriangleT2[1];\n        var qavSortTriangleShape = calcSortTriangleT2[2];\n        QAV.setState("qavSortTriangleShape", qavSortTriangleShape);\n\n        // calculate multiplierArray\n        multiplierArray = EXCEL.calcMultiplierArrayT2(copyTriangleShape);\n        QAV.setState("multiplierArray", multiplierArray);\n\n        // QAV #3 - set Q-sort size\n        var qavOriginalSortSize = qavSortTriangleShape.length; // number of statements\n        QAV.setState("qavOriginalSortSize", qavOriginalSortSize);\n        // todo - fix qavOriginalSortSize and qavTotalStatements are same - symmetry check functions\n        QAV.setState("qavTotalStatements", qavOriginalSortSize);\n        QAV.setState("originalSortSize", qavOriginalSortSize);\n\n        // QAV #4 - grab respondent names and sorts\n        var sortsDataT2 = data[0][0];\n        var calcSorts = EXCEL.grabRespondentNamesAndSorts(sortsDataT2);\n        var qavRespondentNames = calcSorts[0];\n        var respondentSortsArray = calcSorts[1];\n        var symmetryCheckArray = calcSorts[2];\n        // todo - fix double coverage of res names\n        QAV.setState("qavRespondentNames", qavRespondentNames);\n        QAV.setState("respondentNames", qavRespondentNames);\n\n\n        // QAV #5\n        var qavTotalNumberSorts = qavRespondentNames.length;\n        QAV.setState("qavTotalNumberSorts", qavTotalNumberSorts);\n        QAV.setState("totalNumberSorts", qavTotalNumberSorts);\n\n\n        // QAV #6 - set respondent sorts\n        var qavRespondentSortsFromDbStored = respondentSortsArray;\n        QAV.setState("qavRespondentSortsFromDbStored", qavRespondentSortsFromDbStored);\n\n\n        // QAV #7\n        var statementsDataT2 = data[1][0];\n        var qavCurrentStatements = EXCEL.grabProjectStatements(statementsDataT2);\n        QAV.setState("qavCurrentStatements", qavCurrentStatements);\n\n        //\n        // ERROR TESTING\n        //\n        var checkForErrors = EXCEL.checkForErrors(testSortTriangleShapeArray, symmetryCheckArray);\n        var areThereErrors = checkForErrors[0];\n        var nonSymmetricSorts = checkForErrors[1];\n\n\n        // Display respondents and sorts OR error messages\n        var respondentSorts = [];\n        if (areThereErrors.length === 0) {\n            for (var q = 0; q < qavCurrentStatements.length; q++) {\n                var sortStatement = qavCurrentStatements[q];\n                $("#existingDatabaseStatementList").append("<li>" + sortStatement + "</li>");\n            }\n            for (var rr = 0; rr < qavRespondentSortsFromDbStored.length; rr++) {\n                var sortItem = qavRespondentSortsFromDbStored[rr];\n                var sortItem3 = sortItem.replace(/,/g, " ").replace(/ -/g, "-");\n                if (sortItem3.charAt(0) !== "-") {\n                    sortItem3 = " " + sortItem3;\n                }\n                respondentSorts.push((sortItem3));\n                var respondent = qavRespondentNames[rr];\n                $("#existingDatabaseRespondentList").append("<li>" + respondent + "," + sortItem + "</li>");\n            }\n            if (nonSymmetricSorts.length > 0) {\n                $("#nonSymmetricSortsDiv").append("<h4>" + nonSymSortsDivHeader + "</h4>");\n                for (var w = 0; w < nonSymmetricSorts.length; w++) {\n                    $("#nonSymmetricSortsDiv").append("<p>" + qavRespondentNames[nonSymmetricSorts[w]] + ", </p>");\n                }\n            }\n            // show the download button in analysis data div\n            $(".jsonDownloadPQ").show();\n        } else {\n            $("#genericErrorModal .errorPanel").empty();\n            for (var t = 0; t < areThereErrors.length; t++) {\n                $("#genericErrorModal .errorPanel").append("<p>" + qavRespondentNames[areThereErrors[t][0]] + " " + areThereErrors[t][1] + "</p><br>");\n            }\n            VIEW.showGenericErrorModal();\n        }\n        QAV.setState("qavRespondentSortsFromDbStored", respondentSorts);\n    }\n\n\n\n    EXCEL.checkForErrors = function (testSortTriangleShapeArray, symmetryCheckArray) {\n        var language = QAV.getState("language");\n        var errorText1 = resources[language].translation["has missing statement numbers"];\n        var errorText2 = resources[language].translation["has an incorrect statement number"];\n        var areThereErrors = [];\n        var nonSymmetricSorts = [];\n\n        // test for missing values / consistent length\n        var testMax = _.max(testSortTriangleShapeArray);\n        var testMin = _.min(testSortTriangleShapeArray);\n        var testLen = testSortTriangleShapeArray.length;\n        var min, max, testSym;\n        for (var k = 0, kLen = symmetryCheckArray.length; k < kLen; k++) {\n            // console.log(symmetryCheckArray[k].length);\n            if (symmetryCheckArray[k].length !== testLen) {\n                areThereErrors.push([k, errorText1]);\n            }\n            max = _.max(symmetryCheckArray[k]);\n            min = _.min(symmetryCheckArray[k]);\n            if (max > testMax || min < testMin) {\n                areThereErrors.push([k, errorText2]);\n            }\n            testSym = checkQsortValueMatch(symmetryCheckArray[k], testSortTriangleShapeArray);\n            if (testSym > 0) {\n                nonSymmetricSorts.push(k);\n            }\n        }\n        return [areThereErrors, nonSymmetricSorts];\n    };\n\n    EXCEL.grabProjectStatements = function (statementsDataT2) {\n        var qavCurrentStatements = [];\n        for (var s = 0, sLen = statementsDataT2.length; s < sLen; s++) {\n            var temp12 = statementsDataT2[s].Statements;\n            if (temp12 === "" || temp12 === undefined || temp12 === null) {} else {\n                qavCurrentStatements.push(temp12);\n            }\n        }\n        return qavCurrentStatements;\n    };\n\n    EXCEL.grabRespondentNamesAndSorts = function (sortsDataT2) {\n        var symmetryCheckArray = [];\n        var qavRespondentNames = [];\n        var sortsForDisplay = [];\n        var respondentSortsArray = [];\n        for (var m = 6; m < sortsDataT2.length; m++) {\n            var temp1 = sortsDataT2[m].toString().replace(/,,/g, \'\');\n            // to prevent from reading empty cells as data\n            if (temp1.length < 5) {\n                break;\n            }\n            // convert from array of strings to array of numbers\n            sortsForDisplay.push(temp1);\n            temp1 = removeTrailingCommaFromText(temp1);\n            var temp3 = temp1.split(\',\');\n            var temp4 = temp3.shift();\n            var temp5 = temp3.toString();\n            // check to confirm sort value is numeric\n            if (temp5.match(/[^,-\\d]/)) {\n                var errorPanel = $("#genericErrorModal .errorPanel");\n                errorPanel.empty();\n                errorPanel.append("<p>The Q-sort for respondent " + temp4 + " contains non-numeric data</p>");\n                VIEW.showGenericErrorModal();\n                return;\n            }\n            qavRespondentNames.push(temp4);\n            respondentSortsArray.push(temp5);\n            symmetryCheckArray.push(temp3);\n        }\n        return [qavRespondentNames, respondentSortsArray, symmetryCheckArray];\n    };\n\n    EXCEL.calcMultiplierArrayT2 = function (copyTriangleShape) {\n        var multiplierArray = [];\n        var prev;\n        for (var i = 0, iLen = copyTriangleShape.length; i < iLen; i++) {\n            if (copyTriangleShape[i] !== prev) {\n                multiplierArray.push(1);\n            } else {\n                multiplierArray[multiplierArray.length - 1]++;\n            }\n            prev = copyTriangleShape[i];\n        }\n        // pad the multiplierArray\n        var leadValue = copyTriangleShape[0];\n        var minLeadValue = -6;\n        var padding = Math.abs(minLeadValue - leadValue);\n        for (var p = 0; p < padding; p++) {\n            multiplierArray.unshift(0);\n        }\n        for (var j = 0; j < 20; j++) {\n            if (multiplierArray.length < 20) {\n                multiplierArray.push(0);\n            }\n        }\n        return multiplierArray;\n    };\n\n\n    EXCEL.calcSortTriangleShapeT2 = function (qavSortTriangleShape1) {\n        var qavSortTriangleShape2 = qavSortTriangleShape1.replace(/,,/g, \'\');\n        qavSortTriangleShape2 = removeTrailingCommaFromText(qavSortTriangleShape2);\n        var qavSortTriangleShape3 = qavSortTriangleShape2.replace(/Sort Pattern,/, \'\');\n        var tempTriangle2 = qavSortTriangleShape3.split(",");\n        for (var a in tempTriangle2) {\n            tempTriangle2[a] = parseInt(tempTriangle2[a], 10);\n        }\n        var copyTriangleShape = _.cloneDeep(tempTriangle2);\n        var testSortTriangleShapeArray = _.cloneDeep(tempTriangle2);\n        var qavSortTriangleShape = _.cloneDeep(tempTriangle2);\n        return [copyTriangleShape, testSortTriangleShapeArray, qavSortTriangleShape];\n    };\n\n\n\n\n    // HELPER FUNCTIONS\n\n    function removeTrailingCommaFromText(string) {\n        var lastChar = string.slice(-1);\n        if (lastChar == \',\') {\n            string = string.slice(0, -1);\n        }\n        return string;\n    }\n\n    // strips everything but letters and numbers and "." "-"\n    function sanitizeSortValues(value) {\n        return value.replace(/[^a-zA-Z0-9.-]/g, function () {\n            return \'\';\n        });\n    }\n\n    function checkQsortValueMatch(inputArray, triangleShapeArray) {\n        var testVar = _.cloneDeep(triangleShapeArray);\n        var a = inputArray.sort().join(\',\');\n        var b = testVar.sort().join(\',\');\n        // console.log(JSON.stringify(a));\n        // console.log(JSON.stringify(b));\n        if (a !== b) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n\n    //\n    // ********************************************************************  model\n    // ***** Format Type 3 Ken-Q Output File for Display *************************\n    // ***************************************************************************\n\n    function formatKenqUploadForDisplay(data) {\n        // QAV #1\n        var qavProjectName = data[0][0][0][""];\n\n        QAV.setState("qavProjectName", qavProjectName);\n\n        // QAV #2 - get sort triangle shape\n        var grabSortTriangleShapeT3 = EXCEL.grabSortTriangleShapeT3(data[0][0][4][""]);\n        var qavSortTriangleShape = grabSortTriangleShapeT3[0];\n        var copyTriangleShape = grabSortTriangleShapeT3[1];\n        QAV.setState("qavSortTriangleShape", qavSortTriangleShape);\n\n        // calculate multiplierArray\n        var multiplierArray = EXCEL.calcMultiplierArrayT2(copyTriangleShape);\n        QAV.setState("multiplierArray", multiplierArray);\n\n        // QAV #3\n        var qavOriginalSortSize = qavSortTriangleShape.length; // number of statements\n        QAV.setState("qavOriginalSortSize", qavOriginalSortSize);\n        // todo - fix qavOriginalSortSize and qavTotalStatements are same - symmetry check functions\n        QAV.setState("qavTotalStatements", qavOriginalSortSize);\n        QAV.originalSortSize = qavOriginalSortSize;\n\n        // QAV #4 - pull respondent names from data\n        var qavRespondentNames = EXCEL.grabRespondentNamesT3(data[2]);\n        QAV.setState("qavRespondentNames", qavRespondentNames);\n        QAV.setState("respondentNames", qavRespondentNames);\n\n        // QAV #5 - set total number of sorts\n        var qavTotalNumberSorts = qavRespondentNames.length;\n        QAV.setState("qavTotalNumberSorts", qavTotalNumberSorts);\n        QAV.setState("totalNumberSorts", qavTotalNumberSorts);\n\n        // QAV #6 - get respondent sorts \n        var qavRespondentSortsFromDbStored = EXCEL.grabSortsT3(data[2], qavOriginalSortSize);\n\n        // QAV #7 - get statements\n        var qavCurrentStatements = EXCEL.grabStatementsT3(data[1][0]);\n        QAV.setState("qavCurrentStatements", qavCurrentStatements);\n\n        // SYMMETRY TESTING  -  TODO - ADD Non-Symmetric notification\n        var sortsTestingArray = _.cloneDeep(qavRespondentSortsFromDbStored);\n        var shouldDisplayResults = [];\n\n        // Display respondents and sorts\n        var respondentSorts = [];\n        if (shouldDisplayResults.length === 0) {\n            for (var q = 0; q < qavCurrentStatements.length; q++) {\n                var sortStatement = qavCurrentStatements[q];\n                $("#existingDatabaseStatementList").append("<li>" + sortStatement + "</li>");\n            }\n            for (var r = 0; r < qavRespondentSortsFromDbStored.length; r++) {\n                var sortItem = qavRespondentSortsFromDbStored[r];\n                var sortItem2 = sortItem.join();\n                var sortItem3 = sortItem2.replace(/,/g, " ").replace(/ -/g, "-");\n                if (sortItem3.charAt(0) !== "-") {\n                    sortItem3 = " " + sortItem3;\n                }\n                respondentSorts.push((sortItem3));\n                var respondent = qavRespondentNames[r];\n                $("#existingDatabaseRespondentList").append("<li>" + respondent + "," + sortItem + "</li>");\n            }\n            // display PQMethod export button\n            $(".jsonDownloadPQ").show();\n        }\n        QAV.setState("qavRespondentSortsFromDbStored", respondentSorts);\n    }\n\n    EXCEL.grabStatementsT3 = function (data) {\n        var qavCurrentStatements = [];\n        for (var pp = 1; pp < data.length; pp++) {\n            var temp11 = data[pp][""];\n            if (temp11 === "" || temp11 === undefined || temp11 === null) {} else {\n                qavCurrentStatements.push(temp11);\n            }\n        }\n        return qavCurrentStatements;\n    };\n\n    EXCEL.grabSortsT3 = function (data, qavOriginalSortSize) {\n        var qavRespondentSortsFromDbStored = [];\n        for (var k = 4; k < data.length; k++) {\n            var tempArray1 = [];\n            var isEmpty = data[k][1];\n            if (isEmpty === "" || isEmpty === null || isEmpty === undefined) {} else {\n                var temp2 = data[k][1];\n                var start = sanitizeSortValues(temp2);\n                tempArray1.push(+start);\n                var mLength = qavOriginalSortSize;\n                for (var m = 2; m < mLength; m++) {\n                    var temp3 = data[k][m];\n                    tempArray1.push(+temp3);\n                }\n                var finish2 = data[k][mLength];\n                var finish = sanitizeSortValues(finish2);\n                tempArray1.push(+finish);\n                qavRespondentSortsFromDbStored.push(tempArray1);\n            }\n        }\n        return qavRespondentSortsFromDbStored;\n    };\n\n    EXCEL.grabRespondentNamesT3 = function (data) {\n        var qavRespondentNames2 = [];\n        for (var jj = 1, jjLen = data.length; jj < jjLen; jj++) {\n            var temp1 = data[jj][0];\n            if (temp1 === "") {} else {\n                qavRespondentNames2.push(temp1);\n            }\n        }\n        var qavRespondentNames = qavRespondentNames2.slice(2);\n        return qavRespondentNames;\n    };\n\n    EXCEL.grabSortTriangleShapeT3 = function (qavSortTriangleShape1) {\n        var qavSortTriangleShape = JSON.parse("[" + qavSortTriangleShape1 + "]");\n        var copyTriangleShape = _.cloneDeep(qavSortTriangleShape);\n        var returns = [qavSortTriangleShape, copyTriangleShape];\n        return [qavSortTriangleShape, copyTriangleShape];\n    };\n\n}(window.EXCEL = window.EXCEL || {}, QAV));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9FWENFTC5qcz9hMjc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vS2VuLVEgQW5hbHlzaXNcbi8vQ29weXJpZ2h0IChDKSAyMDE2IFNoYXduIEJhbmFzaWNrXG4vL1xuLy8gICAgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuLy8gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuXG4vLyBKU2xpbnQgZGVjbGFyYXRpb25zXG4vKiBnbG9iYWwgd2luZG93LCByZXNvdXJjZXMsIHNhdmVBcywgQmxvYiwgUUFWLCAkLCBJTlBVVCwgZDMsIGxvY2FsU3RvcmFnZSwgVklFVywgRmlsZVJlYWRlciwgWExTWCwgVVRJTCwgXyAqL1xuXG4oZnVuY3Rpb24gKEVYQ0VMLCBRQVYsIHVuZGVmaW5lZCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvL1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICBtb2RlbFxuICAgIC8vICoqKioqIEV4cG9ydGluZyBTb3J0cyB0byBQUU1ldGhvZCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLy8gdG9kbyAtIGRyeSBvdXQgYnkgcmVmYWN0b3JpbmcgaW5wdXROZXdEYXRhIGZ1bmN0aW9uc1xuICAgIEVYQ0VMLmV4cG9ydEV4Y2VsU29ydHNQUU0gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICAkKFwiI2V4aXN0aW5nRGF0YWJhc2VSZXNwb25kZW50TGlzdCBsaVwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wMjEgPSAoJCh0aGlzKS50ZXh0KCkpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godGVtcDIxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZXhwb3J0IGZpbGUgbGluZSAjMSAtIGNhbGN1bGF0ZSBudW1iZXIgb2YgcmVzcG9uZGVudHNcbiAgICAgICAgdmFyIHRlbXAxLCB0ZW1wMWEsIHRlbXAyLCB0ZW1wMywgdGVtcDNhLCB0ZW1wM2I7XG4gICAgICAgIHRlbXAxID0gb3V0cHV0Lmxlbmd0aDtcbiAgICAgICAgdGVtcDFhID0gU3RyaW5nKFVUSUwudGhyZWVEaWdpdFBhZGRpbmcodGVtcDEpKTtcblxuXG4gICAgICAgIC8vIGdyYWIgUHJvamVjdCBOYW1lXG4gICAgICAgIHRlbXAyID0gUUFWLmdldFN0YXRlKFwicWF2UHJvamVjdE5hbWVcIik7XG5cbiAgICAgICAgLy8gZ2V0IG1heCByYW5nZSBudW1iZXJzXG4gICAgICAgIHZhciB0ZW1wNSA9IFFBVi5nZXRTdGF0ZShcInFhdlNvcnRUcmlhbmdsZVNoYXBlXCIpO1xuICAgICAgICB2YXIgdGVtcDViID0gXy5taW4odGVtcDUpO1xuICAgICAgICB2YXIgdGVtcDVjID0gXy5tYXgodGVtcDUpO1xuICAgICAgICB2YXIgdGVtcDVkID0gU3RyaW5nKFVUSUwudGhyZWVEaWdpdFBhZGRpbmcoK3RlbXA1YikpO1xuICAgICAgICB2YXIgdGVtcDVlID0gU3RyaW5nKFVUSUwudGhyZWVEaWdpdFBhZGRpbmcoK3RlbXA1YykpO1xuXG5cbiAgICAgICAgLy8gZ2V0IHRyaWFuZ2Ugc2hhcGVcbiAgICAgICAgdmFyIHRlbXA2ID0gUUFWLmdldFN0YXRlKFwibXVsdGlwbGllckFycmF5XCIpO1xuICAgICAgICB2YXIgdGVtcDZhID0gXCJcIjtcbiAgICAgICAgdmFyIHRlbXA2YiA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICAgICAgdGVtcDZhID0gU3RyaW5nKFVUSUwudGhyZWVEaWdpdFBhZGRpbmcodGVtcDZbaV0pKTtcbiAgICAgICAgICAgIHRlbXA2YiArPSB0ZW1wNmE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGluZyB0aGUgbnVtYmVyIG9mIHN0YXRlbWVudHNcbiAgICAgICAgdGVtcDMgPSBRQVYuZ2V0U3RhdGUoXCJxYXZDdXJyZW50U3RhdGVtZW50c1wiKTtcbiAgICAgICAgaWYgKHRlbXAzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGVtcDNhID0gdGVtcDUubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcDNhID0gdGVtcDMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRlbXAzYiA9IFN0cmluZyhVVElMLnRocmVlRGlnaXRQYWRkaW5nKHRlbXAzYSkpO1xuXG4gICAgICAgIC8vIHNldCBQUU1ldGhvZCBEQVQgZmlsZSBsaW5lIDJcbiAgICAgICAgdmFyIGxpbmUyID0gdGVtcDVkICsgdGVtcDVlICsgdGVtcDZiO1xuICAgICAgICAkKFwiI2V4Y2VsU29ydEV4cG9ydEJveFwiKS5hcHBlbmQoXCIgIDBcIiArIHRlbXAxYSArIHRlbXAzYiArIFwiIFwiICsgdGVtcDIpO1xuICAgICAgICAkKFwiI2V4Y2VsU29ydEV4cG9ydEJveFwiKS5hcHBlbmQoXCJcXG5cIik7XG4gICAgICAgICQoXCIjZXhjZWxTb3J0RXhwb3J0Qm94XCIpLmFwcGVuZChsaW5lMik7XG4gICAgICAgICQoXCIjZXhjZWxTb3J0RXhwb3J0Qm94XCIpLmFwcGVuZChcIlxcblwiKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG91dHB1dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHRlbXA4ID0gb3V0cHV0W2pdLnNwbGl0KFwiLFwiKTtcblxuICAgICAgICAgICAgdmFyIHJlc3BvbmRlbnROYW1lID0gdGVtcDhbMF07XG4gICAgICAgICAgICB2YXIgdGVtcDhhID0gSU5QVVQuc2FuaXRpemVSZXNwb25kZW50TmFtZShyZXNwb25kZW50TmFtZSk7XG5cbiAgICAgICAgICAgIHZhciB0ZW1wOGMgPSB0ZW1wOC5zbGljZSgxLCB0ZW1wOC5sZW5ndGgpO1xuXG4gICAgICAgICAgICB2YXIgdGVtcDhkID0gdGVtcDhjLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0Rm9yQnV0dG9uVGV4dCA9IHRlbXA4ZC5zbGljZSgtNCk7XG4gICAgICAgICAgICBpZiAodGVzdEZvckJ1dHRvblRleHQgPT09IFwic29ydFwiKSB7XG4gICAgICAgICAgICAgICAgdGVtcDhkID0gdGVtcDhkLnJlcGxhY2UoL2RlbGV0ZSBzb3J0L2csIFwiXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGVtcDhlID0gdGVtcDhkLnJlcGxhY2UoLywvZywgXCIgXCIpO1xuICAgICAgICAgICAgdmFyIHRlbXA4ZiA9IHRlbXA4ZS5yZXBsYWNlKC8gLS9nLCBcIi1cIik7XG4gICAgICAgICAgICB2YXIgdGVtcDhnID0gdGVtcDhmLnJlcGxhY2UoL1tcXFtcXF0nXSsvZywgJycpO1xuXG4gICAgICAgICAgICBpZiAoK3RlbXA4WzFdIDwgMCkge1xuICAgICAgICAgICAgICAgIHRlbXA4ZyA9IFwiICBcIiArIHRlbXA4ZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVtcDhnID0gXCIgICBcIiArIHRlbXA4ZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ZW1wOSA9IHRlbXA4YSArIHRlbXA4ZztcbiAgICAgICAgICAgICQoXCIjZXhjZWxTb3J0RXhwb3J0Qm94XCIpLmFwcGVuZCh0ZW1wOSk7XG4gICAgICAgICAgICAkKFwiI2V4Y2VsU29ydEV4cG9ydEJveFwiKS5hcHBlbmQoXCJcXG5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2RvIC0gYWRkIGNoZWNrIHRvIG1hdGNoIHN0YXRlbWVudHMubGVuZ3RoIHdpdGggcHlyYW1pZCBzb3J0IGVudHJ5IHN1bVxuXG4gICAgICAgIC8vIHB1bGwgYWxsIGRhdGEgZnJvbSBoaWRkZW4gZXhwb3J0IHByZXAgYm94XG4gICAgICAgIHZhciBleHBvcnREYXRhID0gJCgnI2V4Y2VsU29ydEV4cG9ydEJveCcpLnZhbCgpO1xuXG4gICAgICAgIHZhciB0aW1lU3RhbXAgPSBVVElMLmN1cnJlbnREYXRlMSgpICsgXCItXCIgKyBVVElMLmN1cnJlbnRUaW1lMSgpO1xuXG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2V4cG9ydERhdGFdLCB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHQvcGxhaW47Y2hhcnNldD11cy1hc2NpaVwiXG4gICAgICAgIH0pO1xuICAgICAgICBzYXZlQXMoYmxvYiwgXCJLZW4tUV9QUU1ldGhvZF9FeHBvcnRfXCIgKyB0aW1lU3RhbXAgKyBcIi5EQVRcIik7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGhpZGRlbiBleHBvcnQgYm94XG4gICAgICAgICQoXCIjZXhjZWxTb3J0RXhwb3J0Qm94XCIpLmh0bWwoXCJcIik7XG4gICAgfTtcblxuICAgIEVYQ0VMLmV4cG9ydFN0YXRlbWVudHNUb1BxbWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGVtcCA9IFFBVi5nZXRTdGF0ZShcInFhdkN1cnJlbnRTdGF0ZW1lbnRzXCIpO1xuICAgICAgICB2YXIgJGV4cG9ydEJveCA9ICQoXCIjZXhjZWxTb3J0RXhwb3J0Qm94XCIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICRleHBvcnRCb3guYXBwZW5kKHRlbXBbaV0sIFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHBvcnREYXRhID0gJGV4cG9ydEJveC52YWwoKTtcblxuICAgICAgICB2YXIgdGltZVN0YW1wID0gVVRJTC5jdXJyZW50RGF0ZTEoKSArIFwiLVwiICsgVVRJTC5jdXJyZW50VGltZTEoKTtcblxuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtleHBvcnREYXRhXSwge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9dXMtYXNjaWlcIlxuICAgICAgICB9KTtcbiAgICAgICAgc2F2ZUFzKGJsb2IsIFwiS2VuLVFfUFFNZXRob2RfU3RhdGVtZW50c19cIiArIHRpbWVTdGFtcCArIFwiLlNUQVwiKTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgaGlkZGVuIGV4cG9ydCBib3hcbiAgICAgICAgJChcIiNleGNlbFNvcnRFeHBvcnRCb3hcIikuaHRtbChcIlwiKTtcbiAgICB9O1xuXG5cblxuICAgIC8vXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKiBJbXBvcnQgVHlwZSAxIG9yIFR5cGUgMiBGaWxlcyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgRVhDRUwuZmlsZVBpY2tlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBmaWxldHlwZSA9IFFBVi5nZXRTdGF0ZShcInR5cGVPZkV4Y2VsRmlsZVwiKTtcbiAgICAgICAgdmFyIGZpbGVzID0gZS50YXJnZXQuZmlsZXNbMF07XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICB2YXIgdGVzdGVyLCB0ZXN0ZXIyLCB0ZXN0ZXIzLCB0ZXN0ZXI0O1xuICAgICAgICB2YXIgdGVtcEFycmF5ID0gW107XG4gICAgICAgIHZhciBhbGxXb3Jrc2hlZXRzID0gW107XG4gICAgICAgIHZhciBkYXRhLCB3b3JrYm9vaywgd29ya3NoZWV0LCBzaGVldF9uYW1lX2xpc3Q7XG4gICAgICAgIHZhciBoYXNTb3J0c1dvcmtzaGVldCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGFzU3RhdGVtZW50c1dvcmtzaGVldCA9IGZhbHNlO1xuICAgICAgICB2YXIgJGVycm9yUGFuZWwgPSAkKFwiI2dlbmVyaWNFcnJvck1vZGFsIC5lcnJvclBhbmVsXCIpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgICAgIHdvcmtib29rID0gWExTWC5yZWFkKGRhdGEsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmluYXJ5J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBldmVyeSBzaGVldCBhbmQgcHVsbCB2YWx1ZXNcbiAgICAgICAgICAgIHNoZWV0X25hbWVfbGlzdCA9IHdvcmtib29rLlNoZWV0TmFtZXM7XG4gICAgICAgICAgICBzaGVldF9uYW1lX2xpc3QuZm9yRWFjaChmdW5jdGlvbiAoeSkgeyAvKiBpdGVyYXRlIHRocm91Z2ggc2hlZXRzICovXG5cbiAgICAgICAgICAgICAgICB3b3Jrc2hlZXQgPSB3b3JrYm9vay5TaGVldHNbeV07XG4gICAgICAgICAgICAgICAgaWYgKHkgPT09IFwic29ydHNcIikge1xuICAgICAgICAgICAgICAgICAgICBoYXNTb3J0c1dvcmtzaGVldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RlciA9IFhMU1gudXRpbHMuc2hlZXRfdG9fY3N2KHdvcmtzaGVldCk7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RlcjIgPSB0ZXN0ZXIuc3BsaXQoL1xcbi8pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxldHlwZSA9PT0gXCJ1c2VyLWlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMjAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0ZXIzID0gdGVzdGVyMltpXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBBcnJheS5wdXNoKHRlc3RlcjMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGV0eXBlID09PSBcInVuZm9yY2VkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RlcjMgPSB0ZXN0ZXIyLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBBcnJheS5wdXNoKHRlc3RlcjMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHkgPT09IFwic3RhdGVtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1N0YXRlbWVudHNXb3Jrc2hlZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGVzdGVyNCA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbih3b3Jrc2hlZXQpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQXJyYXkucHVzaCh0ZXN0ZXI0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWxsV29ya3NoZWV0cy5wdXNoKHRlbXBBcnJheSk7XG4gICAgICAgICAgICB9KTsgLy8gZW5kIGl0ZXJhdGlvbiBvZiBmb3IgZWFjaFxuICAgICAgICAgICAgaWYgKGhhc1NvcnRzV29ya3NoZWV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICRlcnJvclBhbmVsLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgJGVycm9yUGFuZWwuYXBwZW5kKFwiPHA+Q2FuJ3QgZmluZCB0aGUgJ3NvcnRzJyB3b3Jrc2hlZXQuIFBsZWFzZSBjaGVjayB5b3VyIGZpbGUncyB3b3Jrc2hlZXQgbmFtZXMgYW5kIHRyeSBhZ2Fpbi48L3A+PGJyPlwiKTtcbiAgICAgICAgICAgICAgICBWSUVXLnNob3dHZW5lcmljRXJyb3JNb2RhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1N0YXRlbWVudHNXb3Jrc2hlZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgJGVycm9yUGFuZWwuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAkZXJyb3JQYW5lbC5hcHBlbmQoXCI8cD5DYW4ndCBmaW5kIHRoZSAnc3RhdGVtZW50cycgd29ya3NoZWV0LiBQbGVhc2UgY2hlY2sgeW91ciBmaWxlJ3Mgd29ya3NoZWV0IG5hbWVzIGFuZCB0cnkgYWdhaW4uPC9wPjxicj5cIik7XG4gICAgICAgICAgICAgICAgVklFVy5zaG93R2VuZXJpY0Vycm9yTW9kYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxldHlwZSA9PT0gXCJ1c2VyLWlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRVcGxvYWRGb3JEaXNwbGF5KGFsbFdvcmtzaGVldHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxldHlwZSA9PT0gXCJ1bmZvcmNlZFwiKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0VW5mb3JjZWRVcGxvYWRGb3JEaXNwbGF5KGFsbFdvcmtzaGVldHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZWFkZXIucmVhZEFzQmluYXJ5U3RyaW5nKGZpbGVzKTtcbiAgICB9O1xuXG5cbiAgICAvL1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqIEltcG9ydCBUeXBlIDMgLSBLRU4tUSBPVVRQVVQgRmlsZSAqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIEVYQ0VMLmZpbGVQaWNrZWRLZW5xID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBsb2NhbFRleHQxID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlByb2plY3QgT3ZlcnZpZXdcIl07XG4gICAgICAgIHZhciBsb2NhbFRleHQyID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5TdGF0ZW1lbnRzO1xuICAgICAgICB2YXIgZXJyb3JQYW5lbCA9ICQoXCIjZ2VuZXJpY0Vycm9yTW9kYWwgLmVycm9yUGFuZWxcIik7XG5cbiAgICAgICAgdmFyIGZpbGVzID0gZS50YXJnZXQuZmlsZXNbMF07XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICB2YXIgd29ya2Jvb2sgPSBYTFNYLnJlYWQoZGF0YSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdiaW5hcnknXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IHNoZWV0IGFuZCBwdWxsIHZhbHVlc1xuICAgICAgICAgICAgdmFyIGhhc1NvcnRzV29ya3NoZWV0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaGFzU3RhdGVtZW50c1dvcmtzaGVldCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGhhc1NvcnRzV29ya3NoZWV0RnJvbUtlblEgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBhbGxXb3Jrc2hlZXRzID0gW107XG4gICAgICAgICAgICB2YXIgc2hlZXRfbmFtZV9saXN0ID0gd29ya2Jvb2suU2hlZXROYW1lcztcbiAgICAgICAgICAgIHNoZWV0X25hbWVfbGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh5KSB7IC8qIGl0ZXJhdGUgdGhyb3VnaCBzaGVldHMgKi9cblxuICAgICAgICAgICAgICAgIHZhciB3b3Jrc2hlZXQgPSB3b3JrYm9vay5TaGVldHNbeV07XG5cbiAgICAgICAgICAgICAgICB2YXIgdGVtcEFycmF5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHkgPT09IGxvY2FsVGV4dDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0ZXI2ID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtzaGVldCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBBcnJheS5wdXNoKHRlc3RlcjYpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh5ID09PSBcIlEtc29ydHNcIikge1xuICAgICAgICAgICAgICAgICAgICBoYXNTb3J0c1dvcmtzaGVldEZyb21LZW5RID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RlciA9IFhMU1gudXRpbHMuc2hlZXRfdG9fY3N2KHdvcmtzaGVldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0ZXIyID0gdGVzdGVyLnNwbGl0KC9cXG4vKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRlc3RlcjIuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0ZXIzID0gZW50cnkuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBBcnJheS5wdXNoKHRlc3RlcjMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHkgPT09IGxvY2FsVGV4dDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzU3RhdGVtZW50c1dvcmtzaGVldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdGVyNCA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbih3b3Jrc2hlZXQpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQXJyYXkucHVzaCh0ZXN0ZXI0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWxsV29ya3NoZWV0cy5wdXNoKHRlbXBBcnJheSk7XG4gICAgICAgICAgICB9KTsgLy8gZW5kIGl0ZXJhdGlvbiBmb3IgZWFjaFxuICAgICAgICAgICAgaWYgKGhhc1NvcnRzV29ya3NoZWV0RnJvbUtlblEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JQYW5lbC5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIGVycm9yUGFuZWwuYXBwZW5kKFwiPHA+Q2FuJ3QgZmluZCBRLXNvcnRzLiBQbGVhc2UgY2hlY2sgeW91ciBmaWxlJ3MgZm9ybWF0dGluZyBhbmQgdHJ5IGFnYWluLjwvcD48YnI+XCIpO1xuICAgICAgICAgICAgICAgIFZJRVcuc2hvd0dlbmVyaWNFcnJvck1vZGFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzU3RhdGVtZW50c1dvcmtzaGVldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvclBhbmVsLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgZXJyb3JQYW5lbC5hcHBlbmQoXCI8cD5DYW4ndCBmaW5kIHNvcnQgc3RhdGVtZW50cy4gUGxlYXNlIGNoZWNrIHlvdXIgZmlsZSdzIGZvcm1hdHRpbmcgYW5kIHRyeSBhZ2Fpbi48L3A+PGJyPlwiKTtcbiAgICAgICAgICAgICAgICBWSUVXLnNob3dHZW5lcmljRXJyb3JNb2RhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9ybWF0S2VucVVwbG9hZEZvckRpc3BsYXkoYWxsV29ya3NoZWV0cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcoZmlsZXMpO1xuICAgIH07XG5cblxuICAgIC8vXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICBtb2RlbFxuICAgIC8vICoqKioqIEZvcm1hdCBUeXBlIDEgSGFuZC1Db2RlZCBGaWxlIGZvciBEaXNwbGF5ICoqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVcGxvYWRGb3JEaXNwbGF5KGRhdGEpIHtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBlcnJvclRleHQxID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcImhhcyBtaXNzaW5nIHN0YXRlbWVudCBudW1iZXJzXCJdO1xuICAgICAgICB2YXIgZXJyb3JUZXh0MiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJoYXMgYW4gaW5jb3JyZWN0IHN0YXRlbWVudCBudW1iZXJcIl07XG4gICAgICAgIHZhciBlcnJvclRleHQzID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcIlRoZSBudW1iZXIgb2Ygc3RhdGVtZW50cyBpbiB0aGUgc3RhdG1lbnRzIHNoZWV0IG9mIHRoZSBFeGNlbCBmaWxlIGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2Ygc3RhdGVtZW50cyBpbiB0aGUgc29ydHMgc2hlZXRcIl07XG4gICAgICAgIHZhciBpc051bWJlck9mU3RhdGVtZW50c0NvcnJlY3QsIGFyZVRoZXJlRXJyb3JzO1xuXG4gICAgICAgIC8vIFFBViAjMVxuICAgICAgICB2YXIgcWF2UHJvamVjdE5hbWUgPSBkYXRhWzBdWzBdWzFdO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZQcm9qZWN0TmFtZVwiLCBxYXZQcm9qZWN0TmFtZSk7XG5cbiAgICAgICAgLy8gLy8gUUFWICMyICAtICB0b2RvIC0gZml4IGxvb3AgZnVuY3Rpb25cbiAgICAgICAgdmFyIGlucHV0RGF0YTEgPSBkYXRhWzBdO1xuICAgICAgICB2YXIgY3JlYXRlTXVsdGlwbGllckFycmF5QW5kVHJpYW5nbGVTaGFwZSA9IEVYQ0VMLmNyZWF0ZU11bHRpcGxpZXJBcnJheUFuZFRyaWFuZ2xlU2hhcGUoaW5wdXREYXRhMSk7XG4gICAgICAgIHZhciBtdWx0aXBsaWVyQXJyYXkgPSBjcmVhdGVNdWx0aXBsaWVyQXJyYXlBbmRUcmlhbmdsZVNoYXBlWzBdO1xuICAgICAgICB2YXIgcWF2U29ydFRyaWFuZ2xlU2hhcGUgPSBjcmVhdGVNdWx0aXBsaWVyQXJyYXlBbmRUcmlhbmdsZVNoYXBlWzFdO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZTb3J0VHJpYW5nbGVTaGFwZVwiLCBxYXZTb3J0VHJpYW5nbGVTaGFwZSk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcIm11bHRpcGxpZXJBcnJheVwiLCBtdWx0aXBsaWVyQXJyYXkpO1xuXG5cbiAgICAgICAgLy8gUUFWICMzXG4gICAgICAgIHZhciBxYXZPcmlnaW5hbFNvcnRTaXplID0gcWF2U29ydFRyaWFuZ2xlU2hhcGUubGVuZ3RoOyAvLyBudW1iZXIgb2Ygc3RhdGVtZW50c1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZPcmlnaW5hbFNvcnRTaXplXCIsIHFhdk9yaWdpbmFsU29ydFNpemUpO1xuICAgICAgICAvLyB0b2RvIC0gZml4IHFhdk9yaWdpbmFsU29ydFNpemUgYW5kIHFhdlRvdGFsU3RhdGVtZW50cyBhcmUgc2FtZSAtIHN5bW1ldHJ5IGNoZWNrIGZ1bmN0aW9uc1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZUb3RhbFN0YXRlbWVudHNcIiwgcWF2T3JpZ2luYWxTb3J0U2l6ZSk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcIm9yaWdpbmFsU29ydFNpemVcIiwgcWF2T3JpZ2luYWxTb3J0U2l6ZSk7XG4gICAgICAgIC8vIGNyZWF0ZXMgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHNvcnQgdmFsdWUgYW5kIHN0YXRlbWVudCBudW1iZXJcbiAgICAgICAgdmFyIHNvcnREYXRhID0gRVhDRUwucHJlcElucHV0RGF0YShpbnB1dERhdGExLCBxYXZPcmlnaW5hbFNvcnRTaXplKTtcblxuXG4gICAgICAgIC8vIFFBViAjNFxuXG4gICAgICAgIHZhciBuYW1lc0RhdGEgPSBzb3J0RGF0YS5zaGlmdCgpO1xuICAgICAgICB2YXIgcWF2UmVzcG9uZGVudE5hbWVzID0gRVhDRUwuZ2V0UmVzcG9uZGVudE5hbWVzKG5hbWVzRGF0YSk7XG4gICAgICAgIC8vIHRvZG8gLSBmaXggZG91YmxlIGNvdmVyYWdlIG9mIHJlcyBuYW1lc1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZSZXNwb25kZW50TmFtZXNcIiwgcWF2UmVzcG9uZGVudE5hbWVzKTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwicmVzcG9uZGVudE5hbWVzXCIsIHFhdlJlc3BvbmRlbnROYW1lcyk7XG5cblxuICAgICAgICAvLyBRQVYgIzVcbiAgICAgICAgdmFyIHFhdlRvdGFsTnVtYmVyU29ydHMgPSBxYXZSZXNwb25kZW50TmFtZXMubGVuZ3RoO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZUb3RhbE51bWJlclNvcnRzXCIsIHFhdlRvdGFsTnVtYmVyU29ydHMpO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJ0b3RhbE51bWJlclNvcnRzXCIsIHFhdlRvdGFsTnVtYmVyU29ydHMpO1xuXG4gICAgICAgIC8vIFFBViAjNiAgIHJlc3BvbmRlbnQgc29ydHNcbiAgICAgICAgdmFyIHJlc3BvbmRlbnREYXRhU29ydHNQcmVwID0gRVhDRUwuZ2V0UmVzcG9uZGVudFNvcnRzKHNvcnREYXRhKTtcbiAgICAgICAgdmFyIHJlc3BvbmRlbnREYXRhU29ydHMzID0gcmVzcG9uZGVudERhdGFTb3J0c1ByZXBbMF07XG4gICAgICAgIHZhciBzdGF0ZW1lbnROdW1BcnJheSA9IHJlc3BvbmRlbnREYXRhU29ydHNQcmVwWzFdO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZSZXNwb25kZW50U29ydHNGcm9tRGJTdG9yZWRcIiwgcmVzcG9uZGVudERhdGFTb3J0czMpO1xuICAgICAgICB2YXIgcWF2UmVzcG9uZGVudFNvcnRzRnJvbURiU3RvcmVkID0gXy5jbG9uZURlZXAocmVzcG9uZGVudERhdGFTb3J0czMpO1xuICAgICAgICB2YXIgc3ltbURhdGEgPSBfLmNsb25lRGVlcChyZXNwb25kZW50RGF0YVNvcnRzMyk7XG5cbiAgICAgICAgLy8gUUFWICM3ICAgcHJvamVjdCBzdGF0ZW1lbnRzXG4gICAgICAgIHZhciBzdGF0ZW1lbnREYXRhMSA9IGRhdGFbMV07XG4gICAgICAgIHZhciBxYXZDdXJyZW50U3RhdGVtZW50cyA9IEVYQ0VMLmdldFN0YXRlbWVudHMoc3RhdGVtZW50RGF0YTEpO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZDdXJyZW50U3RhdGVtZW50c1wiLCBxYXZDdXJyZW50U3RhdGVtZW50cyk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnROdW1iZXJUZXN0VmFsdWUgPSBxYXZDdXJyZW50U3RhdGVtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgLy8gLy9cbiAgICAgICAgLy8gLy8gU1lNTUVUUlkgVEVTVElOR1xuICAgICAgICAvLyAvL1xuICAgICAgICB2YXIgY2hlY2tGb3JOb25TeW1tZXRyeSA9IEVYQ0VMLnRlc3RTeW1tZXRyeU9mU29ydHMocWF2U29ydFRyaWFuZ2xlU2hhcGUsIHN5bW1EYXRhLCBzdGF0ZW1lbnROdW1BcnJheSwgc3RhdGVtZW50TnVtYmVyVGVzdFZhbHVlKTtcbiAgICAgICAgYXJlVGhlcmVFcnJvcnMgPSBjaGVja0Zvck5vblN5bW1ldHJ5WzBdO1xuICAgICAgICBpc051bWJlck9mU3RhdGVtZW50c0NvcnJlY3QgPSBjaGVja0Zvck5vblN5bW1ldHJ5WzFdO1xuXG5cbiAgICAgICAgLy8gRGlzcGxheSByZXNwb25kZW50cyBhbmQgc29ydHMgT1IgZXJyb3IgbWVzc2FnZXNcblxuICAgICAgICB2YXIgcmVzcG9uZGVudFNvcnRzID0gW107XG4gICAgICAgIGlmIChhcmVUaGVyZUVycm9ycy5sZW5ndGggPT09IDAgJiYgaXNOdW1iZXJPZlN0YXRlbWVudHNDb3JyZWN0ID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgZm9yICh2YXIgcXEgPSAwOyBxcSA8IHFhdkN1cnJlbnRTdGF0ZW1lbnRzLmxlbmd0aDsgcXErKykge1xuICAgICAgICAgICAgICAgIHZhciBzb3J0U3RhdGVtZW50ID0gcWF2Q3VycmVudFN0YXRlbWVudHNbcXFdO1xuICAgICAgICAgICAgICAgICQoXCIjZXhpc3RpbmdEYXRhYmFzZVN0YXRlbWVudExpc3RcIikuYXBwZW5kKFwiPGxpPlwiICsgc29ydFN0YXRlbWVudCArIFwiPC9saT5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciByciA9IDA7IHJyIDwgcWF2UmVzcG9uZGVudFNvcnRzRnJvbURiU3RvcmVkLmxlbmd0aDsgcnIrKykge1xuICAgICAgICAgICAgICAgIHZhciBzb3J0SXRlbSA9IHFhdlJlc3BvbmRlbnRTb3J0c0Zyb21EYlN0b3JlZFtycl07XG4gICAgICAgICAgICAgICAgdmFyIHNvcnRJdGVtMiA9IHNvcnRJdGVtLmpvaW4oKTtcbiAgICAgICAgICAgICAgICB2YXIgc29ydEl0ZW0zID0gc29ydEl0ZW0yLnJlcGxhY2UoLywvZywgXCIgXCIpLnJlcGxhY2UoLyAtL2csIFwiLVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc29ydEl0ZW0zLmNoYXJBdCgwKSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydEl0ZW0zID0gXCIgXCIgKyBzb3J0SXRlbTM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbmRlbnRTb3J0cy5wdXNoKChzb3J0SXRlbTMpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uZGVudCA9IHFhdlJlc3BvbmRlbnROYW1lc1tycl07XG4gICAgICAgICAgICAgICAgJChcIiNleGlzdGluZ0RhdGFiYXNlUmVzcG9uZGVudExpc3RcIikuYXBwZW5kKFwiPGxpPlwiICsgcmVzcG9uZGVudCArIFwiLFwiICsgc29ydEl0ZW0gKyBcIjwvbGk+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGlzcGxheSB0aGUgZG93bmxvYWQgYnV0dG9uIGZvciBQUU1ldGhvZCBleHBvcnQgLSB0b2RvIC0gY2hhbmdlIG5hbWluZyBmb3IgY2xhc3NcbiAgICAgICAgICAgICQoXCIuanNvbkRvd25sb2FkUFFcIikuc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJChcIiNnZW5lcmljRXJyb3JNb2RhbCAuZXJyb3JQYW5lbFwiKS5lbXB0eSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBhcmVUaGVyZUVycm9ycy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgICAgICQoXCIjZ2VuZXJpY0Vycm9yTW9kYWwgLmVycm9yUGFuZWxcIikuYXBwZW5kKFwiPHA+XCIgKyBxYXZSZXNwb25kZW50TmFtZXNbYXJlVGhlcmVFcnJvcnNbdF1bMF1dICsgXCIgXCIgKyBhcmVUaGVyZUVycm9yc1t0XVsxXSArIFwiPC9wPjxicj5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlck9mU3RhdGVtZW50c0NvcnJlY3QgPT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICQoXCIjZ2VuZXJpY0Vycm9yTW9kYWwgLmVycm9yUGFuZWxcIikuYXBwZW5kKFwiPGg2PlwiICsgZXJyb3JUZXh0MyArIFwiPC9oNj5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFZJRVcuc2hvd0dlbmVyaWNFcnJvck1vZGFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgUUFWLnNldFN0YXRlKFwicWF2UmVzcG9uZGVudFNvcnRzRnJvbURiU3RvcmVkXCIsIHJlc3BvbmRlbnRTb3J0cyk7XG4gICAgfVxuXG4gICAgRVhDRUwudGVzdFN5bW1ldHJ5T2ZTb3J0cyA9IGZ1bmN0aW9uIChxYXZTb3J0VHJpYW5nbGVTaGFwZSwgc3ltbURhdGEsIHN0YXRlbWVudE51bUFycmF5LCBzdGF0ZW1lbnROdW1iZXJUZXN0VmFsdWUpIHtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBlcnJvclRleHQxID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcImhhcyBtaXNzaW5nIHN0YXRlbWVudCBudW1iZXJzXCJdO1xuICAgICAgICB2YXIgZXJyb3JUZXh0MiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJoYXMgYW4gaW5jb3JyZWN0IFEtc29ydCB2YWx1ZVwiXTtcbiAgICAgICAgdmFyIHRlc3RTb3J0VHJpYW5nbGVTaGFwZUFycmF5ID0gXy5jbG9uZURlZXAocWF2U29ydFRyaWFuZ2xlU2hhcGUpO1xuICAgICAgICB2YXIgaXNOdW1iZXJPZlN0YXRlbWVudHNDb3JyZWN0LCBhcmVUaGVyZUVycm9ycyA9IFtdO1xuXG4gICAgICAgIC8vIFVzZSBEMy5qcyB0byBnZW5lcmF0ZSByYW5nZSBhcnJheSB0byB0ZXN0IGFnYWluc3RcbiAgICAgICAgdmFyIHJhbmdlVGVzdEFycmF5ID0gZDMucmFuZ2UoMSwgKHRlc3RTb3J0VHJpYW5nbGVTaGFwZUFycmF5Lmxlbmd0aCArIDEpKTtcblxuICAgICAgICAvLyB0ZXN0IGZvciBtaXNzaW5nIHZhbHVlcyAvIGNvbnNpc3RlbnQgbGVuZ3RoXG4gICAgICAgIHZhciB0ZXN0TWF4ID0gXy5tYXgocmFuZ2VUZXN0QXJyYXkpO1xuICAgICAgICB2YXIgdGVzdE1pbiA9IF8ubWluKHJhbmdlVGVzdEFycmF5KTtcbiAgICAgICAgdmFyIG1pbiwgbWF4LCB0ZXN0U3ltO1xuICAgICAgICBmb3IgKHZhciBrayA9IDA7IGtrIDwgc3ltbURhdGEubGVuZ3RoOyBraysrKSB7XG4gICAgICAgICAgICBtYXggPSBfLm1heChzdGF0ZW1lbnROdW1BcnJheVtra10pO1xuICAgICAgICAgICAgbWluID0gXy5taW4oc3RhdGVtZW50TnVtQXJyYXlba2tdKTtcbiAgICAgICAgICAgIGlmIChtYXggPiB0ZXN0TWF4IHx8IG1pbiA8IHRlc3RNaW4pIHtcbiAgICAgICAgICAgICAgICBhcmVUaGVyZUVycm9ycy5wdXNoKFtraywgZXJyb3JUZXh0Ml0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXN0U3ltID0gY2hlY2tRc29ydFZhbHVlTWF0Y2goc3RhdGVtZW50TnVtQXJyYXlba2tdLCByYW5nZVRlc3RBcnJheSk7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RTeW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZVRoZXJlRXJyb3JzLnB1c2goW2trLCBlcnJvclRleHQxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIG51bWJlciBvZiBzdGF0ZW1lbnRzIGluIHN0YXRlbWVudHMgdGFiIG1hdGNoZXMgbnVtYmVyIGNhbGN1bGF0ZWQgc3RhdGVtZW50c1xuICAgICAgICBpZiAoc3RhdGVtZW50TnVtYmVyVGVzdFZhbHVlICE9PSB0ZXN0U29ydFRyaWFuZ2xlU2hhcGVBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlzTnVtYmVyT2ZTdGF0ZW1lbnRzQ29ycmVjdCA9IFwiZmFsc2VcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzTnVtYmVyT2ZTdGF0ZW1lbnRzQ29ycmVjdCA9IFwidHJ1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhciByZXR1cm5lZFZhbHVlID0gW2FyZVRoZXJlRXJyb3JzLCBpc051bWJlck9mU3RhdGVtZW50c0NvcnJlY3RdO1xuICAgICAgICByZXR1cm4gW2FyZVRoZXJlRXJyb3JzLCBpc051bWJlck9mU3RhdGVtZW50c0NvcnJlY3RdO1xuICAgIH07XG5cblxuICAgIEVYQ0VMLmdldFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50RGF0YTEpIHtcbiAgICAgICAgdmFyIHFhdkN1cnJlbnRTdGF0ZW1lbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBzTGVuID0gc3RhdGVtZW50RGF0YTFbMF0ubGVuZ3RoOyBzIDwgc0xlbjsgcysrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcDEyID0gc3RhdGVtZW50RGF0YTFbMF1bc10uU3RhdGVtZW50cztcbiAgICAgICAgICAgIGlmICh0ZW1wMTIgPT09IFwiXCIgfHwgdGVtcDEyID09PSB1bmRlZmluZWQgfHwgdGVtcDEyID09PSBudWxsKSB7fSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxYXZDdXJyZW50U3RhdGVtZW50cy5wdXNoKHRlbXAxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHFhdkN1cnJlbnRTdGF0ZW1lbnRzO1xuICAgIH07XG5cbiAgICBFWENFTC5nZXRSZXNwb25kZW50U29ydHMgPSBmdW5jdGlvbiAoc29ydERhdGEpIHtcbiAgICAgICAgdmFyIHNvcnREYXRhVHJhbnNwb3NlZCA9IF8uemlwLmFwcGx5KF8sIHNvcnREYXRhKTtcbiAgICAgICAgdmFyIGRhdGEyID0gW107XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgc29ydERhdGFUcmFuc3Bvc2VkLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICB2YXIgc29ydGVkQXJyYXkxID0gXy5zb3J0Qnkoc29ydERhdGFUcmFuc3Bvc2VkW3BdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai5zdGF0ZW1lbnROdW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGEyLnB1c2goc29ydGVkQXJyYXkxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGVtZW50TnVtQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIHRlbXAyLCB0ZW1wMmE7XG4gICAgICAgIHZhciByZXNwb25kZW50RGF0YVNvcnRzMyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IGRhdGEyLmxlbmd0aDsgcSsrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcDExID0gZGF0YTJbcV07XG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5MyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRlbXBBcnJheTMzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHRlbXAxMS5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgIHRlbXAyID0gdGVtcDExW3JdLnNvcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB0ZW1wMmEgPSB0ZW1wMTFbcl0uc3RhdGVtZW50TnVtO1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheTMucHVzaCh0ZW1wMik7XG4gICAgICAgICAgICAgICAgdGVtcEFycmF5MzMucHVzaCh0ZW1wMmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uZGVudERhdGFTb3J0czMucHVzaCh0ZW1wQXJyYXkzKTtcbiAgICAgICAgICAgIHN0YXRlbWVudE51bUFycmF5LnB1c2godGVtcEFycmF5MzMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXR1cm5lZFZhbHVlID0gW3Jlc3BvbmRlbnREYXRhU29ydHMzLCBzdGF0ZW1lbnROdW1BcnJheV07XG4gICAgICAgIHJldHVybiBbcmVzcG9uZGVudERhdGFTb3J0czMsIHN0YXRlbWVudE51bUFycmF5XTtcbiAgICB9O1xuXG4gICAgRVhDRUwuZ2V0UmVzcG9uZGVudE5hbWVzID0gZnVuY3Rpb24gKG5hbWVzRGF0YSkge1xuICAgICAgICB2YXIgcWF2UmVzcG9uZGVudE5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIG0gPSAwLCBtTGVuID0gbmFtZXNEYXRhLmxlbmd0aDsgbSA8IG1MZW47IG0rKykge1xuICAgICAgICAgICAgdmFyIHRlbXAxID0gbmFtZXNEYXRhW21dLnN0YXRlbWVudE51bTtcbiAgICAgICAgICAgIGlmICh0ZW1wMSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHFhdlJlc3BvbmRlbnROYW1lcy5wdXNoKHRlbXAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxYXZSZXNwb25kZW50TmFtZXMgPSBVVElMLmNoZWNrVW5pcXVlTmFtZShxYXZSZXNwb25kZW50TmFtZXMpO1xuICAgICAgICByZXR1cm4gcWF2UmVzcG9uZGVudE5hbWVzO1xuICAgIH07XG5cbiAgICBFWENFTC5wcmVwSW5wdXREYXRhID0gZnVuY3Rpb24gKGlucHV0RGF0YTEsIHFhdk9yaWdpbmFsU29ydFNpemUpIHtcbiAgICAgICAgdmFyIHNvcnREYXRhID0gW107XG4gICAgICAgIHZhciBzb3J0TGVuZ3RoID0gMjkgKyBxYXZPcmlnaW5hbFNvcnRTaXplO1xuICAgICAgICB2YXIgY291bnRlciA9IChpbnB1dERhdGExWzI4XS5sZW5ndGgpIC0gMTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMjg7IGsgPCBzb3J0TGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBpbnB1dERhdGExW2tdWzBdO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgdmFyIHRlbXBBcnJheTEgPSBbXTtcbiAgICAgICAgICAgIHZhciBqID0gMTtcbiAgICAgICAgICAgIHZhciB0ZW1wT2JqMTtcblxuICAgICAgICAgICAgZm9yICh2YXIga3IgPSAwOyBrciA8IGNvdW50ZXI7IGtyKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGlucHV0RGF0YTFba11bal07XG5cbiAgICAgICAgICAgICAgICAvLyBjYXRjaCB0aGUgcmVzcG9uZGVudCBuYW1lcyBmaXJzdFxuICAgICAgICAgICAgICAgIGlmIChrID09PSAyOCAmJiB2YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wT2JqMSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0ZW1wT2JqMS5zb3J0VmFsdWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBPYmoxLnN0YXRlbWVudE51bSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxLnB1c2godGVtcE9iajEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcE9iajEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBPYmoxLnNvcnRWYWx1ZSA9ICtrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wT2JqMS5zdGF0ZW1lbnROdW0gPSArdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxLnB1c2godGVtcE9iajEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGogPSBqICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvcnREYXRhLnB1c2godGVtcEFycmF5MSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvcnREYXRhO1xuICAgIH07XG5cbiAgICBFWENFTC5jcmVhdGVNdWx0aXBsaWVyQXJyYXlBbmRUcmlhbmdsZVNoYXBlID0gZnVuY3Rpb24gKGlucHV0RGF0YTEpIHtcbiAgICAgICAgY29uc29sZS5sb2coaW5wdXREYXRhMSk7XG4gICAgICAgIHZhciBxYXZTb3J0VHJpYW5nbGVTaGFwZSA9IFtdO1xuICAgICAgICB2YXIgbXVsdGlwbGllckFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSA0OyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRlc3RWYWx1ZSA9ICtpbnB1dERhdGExW2ldWzFdO1xuICAgICAgICAgICAgaWYgKHRlc3RWYWx1ZSA8IDEgfHwgaXNOYU4odGVzdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG11bHRpcGxpZXJBcnJheS5wdXNoKDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9ICtpbnB1dERhdGExW2ldWzFdO1xuICAgICAgICAgICAgICAgIG11bHRpcGxpZXJBcnJheS5wdXNoKG11bHRpcGxpZXIpO1xuICAgICAgICAgICAgICAgIHZhciBzb3J0VmFsdWUgPSAraW5wdXREYXRhMVtpXVswXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IG11bHRpcGxpZXI7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcWF2U29ydFRyaWFuZ2xlU2hhcGUucHVzaChzb3J0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW211bHRpcGxpZXJBcnJheSwgcWF2U29ydFRyaWFuZ2xlU2hhcGVdO1xuICAgIH07XG5cblxuICAgIC8vXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogIG1vZGVsXG4gICAgLy8gKioqKiogRm9ybWF0IFR5cGUgMiBFeGNlbCBmaWxlIChVbmZvcmNlZCkgZm9yIERpc3BsYXkgKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVbmZvcmNlZFVwbG9hZEZvckRpc3BsYXkoZGF0YSkge1xuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIGVycm9yVGV4dDEgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiaGFzIG1pc3NpbmcgUS1zb3J0IHZhbHVlc1wiXTtcbiAgICAgICAgdmFyIGVycm9yVGV4dDIgPSByZXNvdXJjZXNbbGFuZ3VhZ2VdLnRyYW5zbGF0aW9uW1wiaGFzIGFuIGluY29ycmVjdCBRLXNvcnQgdmFsdWVcIl07XG4gICAgICAgIHZhciBub25TeW1Tb3J0c0RpdkhlYWRlciA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJOb24tU3ltbWV0cmljIFEtc29ydHNcIl07XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICB2YXIgbXVsdGlwbGllckFycmF5ID0gW107XG5cbiAgICAgICAgLy8gUUFWICMxXG4gICAgICAgIHZhciBxYXZQcm9qZWN0TmFtZTEgPSBkYXRhWzBdWzBdWzFdO1xuICAgICAgICB2YXIgcWF2UHJvamVjdE5hbWUgPSBxYXZQcm9qZWN0TmFtZTEudG9TdHJpbmcoKS5yZXBsYWNlKC8sL2csICcnKTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwicWF2UHJvamVjdE5hbWVcIiwgcWF2UHJvamVjdE5hbWUpO1xuXG4gICAgICAgIC8vIFFBViAjMiAtIGNhbGN1bGF0ZSBzb3J0IGRlc2lnbiBhcnJheVxuICAgICAgICB2YXIgY2FsY1NvcnRUcmlhbmdsZVQyID0gRVhDRUwuY2FsY1NvcnRUcmlhbmdsZVNoYXBlVDIoZGF0YVswXVswXVszXSk7XG4gICAgICAgIHZhciBjb3B5VHJpYW5nbGVTaGFwZSA9IGNhbGNTb3J0VHJpYW5nbGVUMlswXTtcbiAgICAgICAgdmFyIHRlc3RTb3J0VHJpYW5nbGVTaGFwZUFycmF5ID0gY2FsY1NvcnRUcmlhbmdsZVQyWzFdO1xuICAgICAgICB2YXIgcWF2U29ydFRyaWFuZ2xlU2hhcGUgPSBjYWxjU29ydFRyaWFuZ2xlVDJbMl07XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInFhdlNvcnRUcmlhbmdsZVNoYXBlXCIsIHFhdlNvcnRUcmlhbmdsZVNoYXBlKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgbXVsdGlwbGllckFycmF5XG4gICAgICAgIG11bHRpcGxpZXJBcnJheSA9IEVYQ0VMLmNhbGNNdWx0aXBsaWVyQXJyYXlUMihjb3B5VHJpYW5nbGVTaGFwZSk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcIm11bHRpcGxpZXJBcnJheVwiLCBtdWx0aXBsaWVyQXJyYXkpO1xuXG4gICAgICAgIC8vIFFBViAjMyAtIHNldCBRLXNvcnQgc2l6ZVxuICAgICAgICB2YXIgcWF2T3JpZ2luYWxTb3J0U2l6ZSA9IHFhdlNvcnRUcmlhbmdsZVNoYXBlLmxlbmd0aDsgLy8gbnVtYmVyIG9mIHN0YXRlbWVudHNcbiAgICAgICAgUUFWLnNldFN0YXRlKFwicWF2T3JpZ2luYWxTb3J0U2l6ZVwiLCBxYXZPcmlnaW5hbFNvcnRTaXplKTtcbiAgICAgICAgLy8gdG9kbyAtIGZpeCBxYXZPcmlnaW5hbFNvcnRTaXplIGFuZCBxYXZUb3RhbFN0YXRlbWVudHMgYXJlIHNhbWUgLSBzeW1tZXRyeSBjaGVjayBmdW5jdGlvbnNcbiAgICAgICAgUUFWLnNldFN0YXRlKFwicWF2VG90YWxTdGF0ZW1lbnRzXCIsIHFhdk9yaWdpbmFsU29ydFNpemUpO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJvcmlnaW5hbFNvcnRTaXplXCIsIHFhdk9yaWdpbmFsU29ydFNpemUpO1xuXG4gICAgICAgIC8vIFFBViAjNCAtIGdyYWIgcmVzcG9uZGVudCBuYW1lcyBhbmQgc29ydHNcbiAgICAgICAgdmFyIHNvcnRzRGF0YVQyID0gZGF0YVswXVswXTtcbiAgICAgICAgdmFyIGNhbGNTb3J0cyA9IEVYQ0VMLmdyYWJSZXNwb25kZW50TmFtZXNBbmRTb3J0cyhzb3J0c0RhdGFUMik7XG4gICAgICAgIHZhciBxYXZSZXNwb25kZW50TmFtZXMgPSBjYWxjU29ydHNbMF07XG4gICAgICAgIHZhciByZXNwb25kZW50U29ydHNBcnJheSA9IGNhbGNTb3J0c1sxXTtcbiAgICAgICAgdmFyIHN5bW1ldHJ5Q2hlY2tBcnJheSA9IGNhbGNTb3J0c1syXTtcbiAgICAgICAgLy8gdG9kbyAtIGZpeCBkb3VibGUgY292ZXJhZ2Ugb2YgcmVzIG5hbWVzXG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInFhdlJlc3BvbmRlbnROYW1lc1wiLCBxYXZSZXNwb25kZW50TmFtZXMpO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJyZXNwb25kZW50TmFtZXNcIiwgcWF2UmVzcG9uZGVudE5hbWVzKTtcblxuXG4gICAgICAgIC8vIFFBViAjNVxuICAgICAgICB2YXIgcWF2VG90YWxOdW1iZXJTb3J0cyA9IHFhdlJlc3BvbmRlbnROYW1lcy5sZW5ndGg7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInFhdlRvdGFsTnVtYmVyU29ydHNcIiwgcWF2VG90YWxOdW1iZXJTb3J0cyk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInRvdGFsTnVtYmVyU29ydHNcIiwgcWF2VG90YWxOdW1iZXJTb3J0cyk7XG5cblxuICAgICAgICAvLyBRQVYgIzYgLSBzZXQgcmVzcG9uZGVudCBzb3J0c1xuICAgICAgICB2YXIgcWF2UmVzcG9uZGVudFNvcnRzRnJvbURiU3RvcmVkID0gcmVzcG9uZGVudFNvcnRzQXJyYXk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInFhdlJlc3BvbmRlbnRTb3J0c0Zyb21EYlN0b3JlZFwiLCBxYXZSZXNwb25kZW50U29ydHNGcm9tRGJTdG9yZWQpO1xuXG5cbiAgICAgICAgLy8gUUFWICM3XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzRGF0YVQyID0gZGF0YVsxXVswXTtcbiAgICAgICAgdmFyIHFhdkN1cnJlbnRTdGF0ZW1lbnRzID0gRVhDRUwuZ3JhYlByb2plY3RTdGF0ZW1lbnRzKHN0YXRlbWVudHNEYXRhVDIpO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZDdXJyZW50U3RhdGVtZW50c1wiLCBxYXZDdXJyZW50U3RhdGVtZW50cyk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRVJST1IgVEVTVElOR1xuICAgICAgICAvL1xuICAgICAgICB2YXIgY2hlY2tGb3JFcnJvcnMgPSBFWENFTC5jaGVja0ZvckVycm9ycyh0ZXN0U29ydFRyaWFuZ2xlU2hhcGVBcnJheSwgc3ltbWV0cnlDaGVja0FycmF5KTtcbiAgICAgICAgdmFyIGFyZVRoZXJlRXJyb3JzID0gY2hlY2tGb3JFcnJvcnNbMF07XG4gICAgICAgIHZhciBub25TeW1tZXRyaWNTb3J0cyA9IGNoZWNrRm9yRXJyb3JzWzFdO1xuXG5cbiAgICAgICAgLy8gRGlzcGxheSByZXNwb25kZW50cyBhbmQgc29ydHMgT1IgZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgdmFyIHJlc3BvbmRlbnRTb3J0cyA9IFtdO1xuICAgICAgICBpZiAoYXJlVGhlcmVFcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IHFhdkN1cnJlbnRTdGF0ZW1lbnRzLmxlbmd0aDsgcSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvcnRTdGF0ZW1lbnQgPSBxYXZDdXJyZW50U3RhdGVtZW50c1txXTtcbiAgICAgICAgICAgICAgICAkKFwiI2V4aXN0aW5nRGF0YWJhc2VTdGF0ZW1lbnRMaXN0XCIpLmFwcGVuZChcIjxsaT5cIiArIHNvcnRTdGF0ZW1lbnQgKyBcIjwvbGk+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgcnIgPSAwOyByciA8IHFhdlJlc3BvbmRlbnRTb3J0c0Zyb21EYlN0b3JlZC5sZW5ndGg7IHJyKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc29ydEl0ZW0gPSBxYXZSZXNwb25kZW50U29ydHNGcm9tRGJTdG9yZWRbcnJdO1xuICAgICAgICAgICAgICAgIHZhciBzb3J0SXRlbTMgPSBzb3J0SXRlbS5yZXBsYWNlKC8sL2csIFwiIFwiKS5yZXBsYWNlKC8gLS9nLCBcIi1cIik7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRJdGVtMy5jaGFyQXQoMCkgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRJdGVtMyA9IFwiIFwiICsgc29ydEl0ZW0zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25kZW50U29ydHMucHVzaCgoc29ydEl0ZW0zKSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbmRlbnQgPSBxYXZSZXNwb25kZW50TmFtZXNbcnJdO1xuICAgICAgICAgICAgICAgICQoXCIjZXhpc3RpbmdEYXRhYmFzZVJlc3BvbmRlbnRMaXN0XCIpLmFwcGVuZChcIjxsaT5cIiArIHJlc3BvbmRlbnQgKyBcIixcIiArIHNvcnRJdGVtICsgXCI8L2xpPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub25TeW1tZXRyaWNTb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgJChcIiNub25TeW1tZXRyaWNTb3J0c0RpdlwiKS5hcHBlbmQoXCI8aDQ+XCIgKyBub25TeW1Tb3J0c0RpdkhlYWRlciArIFwiPC9oND5cIik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCBub25TeW1tZXRyaWNTb3J0cy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgICAgICAgICAgICAkKFwiI25vblN5bW1ldHJpY1NvcnRzRGl2XCIpLmFwcGVuZChcIjxwPlwiICsgcWF2UmVzcG9uZGVudE5hbWVzW25vblN5bW1ldHJpY1NvcnRzW3ddXSArIFwiLCA8L3A+XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNob3cgdGhlIGRvd25sb2FkIGJ1dHRvbiBpbiBhbmFseXNpcyBkYXRhIGRpdlxuICAgICAgICAgICAgJChcIi5qc29uRG93bmxvYWRQUVwiKS5zaG93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKFwiI2dlbmVyaWNFcnJvck1vZGFsIC5lcnJvclBhbmVsXCIpLmVtcHR5KCk7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGFyZVRoZXJlRXJyb3JzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgJChcIiNnZW5lcmljRXJyb3JNb2RhbCAuZXJyb3JQYW5lbFwiKS5hcHBlbmQoXCI8cD5cIiArIHFhdlJlc3BvbmRlbnROYW1lc1thcmVUaGVyZUVycm9yc1t0XVswXV0gKyBcIiBcIiArIGFyZVRoZXJlRXJyb3JzW3RdWzFdICsgXCI8L3A+PGJyPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZJRVcuc2hvd0dlbmVyaWNFcnJvck1vZGFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgUUFWLnNldFN0YXRlKFwicWF2UmVzcG9uZGVudFNvcnRzRnJvbURiU3RvcmVkXCIsIHJlc3BvbmRlbnRTb3J0cyk7XG4gICAgfVxuXG5cblxuICAgIEVYQ0VMLmNoZWNrRm9yRXJyb3JzID0gZnVuY3Rpb24gKHRlc3RTb3J0VHJpYW5nbGVTaGFwZUFycmF5LCBzeW1tZXRyeUNoZWNrQXJyYXkpIHtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBlcnJvclRleHQxID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbltcImhhcyBtaXNzaW5nIHN0YXRlbWVudCBudW1iZXJzXCJdO1xuICAgICAgICB2YXIgZXJyb3JUZXh0MiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJoYXMgYW4gaW5jb3JyZWN0IHN0YXRlbWVudCBudW1iZXJcIl07XG4gICAgICAgIHZhciBhcmVUaGVyZUVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgbm9uU3ltbWV0cmljU29ydHMgPSBbXTtcblxuICAgICAgICAvLyB0ZXN0IGZvciBtaXNzaW5nIHZhbHVlcyAvIGNvbnNpc3RlbnQgbGVuZ3RoXG4gICAgICAgIHZhciB0ZXN0TWF4ID0gXy5tYXgodGVzdFNvcnRUcmlhbmdsZVNoYXBlQXJyYXkpO1xuICAgICAgICB2YXIgdGVzdE1pbiA9IF8ubWluKHRlc3RTb3J0VHJpYW5nbGVTaGFwZUFycmF5KTtcbiAgICAgICAgdmFyIHRlc3RMZW4gPSB0ZXN0U29ydFRyaWFuZ2xlU2hhcGVBcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciBtaW4sIG1heCwgdGVzdFN5bTtcbiAgICAgICAgZm9yICh2YXIgayA9IDAsIGtMZW4gPSBzeW1tZXRyeUNoZWNrQXJyYXkubGVuZ3RoOyBrIDwga0xlbjsgaysrKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzeW1tZXRyeUNoZWNrQXJyYXlba10ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChzeW1tZXRyeUNoZWNrQXJyYXlba10ubGVuZ3RoICE9PSB0ZXN0TGVuKSB7XG4gICAgICAgICAgICAgICAgYXJlVGhlcmVFcnJvcnMucHVzaChbaywgZXJyb3JUZXh0MV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF4ID0gXy5tYXgoc3ltbWV0cnlDaGVja0FycmF5W2tdKTtcbiAgICAgICAgICAgIG1pbiA9IF8ubWluKHN5bW1ldHJ5Q2hlY2tBcnJheVtrXSk7XG4gICAgICAgICAgICBpZiAobWF4ID4gdGVzdE1heCB8fCBtaW4gPCB0ZXN0TWluKSB7XG4gICAgICAgICAgICAgICAgYXJlVGhlcmVFcnJvcnMucHVzaChbaywgZXJyb3JUZXh0Ml0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVzdFN5bSA9IGNoZWNrUXNvcnRWYWx1ZU1hdGNoKHN5bW1ldHJ5Q2hlY2tBcnJheVtrXSwgdGVzdFNvcnRUcmlhbmdsZVNoYXBlQXJyYXkpO1xuICAgICAgICAgICAgaWYgKHRlc3RTeW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9uU3ltbWV0cmljU29ydHMucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FyZVRoZXJlRXJyb3JzLCBub25TeW1tZXRyaWNTb3J0c107XG4gICAgfTtcblxuICAgIEVYQ0VMLmdyYWJQcm9qZWN0U3RhdGVtZW50cyA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRzRGF0YVQyKSB7XG4gICAgICAgIHZhciBxYXZDdXJyZW50U3RhdGVtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBzID0gMCwgc0xlbiA9IHN0YXRlbWVudHNEYXRhVDIubGVuZ3RoOyBzIDwgc0xlbjsgcysrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcDEyID0gc3RhdGVtZW50c0RhdGFUMltzXS5TdGF0ZW1lbnRzO1xuICAgICAgICAgICAgaWYgKHRlbXAxMiA9PT0gXCJcIiB8fCB0ZW1wMTIgPT09IHVuZGVmaW5lZCB8fCB0ZW1wMTIgPT09IG51bGwpIHt9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHFhdkN1cnJlbnRTdGF0ZW1lbnRzLnB1c2godGVtcDEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcWF2Q3VycmVudFN0YXRlbWVudHM7XG4gICAgfTtcblxuICAgIEVYQ0VMLmdyYWJSZXNwb25kZW50TmFtZXNBbmRTb3J0cyA9IGZ1bmN0aW9uIChzb3J0c0RhdGFUMikge1xuICAgICAgICB2YXIgc3ltbWV0cnlDaGVja0FycmF5ID0gW107XG4gICAgICAgIHZhciBxYXZSZXNwb25kZW50TmFtZXMgPSBbXTtcbiAgICAgICAgdmFyIHNvcnRzRm9yRGlzcGxheSA9IFtdO1xuICAgICAgICB2YXIgcmVzcG9uZGVudFNvcnRzQXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbSA9IDY7IG0gPCBzb3J0c0RhdGFUMi5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgdmFyIHRlbXAxID0gc29ydHNEYXRhVDJbbV0udG9TdHJpbmcoKS5yZXBsYWNlKC8sLC9nLCAnJyk7XG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IGZyb20gcmVhZGluZyBlbXB0eSBjZWxscyBhcyBkYXRhXG4gICAgICAgICAgICBpZiAodGVtcDEubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udmVydCBmcm9tIGFycmF5IG9mIHN0cmluZ3MgdG8gYXJyYXkgb2YgbnVtYmVyc1xuICAgICAgICAgICAgc29ydHNGb3JEaXNwbGF5LnB1c2godGVtcDEpO1xuICAgICAgICAgICAgdGVtcDEgPSByZW1vdmVUcmFpbGluZ0NvbW1hRnJvbVRleHQodGVtcDEpO1xuICAgICAgICAgICAgdmFyIHRlbXAzID0gdGVtcDEuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciB0ZW1wNCA9IHRlbXAzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgdGVtcDUgPSB0ZW1wMy50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gY2hlY2sgdG8gY29uZmlybSBzb3J0IHZhbHVlIGlzIG51bWVyaWNcbiAgICAgICAgICAgIGlmICh0ZW1wNS5tYXRjaCgvW14sLVxcZF0vKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvclBhbmVsID0gJChcIiNnZW5lcmljRXJyb3JNb2RhbCAuZXJyb3JQYW5lbFwiKTtcbiAgICAgICAgICAgICAgICBlcnJvclBhbmVsLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgZXJyb3JQYW5lbC5hcHBlbmQoXCI8cD5UaGUgUS1zb3J0IGZvciByZXNwb25kZW50IFwiICsgdGVtcDQgKyBcIiBjb250YWlucyBub24tbnVtZXJpYyBkYXRhPC9wPlwiKTtcbiAgICAgICAgICAgICAgICBWSUVXLnNob3dHZW5lcmljRXJyb3JNb2RhbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFhdlJlc3BvbmRlbnROYW1lcy5wdXNoKHRlbXA0KTtcbiAgICAgICAgICAgIHJlc3BvbmRlbnRTb3J0c0FycmF5LnB1c2godGVtcDUpO1xuICAgICAgICAgICAgc3ltbWV0cnlDaGVja0FycmF5LnB1c2godGVtcDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcWF2UmVzcG9uZGVudE5hbWVzLCByZXNwb25kZW50U29ydHNBcnJheSwgc3ltbWV0cnlDaGVja0FycmF5XTtcbiAgICB9O1xuXG4gICAgRVhDRUwuY2FsY011bHRpcGxpZXJBcnJheVQyID0gZnVuY3Rpb24gKGNvcHlUcmlhbmdsZVNoYXBlKSB7XG4gICAgICAgIHZhciBtdWx0aXBsaWVyQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gY29weVRyaWFuZ2xlU2hhcGUubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29weVRyaWFuZ2xlU2hhcGVbaV0gIT09IHByZXYpIHtcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyQXJyYXkucHVzaCgxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbXVsdGlwbGllckFycmF5W211bHRpcGxpZXJBcnJheS5sZW5ndGggLSAxXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IGNvcHlUcmlhbmdsZVNoYXBlW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZCB0aGUgbXVsdGlwbGllckFycmF5XG4gICAgICAgIHZhciBsZWFkVmFsdWUgPSBjb3B5VHJpYW5nbGVTaGFwZVswXTtcbiAgICAgICAgdmFyIG1pbkxlYWRWYWx1ZSA9IC02O1xuICAgICAgICB2YXIgcGFkZGluZyA9IE1hdGguYWJzKG1pbkxlYWRWYWx1ZSAtIGxlYWRWYWx1ZSk7XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcGFkZGluZzsgcCsrKSB7XG4gICAgICAgICAgICBtdWx0aXBsaWVyQXJyYXkudW5zaGlmdCgwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDIwOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChtdWx0aXBsaWVyQXJyYXkubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyQXJyYXkucHVzaCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXVsdGlwbGllckFycmF5O1xuICAgIH07XG5cblxuICAgIEVYQ0VMLmNhbGNTb3J0VHJpYW5nbGVTaGFwZVQyID0gZnVuY3Rpb24gKHFhdlNvcnRUcmlhbmdsZVNoYXBlMSkge1xuICAgICAgICB2YXIgcWF2U29ydFRyaWFuZ2xlU2hhcGUyID0gcWF2U29ydFRyaWFuZ2xlU2hhcGUxLnJlcGxhY2UoLywsL2csICcnKTtcbiAgICAgICAgcWF2U29ydFRyaWFuZ2xlU2hhcGUyID0gcmVtb3ZlVHJhaWxpbmdDb21tYUZyb21UZXh0KHFhdlNvcnRUcmlhbmdsZVNoYXBlMik7XG4gICAgICAgIHZhciBxYXZTb3J0VHJpYW5nbGVTaGFwZTMgPSBxYXZTb3J0VHJpYW5nbGVTaGFwZTIucmVwbGFjZSgvU29ydCBQYXR0ZXJuLC8sICcnKTtcbiAgICAgICAgdmFyIHRlbXBUcmlhbmdsZTIgPSBxYXZTb3J0VHJpYW5nbGVTaGFwZTMuc3BsaXQoXCIsXCIpO1xuICAgICAgICBmb3IgKHZhciBhIGluIHRlbXBUcmlhbmdsZTIpIHtcbiAgICAgICAgICAgIHRlbXBUcmlhbmdsZTJbYV0gPSBwYXJzZUludCh0ZW1wVHJpYW5nbGUyW2FdLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvcHlUcmlhbmdsZVNoYXBlID0gXy5jbG9uZURlZXAodGVtcFRyaWFuZ2xlMik7XG4gICAgICAgIHZhciB0ZXN0U29ydFRyaWFuZ2xlU2hhcGVBcnJheSA9IF8uY2xvbmVEZWVwKHRlbXBUcmlhbmdsZTIpO1xuICAgICAgICB2YXIgcWF2U29ydFRyaWFuZ2xlU2hhcGUgPSBfLmNsb25lRGVlcCh0ZW1wVHJpYW5nbGUyKTtcbiAgICAgICAgcmV0dXJuIFtjb3B5VHJpYW5nbGVTaGFwZSwgdGVzdFNvcnRUcmlhbmdsZVNoYXBlQXJyYXksIHFhdlNvcnRUcmlhbmdsZVNoYXBlXTtcbiAgICB9O1xuXG5cblxuXG4gICAgLy8gSEVMUEVSIEZVTkNUSU9OU1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdDb21tYUZyb21UZXh0KHN0cmluZykge1xuICAgICAgICB2YXIgbGFzdENoYXIgPSBzdHJpbmcuc2xpY2UoLTEpO1xuICAgICAgICBpZiAobGFzdENoYXIgPT0gJywnKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLy8gc3RyaXBzIGV2ZXJ5dGhpbmcgYnV0IGxldHRlcnMgYW5kIG51bWJlcnMgYW5kIFwiLlwiIFwiLVwiXG4gICAgZnVuY3Rpb24gc2FuaXRpemVTb3J0VmFsdWVzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXmEtekEtWjAtOS4tXS9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrUXNvcnRWYWx1ZU1hdGNoKGlucHV0QXJyYXksIHRyaWFuZ2xlU2hhcGVBcnJheSkge1xuICAgICAgICB2YXIgdGVzdFZhciA9IF8uY2xvbmVEZWVwKHRyaWFuZ2xlU2hhcGVBcnJheSk7XG4gICAgICAgIHZhciBhID0gaW5wdXRBcnJheS5zb3J0KCkuam9pbignLCcpO1xuICAgICAgICB2YXIgYiA9IHRlc3RWYXIuc29ydCgpLmpvaW4oJywnKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoYSkpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShiKSk7XG4gICAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvL1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICBtb2RlbFxuICAgIC8vICoqKioqIEZvcm1hdCBUeXBlIDMgS2VuLVEgT3V0cHV0IEZpbGUgZm9yIERpc3BsYXkgKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgZnVuY3Rpb24gZm9ybWF0S2VucVVwbG9hZEZvckRpc3BsYXkoZGF0YSkge1xuICAgICAgICAvLyBRQVYgIzFcbiAgICAgICAgdmFyIHFhdlByb2plY3ROYW1lID0gZGF0YVswXVswXVswXVtcIlwiXTtcblxuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZQcm9qZWN0TmFtZVwiLCBxYXZQcm9qZWN0TmFtZSk7XG5cbiAgICAgICAgLy8gUUFWICMyIC0gZ2V0IHNvcnQgdHJpYW5nbGUgc2hhcGVcbiAgICAgICAgdmFyIGdyYWJTb3J0VHJpYW5nbGVTaGFwZVQzID0gRVhDRUwuZ3JhYlNvcnRUcmlhbmdsZVNoYXBlVDMoZGF0YVswXVswXVs0XVtcIlwiXSk7XG4gICAgICAgIHZhciBxYXZTb3J0VHJpYW5nbGVTaGFwZSA9IGdyYWJTb3J0VHJpYW5nbGVTaGFwZVQzWzBdO1xuICAgICAgICB2YXIgY29weVRyaWFuZ2xlU2hhcGUgPSBncmFiU29ydFRyaWFuZ2xlU2hhcGVUM1sxXTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwicWF2U29ydFRyaWFuZ2xlU2hhcGVcIiwgcWF2U29ydFRyaWFuZ2xlU2hhcGUpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBtdWx0aXBsaWVyQXJyYXlcbiAgICAgICAgdmFyIG11bHRpcGxpZXJBcnJheSA9IEVYQ0VMLmNhbGNNdWx0aXBsaWVyQXJyYXlUMihjb3B5VHJpYW5nbGVTaGFwZSk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcIm11bHRpcGxpZXJBcnJheVwiLCBtdWx0aXBsaWVyQXJyYXkpO1xuXG4gICAgICAgIC8vIFFBViAjM1xuICAgICAgICB2YXIgcWF2T3JpZ2luYWxTb3J0U2l6ZSA9IHFhdlNvcnRUcmlhbmdsZVNoYXBlLmxlbmd0aDsgLy8gbnVtYmVyIG9mIHN0YXRlbWVudHNcbiAgICAgICAgUUFWLnNldFN0YXRlKFwicWF2T3JpZ2luYWxTb3J0U2l6ZVwiLCBxYXZPcmlnaW5hbFNvcnRTaXplKTtcbiAgICAgICAgLy8gdG9kbyAtIGZpeCBxYXZPcmlnaW5hbFNvcnRTaXplIGFuZCBxYXZUb3RhbFN0YXRlbWVudHMgYXJlIHNhbWUgLSBzeW1tZXRyeSBjaGVjayBmdW5jdGlvbnNcbiAgICAgICAgUUFWLnNldFN0YXRlKFwicWF2VG90YWxTdGF0ZW1lbnRzXCIsIHFhdk9yaWdpbmFsU29ydFNpemUpO1xuICAgICAgICBRQVYub3JpZ2luYWxTb3J0U2l6ZSA9IHFhdk9yaWdpbmFsU29ydFNpemU7XG5cbiAgICAgICAgLy8gUUFWICM0IC0gcHVsbCByZXNwb25kZW50IG5hbWVzIGZyb20gZGF0YVxuICAgICAgICB2YXIgcWF2UmVzcG9uZGVudE5hbWVzID0gRVhDRUwuZ3JhYlJlc3BvbmRlbnROYW1lc1QzKGRhdGFbMl0pO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZSZXNwb25kZW50TmFtZXNcIiwgcWF2UmVzcG9uZGVudE5hbWVzKTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwicmVzcG9uZGVudE5hbWVzXCIsIHFhdlJlc3BvbmRlbnROYW1lcyk7XG5cbiAgICAgICAgLy8gUUFWICM1IC0gc2V0IHRvdGFsIG51bWJlciBvZiBzb3J0c1xuICAgICAgICB2YXIgcWF2VG90YWxOdW1iZXJTb3J0cyA9IHFhdlJlc3BvbmRlbnROYW1lcy5sZW5ndGg7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInFhdlRvdGFsTnVtYmVyU29ydHNcIiwgcWF2VG90YWxOdW1iZXJTb3J0cyk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInRvdGFsTnVtYmVyU29ydHNcIiwgcWF2VG90YWxOdW1iZXJTb3J0cyk7XG5cbiAgICAgICAgLy8gUUFWICM2IC0gZ2V0IHJlc3BvbmRlbnQgc29ydHMgXG4gICAgICAgIHZhciBxYXZSZXNwb25kZW50U29ydHNGcm9tRGJTdG9yZWQgPSBFWENFTC5ncmFiU29ydHNUMyhkYXRhWzJdLCBxYXZPcmlnaW5hbFNvcnRTaXplKTtcblxuICAgICAgICAvLyBRQVYgIzcgLSBnZXQgc3RhdGVtZW50c1xuICAgICAgICB2YXIgcWF2Q3VycmVudFN0YXRlbWVudHMgPSBFWENFTC5ncmFiU3RhdGVtZW50c1QzKGRhdGFbMV1bMF0pO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJxYXZDdXJyZW50U3RhdGVtZW50c1wiLCBxYXZDdXJyZW50U3RhdGVtZW50cyk7XG5cbiAgICAgICAgLy8gU1lNTUVUUlkgVEVTVElORyAgLSAgVE9ETyAtIEFERCBOb24tU3ltbWV0cmljIG5vdGlmaWNhdGlvblxuICAgICAgICB2YXIgc29ydHNUZXN0aW5nQXJyYXkgPSBfLmNsb25lRGVlcChxYXZSZXNwb25kZW50U29ydHNGcm9tRGJTdG9yZWQpO1xuICAgICAgICB2YXIgc2hvdWxkRGlzcGxheVJlc3VsdHMgPSBbXTtcblxuICAgICAgICAvLyBEaXNwbGF5IHJlc3BvbmRlbnRzIGFuZCBzb3J0c1xuICAgICAgICB2YXIgcmVzcG9uZGVudFNvcnRzID0gW107XG4gICAgICAgIGlmIChzaG91bGREaXNwbGF5UmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgcWF2Q3VycmVudFN0YXRlbWVudHMubGVuZ3RoOyBxKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc29ydFN0YXRlbWVudCA9IHFhdkN1cnJlbnRTdGF0ZW1lbnRzW3FdO1xuICAgICAgICAgICAgICAgICQoXCIjZXhpc3RpbmdEYXRhYmFzZVN0YXRlbWVudExpc3RcIikuYXBwZW5kKFwiPGxpPlwiICsgc29ydFN0YXRlbWVudCArIFwiPC9saT5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHFhdlJlc3BvbmRlbnRTb3J0c0Zyb21EYlN0b3JlZC5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgIHZhciBzb3J0SXRlbSA9IHFhdlJlc3BvbmRlbnRTb3J0c0Zyb21EYlN0b3JlZFtyXTtcbiAgICAgICAgICAgICAgICB2YXIgc29ydEl0ZW0yID0gc29ydEl0ZW0uam9pbigpO1xuICAgICAgICAgICAgICAgIHZhciBzb3J0SXRlbTMgPSBzb3J0SXRlbTIucmVwbGFjZSgvLC9nLCBcIiBcIikucmVwbGFjZSgvIC0vZywgXCItXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzb3J0SXRlbTMuY2hhckF0KDApICE9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICBzb3J0SXRlbTMgPSBcIiBcIiArIHNvcnRJdGVtMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uZGVudFNvcnRzLnB1c2goKHNvcnRJdGVtMykpO1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25kZW50ID0gcWF2UmVzcG9uZGVudE5hbWVzW3JdO1xuICAgICAgICAgICAgICAgICQoXCIjZXhpc3RpbmdEYXRhYmFzZVJlc3BvbmRlbnRMaXN0XCIpLmFwcGVuZChcIjxsaT5cIiArIHJlc3BvbmRlbnQgKyBcIixcIiArIHNvcnRJdGVtICsgXCI8L2xpPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRpc3BsYXkgUFFNZXRob2QgZXhwb3J0IGJ1dHRvblxuICAgICAgICAgICAgJChcIi5qc29uRG93bmxvYWRQUVwiKS5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgUUFWLnNldFN0YXRlKFwicWF2UmVzcG9uZGVudFNvcnRzRnJvbURiU3RvcmVkXCIsIHJlc3BvbmRlbnRTb3J0cyk7XG4gICAgfVxuXG4gICAgRVhDRUwuZ3JhYlN0YXRlbWVudHNUMyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBxYXZDdXJyZW50U3RhdGVtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwcCA9IDE7IHBwIDwgZGF0YS5sZW5ndGg7IHBwKyspIHtcbiAgICAgICAgICAgIHZhciB0ZW1wMTEgPSBkYXRhW3BwXVtcIlwiXTtcbiAgICAgICAgICAgIGlmICh0ZW1wMTEgPT09IFwiXCIgfHwgdGVtcDExID09PSB1bmRlZmluZWQgfHwgdGVtcDExID09PSBudWxsKSB7fSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxYXZDdXJyZW50U3RhdGVtZW50cy5wdXNoKHRlbXAxMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHFhdkN1cnJlbnRTdGF0ZW1lbnRzO1xuICAgIH07XG5cbiAgICBFWENFTC5ncmFiU29ydHNUMyA9IGZ1bmN0aW9uIChkYXRhLCBxYXZPcmlnaW5hbFNvcnRTaXplKSB7XG4gICAgICAgIHZhciBxYXZSZXNwb25kZW50U29ydHNGcm9tRGJTdG9yZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayA9IDQ7IGsgPCBkYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcEFycmF5MSA9IFtdO1xuICAgICAgICAgICAgdmFyIGlzRW1wdHkgPSBkYXRhW2tdWzFdO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkgPT09IFwiXCIgfHwgaXNFbXB0eSA9PT0gbnVsbCB8fCBpc0VtcHR5ID09PSB1bmRlZmluZWQpIHt9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wMiA9IGRhdGFba11bMV07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc2FuaXRpemVTb3J0VmFsdWVzKHRlbXAyKTtcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkxLnB1c2goK3N0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgbUxlbmd0aCA9IHFhdk9yaWdpbmFsU29ydFNpemU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDI7IG0gPCBtTGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAzID0gZGF0YVtrXVttXTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEFycmF5MS5wdXNoKCt0ZW1wMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmaW5pc2gyID0gZGF0YVtrXVttTGVuZ3RoXTtcbiAgICAgICAgICAgICAgICB2YXIgZmluaXNoID0gc2FuaXRpemVTb3J0VmFsdWVzKGZpbmlzaDIpO1xuICAgICAgICAgICAgICAgIHRlbXBBcnJheTEucHVzaCgrZmluaXNoKTtcbiAgICAgICAgICAgICAgICBxYXZSZXNwb25kZW50U29ydHNGcm9tRGJTdG9yZWQucHVzaCh0ZW1wQXJyYXkxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcWF2UmVzcG9uZGVudFNvcnRzRnJvbURiU3RvcmVkO1xuICAgIH07XG5cbiAgICBFWENFTC5ncmFiUmVzcG9uZGVudE5hbWVzVDMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcWF2UmVzcG9uZGVudE5hbWVzMiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqaiA9IDEsIGpqTGVuID0gZGF0YS5sZW5ndGg7IGpqIDwgampMZW47IGpqKyspIHtcbiAgICAgICAgICAgIHZhciB0ZW1wMSA9IGRhdGFbampdWzBdO1xuICAgICAgICAgICAgaWYgKHRlbXAxID09PSBcIlwiKSB7fSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxYXZSZXNwb25kZW50TmFtZXMyLnB1c2godGVtcDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBxYXZSZXNwb25kZW50TmFtZXMgPSBxYXZSZXNwb25kZW50TmFtZXMyLnNsaWNlKDIpO1xuICAgICAgICByZXR1cm4gcWF2UmVzcG9uZGVudE5hbWVzO1xuICAgIH07XG5cbiAgICBFWENFTC5ncmFiU29ydFRyaWFuZ2xlU2hhcGVUMyA9IGZ1bmN0aW9uIChxYXZTb3J0VHJpYW5nbGVTaGFwZTEpIHtcbiAgICAgICAgdmFyIHFhdlNvcnRUcmlhbmdsZVNoYXBlID0gSlNPTi5wYXJzZShcIltcIiArIHFhdlNvcnRUcmlhbmdsZVNoYXBlMSArIFwiXVwiKTtcbiAgICAgICAgdmFyIGNvcHlUcmlhbmdsZVNoYXBlID0gXy5jbG9uZURlZXAocWF2U29ydFRyaWFuZ2xlU2hhcGUpO1xuICAgICAgICB2YXIgcmV0dXJucyA9IFtxYXZTb3J0VHJpYW5nbGVTaGFwZSwgY29weVRyaWFuZ2xlU2hhcGVdO1xuICAgICAgICByZXR1cm4gW3FhdlNvcnRUcmlhbmdsZVNoYXBlLCBjb3B5VHJpYW5nbGVTaGFwZV07XG4gICAgfTtcblxufSh3aW5kb3cuRVhDRUwgPSB3aW5kb3cuRVhDRUwgfHwge30sIFFBVikpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL0VYQ0VMLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMTMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==')}});