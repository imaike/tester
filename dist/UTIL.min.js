!function(I){function g(A){if(C[A])return C[A].exports;var n=C[A]={i:A,l:!1,exports:{}};return I[A].call(n.exports,n,n.exports,g),n.l=!0,n.exports}var C={};g.m=I,g.c=C,g.i=function(I){return I},g.d=function(I,C,A){g.o(I,C)||Object.defineProperty(I,C,{configurable:!1,enumerable:!0,get:A})},g.n=function(I){var C=I&&I.__esModule?function(){return I.default}:function(){return I};return g.d(C,"a",C),C},g.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},g.p="",g(g.s=14)}({14:function(module,exports){eval('//Ken-Q Analysis\n//Copyright (C) 2016 Shawn Banasick\n//\n//    This program is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, either version 3 of the License, or\n//    (at your option) any later version.\n\n\n// JSlint declarations\n/* global window, $, d3, resources, window, _, navigator, Blob, URL, ROTA, QAV, document, evenRound*/\n\n\n//***************************************************************************   model\n//******* custom rounding - to evens  ***********************************************\n//***********************************************************************************\n// another attempt at custom rounding to mimic pqmethod? "bankers / gaussian rounding"\nfunction evenRound(num, decimalPlaces) {\n    var d = decimalPlaces || 0;\n    var m = Math.pow(10, d);\n    var n = +(d ? num * m : num).toFixed(8); // Avoid rounding errors\n    var i = Math.floor(n),\n        f = n - i;\n    var e = 1e-8; // Allow for rounding errors in f\n    var r = (f > 0.5 - e && f < 0.5 + e) ?\n        ((i % 2 === 0) ? i : i + 1) : Math.round(n);\n    return d ? r / m : r;\n}\n\nfunction jlog(text, element) {\n    return console.log("var " + text + " = " + JSON.stringify(element) + ";");\n}\n\n\n(function (UTIL, QAV, undefined) {\n    \'use strict\';\n\n    UTIL.checkIfOnline = function () {\n        var isOnline;\n        if (window.location.protocol === \'file:\') {\n            isOnline = false;\n        } else {\n            isOnline = true;\n        }\n        return isOnline;\n    };\n\n\n    /*\n    ********************************************************\n    HELPER FUNCTIONS\n\n    standard deviation and average from:\n    http://derickbailey.com/2014/09/21/calculating-standard-deviation-with-array-map-and-array-reduce-in-javascript/\n\n    variance from:\n    http://www.endmemo.com/js/jstatistics.php\n    ********************************************************\n    */\n\n    UTIL.standardDeviation = function (values) {\n        var avg = UTIL.average(values);\n        var squareDiffs = values.map(function (value) {\n            var diff = value - avg;\n            var sqrDiff = diff * diff;\n            return sqrDiff;\n        });\n        var avgSquareDiff1 = squareDiffs.reduce(function (sum, value) {\n            return sum + value;\n        }, 0);\n        var avgSquareDiff = evenRound((avgSquareDiff1 / (squareDiffs.length - 1)), 8);\n        var stdDev = evenRound((Math.sqrt(avgSquareDiff)), 8);\n        return stdDev;\n    };\n\n    UTIL.variance = function (arr) {\n        var len = 0;\n        var sum = 0;\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === "") {} else if (isNaN(arr[i])) {\n                return 0;\n            } else {\n                len = len + 1;\n                sum = sum + parseFloat(arr[i]);\n            }\n        }\n        var v = 0;\n        if (len > 1) {\n            var mean = sum / len;\n            for (i = 0; i < arr.length; i++) {\n                if (arr[i] === "") {} else {\n                    v = v + (arr[i] - mean) * (arr[i] - mean);\n                }\n            }\n            var output2 = v / len;\n            var output = evenRound(output2, 6);\n            return output;\n        } else {\n            return 0;\n        }\n    };\n\n\n    UTIL.average = function (data) {\n        var sum = data.reduce(function (sum, value) {\n            return sum + value;\n        }, 0);\n        var avg = evenRound((sum / data.length), 8);\n        return avg;\n    };\n\n    UTIL.drawDatatable = function (configObj) {\n        $(configObj.domElement).DataTable({\n            "fixedColumns": configObj.fixed,\n            "retrieve": true,\n            "searching": false,\n            "ordering": configObj.ordering,\n            "info": false,\n            "destroy": true,\n            "scrollY": 800,\n            "scrollCollapse": true,\n            "scrollX": true,\n            "paging": false,\n            "data": configObj.data,\n            "columns": configObj.headers,\n            "columnDefs": configObj.colDefs,\n        });\n\n        var table = $(configObj.domElement).DataTable();\n        $(configObj.domElement + \' tbody\')\n            .on(\'mouseenter\', \'td\', function () {\n                var colIdx = table.cell(this).index().column;\n                $(table.cells().nodes()).removeClass(\'highlight\');\n                $(table.column(colIdx).nodes()).addClass(\'highlight\');\n            })\n            .on(\'mouseleave\', function () {\n                $(table.cells().nodes()).removeClass(\'highlight\');\n                $(table.columns().nodes()).removeClass(\'highlight\');\n            });\n    };\n\n    UTIL.addFactorSelectCheckboxesRotation = function (loopLength) {\n\n        // clear checkboxes if previously added to DOM\n        var checkboxFrameCheck = $("#checkboxFrame");\n        if (checkboxFrameCheck.length > 0) {\n            checkboxFrameCheck.empty();\n        }\n\n        var language = QAV.getState("language");\n        var facText = resources[language].translation.Factor;\n\n        // add checkboxes to DOM according to number factors extracted\n        for (var k = 0; k < loopLength; k++) {\n            var incrementedK = k + 1;\n\n            var checkbox = document.createElement(\'input\');\n            checkbox.type = "checkbox";\n            checkbox.name = "radioCheck";\n            checkbox.value = incrementedK;\n            checkbox.className = "checkbox";\n            checkbox.id = "checkChart" + incrementedK;\n\n            var label = document.createElement(\'label\');\n            label.htmlFor = "checkChart" + incrementedK;\n            label.className = "checkboxLabel";\n            label.appendChild(document.createTextNode(facText + " " + incrementedK));\n\n            document.getElementById("checkboxFrame").appendChild(checkbox);\n            document.getElementById("checkboxFrame").appendChild(label);\n        }\n    };\n\n    // ***************************************************************   model\n    // ***** check for unique names and sanitize  ****************************\n    // ***********************************************************************\n    UTIL.checkUniqueName = function (namesFromExistingData) {\n        var namesUniqueArrayTest2 = _.cloneDeep(namesFromExistingData);\n        var namesUniqueArrayTest = _.uniq(namesUniqueArrayTest2);\n\n        if (namesFromExistingData.length !== namesUniqueArrayTest.length) {\n            for (var i = 0; i < namesFromExistingData.length; i++) {\n                // stripping out "." because of display error in datatables\n                var ii = i + 1;\n                var currentName = namesFromExistingData[i];\n                var currentName2 = currentName.replace(/\\./g, "");\n                namesFromExistingData[i] = ii + "_" + currentName2;\n            }\n        } else {\n            for (var j = 0; j < namesFromExistingData.length; j++) {\n                // stripping out "." because of display error in datatables\n                namesFromExistingData[j] = namesFromExistingData[j].replace(/\\./g, " ");\n            }\n        }\n        return namesFromExistingData;\n    };\n\n    UTIL.calculateSortTriangleShape = function (pyramidShapeNumbers) {\n        var sortPossibleValues = [-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];\n        var qavSortTriangleShape = [];\n        for (var i = 0; i < sortPossibleValues.length; i++) {\n            for (var j = 0; j < pyramidShapeNumbers[i]; j++) {\n                qavSortTriangleShape.push(sortPossibleValues[i]);\n            }\n        }\n        QAV.setState("qavSortTriangleShape", qavSortTriangleShape);\n        return qavSortTriangleShape;\n    };\n\n    UTIL.sanitizeUserInputText = function (input) {\n        if (_.isNumber(input)) {\n            return input;\n        } else {\n            var output = input.replace(/<script[^>]*?>.*?<\\/<\\/script>/gi, \'\').\n            replace(/<[\\/\\!]*?[^<>]*?>/gi, \'\').\n            replace(/<style[^>]*?>.*?<\\/style>/gi, \'\').\n            replace(/<![\\s\\S]*?--[ \\t\\n\\r]*>/gi, \'\');\n            QAV.setState("output", output);\n            return output;\n        }\n    };\n\n    // helper function for export routines\n    UTIL.threeDigitPadding = function (e) {\n        if (e < 0) {\n            return " " + e;\n        } else if (e < 10) {\n            return "  " + e;\n        } else if (e > 99) {\n            return e;\n        } else {\n            return " " + e;\n        }\n    };\n\n    UTIL.currentDate1 = function () {\n        var currentDate = new Date();\n        var Day = currentDate.getDate();\n        if (Day < 10) {\n            Day = \'0\' + Day;\n        }\n        var Month = currentDate.getMonth() + 1;\n        if (Month < 10) {\n            Month = \'0\' + Month;\n        }\n        var Year = currentDate.getFullYear();\n        var fullDate = Year + "-" + Month + "-" + Day;\n        return fullDate;\n    };\n\n    UTIL.currentTime1 = function () {\n        var currentTime = new Date();\n        var Minutes = currentTime.getMinutes();\n        if (Minutes < 10) {\n            Minutes = \'0\' + Minutes;\n        }\n        var Hour = currentTime.getHours();\n        if (Hour < 10) {\n            Hour = \'0\' + Hour;\n        }\n\n        var Time = String(Hour) + "-" + String(Minutes);\n\n        return Time;\n    };\n\n    UTIL.checkIfValueIsNumber = function (value, inputBoxId) {\n        if (isNaN(value)) {\n            $("#" + inputBoxId).css("border", "red solid 3px");\n        } else {\n            $("#" + inputBoxId).css("border", "lightgray solid 1px");\n        }\n    };\n\n\n    // *************************************************************  Data Model\n    // **********  Archive function to allow undo of rotations *****************\n    // *************************************************************************\n\n    UTIL.archiveFactorScoreStateMatrixAndDatatable = function () {\n\n        // saveRotationArchieveCounter is reset to 1 on centroid extraction function call\n\n        // get current table data including flags\n        var table = $(\'#factorRotationTable2\').dataTable();\n        var chartData = table.fnGetData();\n\n\n        // get current footer data and push into table data\n        var footerData = QAV.getState("expVar");\n\n        // get copy of current state matrix\n        var rotFacStateArray = QAV.getState("rotFacStateArray");\n\n        // get copy of current rotation table headers (for undo bipolar split charting)\n        var columnHeadersArray = QAV.getState("columnHeadersArray");\n\n        var archiveArray = [];\n\n        // store curr rotation data, chartdata with user flags, and headers in archive array\n        archiveArray.push(rotFacStateArray, chartData, columnHeadersArray, footerData);\n\n        // archive both in local storage with key + counter\n        QAV.setState("rotFacStateArrayArchive" + ROTA.saveRotationArchiveCounter("get"), archiveArray);\n\n        ROTA.saveRotationArchiveCounter("increase");\n    };\n\n    // todo - remove autocomplete="off" for Firefox from index.html and use this\n    //    (function () {\n    //        $(window).unload(function() {\n    //            $(\'#existingDatabaseSelect select option\').remove();\n    //\n    //        });\n    //    })();\n    //\n\n\n    // custom export function - adapted from Jossef Harush - https://jsfiddle.net/jossef/m3rrLzk0/\n    UTIL.exportToCsv = function (filename, rows) {\n        var processRow = function (row) {\n            var finalVal = \'\';\n            for (var j = 0; j < row.length; j++) {\n                var value = row[j];\n                if (value === null || value === undefined) {\n                    value = "";\n                }\n                var innerValue = value.toString();\n                var result = innerValue.replace(/"/g, \'""\');\n                if (result.search(/("|,|\\n)/g) >= 0) {\n                    result = \'"\' + result + \'"\';\n                }\n                if (j > 0) {\n                    finalVal += \',\';\n                }\n                finalVal += result;\n            }\n            return finalVal + \'\\n\';\n        };\n\n        var csvFile = \'\';\n        for (var i = 0; i < rows.length; i++) {\n            csvFile += processRow(rows[i]);\n        }\n\n        var blob = new Blob([csvFile], {\n            type: \'text/CSV;charset=UTF-8;\'\n        });\n        if (navigator.msSaveBlob) { // IE 10+\n            navigator.msSaveBlob(blob, filename);\n        } else {\n            var link = document.createElement("a");\n            if (link.download !== undefined) { // feature detection\n                // Browsers that support HTML5 download attribute\n                var url = URL.createObjectURL(blob);\n                link.setAttribute("href", url);\n                link.setAttribute("download", filename);\n                link.style.visibility = \'hidden\';\n                document.body.appendChild(link);\n                link.click();\n                document.body.removeChild(link);\n            }\n        }\n    };\n\n\n\n\n\n    UTIL.drawScreePlot = function (dataArray) {\n        var i, data, chartSize, margin, width, height;\n        var tempArray, maxValue, xTicks;\n\n        maxValue = _.max(dataArray);\n        if (maxValue < 10 && maxValue > 5) {\n            maxValue = 10;\n        } else if (maxValue < 5) {\n            maxValue = 5;\n        }\n\n        xTicks = dataArray.length;\n        if (xTicks < 5) {\n            xTicks = 5;\n        }\n\n        data = [];\n        for (i = 0; i < dataArray.length; i++) {\n            tempArray = {};\n            tempArray.eigen = dataArray[i];\n            tempArray.factor = (i + 1);\n            data.push(tempArray);\n        }\n\n        chartSize = $(window).width() / 1.25;\n\n        margin = {\n            top: 150,\n            right: 10,\n            bottom: 40,\n            left: 100\n        };\n\n        width = chartSize - margin.left - margin.right;\n        if (width > 700) {\n            width = 700;\n        }\n        height = width - margin.bottom - 80;\n\n        // get current language value\n        var language = QAV.getState("language");\n        var plotTitle = resources[language].translation["Scree Plot"];\n        var xAxisTitle = resources[language].translation["Factor Number"];\n        var yAxisTitle = resources[language].translation.Eigenvalues;\n\n        // Set the ranges\n        var x = d3.scale.linear().range([0, width]);\n        var y = d3.scale.linear().range([height, 0]);\n\n        // Define the axes    todo - fix bug with subdivide when less than 4 fac\n        var xAxis = d3.svg.axis().scale(x).tickSubdivide(false)\n            .orient("bottom").ticks(8);\n\n        var yAxis = d3.svg.axis().scale(y).tickSubdivide(true)\n            .orient("left").ticks(maxValue);\n\n        // Define the line\n        var valueline = d3.svg.line()\n            .x(function (d) {\n                return x(d.factor);\n            })\n            .y(function (d) {\n                return y(d.eigen);\n            });\n\n        // Adds the svg canvas\n        var svg = d3.select("#screePlotDiv")\n            .append("svg")\n            .attr("id", "screePlotSVG")\n            .attr("width", width + margin.left + margin.right)\n            .attr("height", height + 20 + margin.top + margin.bottom)\n            .append("g")\n            .attr("transform",\n                "translate(" + margin.left + "," + margin.top + ")");\n\n        // Scale the range of the data\n        x.domain([0, 8]);\n        y.domain([0, d3.max(data, function (d) {\n            return d.eigen < 10 ? maxValue : d.eigen;\n        })]);\n\n        // create x axis title\n        svg.append("text")\n            .attr("x", width / 2)\n            .attr("y", height + 45)\n            .style("text-anchor", "middle")\n            .style("font-weight", "bold")\n            .style("margin-top", "10px")\n            .style("font-size", "14px")\n            .style("font-family", "Arial")\n            .text(xAxisTitle);\n\n        // create Y axis label\n        svg.append("text")\n            .attr("transform", "rotate(-90)")\n            .attr("y", 0 - (margin.left / 2))\n            .attr("x", 0 - (height / 2))\n            .attr("dy", "1em")\n            .style("text-anchor", "middle")\n            .style("font-weight", "bold")\n            .style("font-size", "14px")\n            .style("font-family", "Arial")\n            .text(yAxisTitle);\n\n        // create chart title\n        svg.append("text")\n            .attr("x", (width / 2))\n            .attr("y", 0 - (margin.top / 8))\n            .attr("text-anchor", "middle")\n            .style("font-size", "30px")\n            .style("font-family", "Arial")\n            .text(plotTitle);\n\n        // Add the valueline path.\n        svg.append("path")\n            .attr("class", "line")\n            .attr("d", valueline(data))\n            .style({\n                \'stroke\': \'black\',\n                \'fill\': \'none\',\n                \'stroke-width\': \'2px\',\n            });\n\n        // Add the X Axis\n        svg.append("g")\n            .attr("class", "x axis")\n            .attr("transform", "translate(0," + height + ")")\n            .call(xAxis);\n\n        // Add the Y Axis\n        svg.append("g")\n            .attr("class", "y axis")\n            .call(yAxis);\n\n        svg.selectAll(".tick > text")\n            .style("font-family", "Arial");\n\n        svg.selectAll(".dot2")\n            .data(data)\n            .enter().append("circle")\n            .attr("class", "dot2")\n            .attr("cx", function (data) {\n                return x(data.factor);\n            })\n            .attr("cy", function (data) {\n                return y(data.eigen);\n            })\n            .attr("r", 3.5);\n\n        svg.selectAll(\'.axis lne, .axis path\')\n            .style({\n                \'stroke\': \'black\',\n                \'fill\': \'none\',\n                \'stroke-width\': \'1px\'\n            });\n\n        svg.selectAll(".tick:not(:first-of-type) line").attr("stroke", "black").attr("stroke-width", "1px");\n    };\n\n\n\n    // PNG downloads adapted from Nikita Rokotyan http://bl.ocks.org/Rokotyan/0556f8facbaf344507cdc45dc3622177\n    UTIL.downloadPngImages = function (svgString, svgCharacteristics, nameConfig) {\n        var width = parseInt(svgCharacteristics.style("width"), 10) + 2;\n        var height = parseInt(svgCharacteristics.style("height"), 10);\n        svgString2Image(svgString, 2 * width, 2 * height, \'png\', save); // passes Blob and filesize String to the callback\n        var filenamePng = nameConfig + \'.png\';\n\n        function save(dataBlob, filesize) {\n            saveAs(dataBlob, filenamePng); // FileSaver.js function\n        }\n    };\n\n    UTIL.getSVGString = function (svgNode) {\n        svgNode.setAttribute(\'xlink\', \'http://www.w3.org/1999/xlink\');\n        var cssStyleText = getCSSStyles(svgNode);\n        appendCSS(cssStyleText, svgNode);\n\n        var serializer = new XMLSerializer();\n        var svgString = serializer.serializeToString(svgNode);\n        svgString = svgString.replace(/(\\w+)?:?xlink=/g, \'xmlns:xlink=\'); // Fix root xlink without namespace\n        svgString = svgString.replace(/NS\\d+:href/g, \'xlink:href\'); // Safari NS namespace fix\n\n        return svgString;\n\n        function getCSSStyles(parentElement) {\n            var selectorTextArr = [];\n\n            // Add Parent element Id and Classes to the list\n            selectorTextArr.push(\'#\' + parentElement.id);\n            for (var c = 0; c < parentElement.classList.length; c++)\n                if (!contains(\'.\' + parentElement.classList[c], selectorTextArr))\n                    selectorTextArr.push(\'.\' + parentElement.classList[c]);\n\n            // Add Children element Ids and Classes to the list\n            var nodes = parentElement.getElementsByTagName("*");\n            for (var i = 0; i < nodes.length; i++) {\n                var id = nodes[i].id;\n                if (!contains(\'#\' + id, selectorTextArr))\n                    selectorTextArr.push(\'#\' + id);\n\n                var classes = nodes[i].classList;\n                for (var c = 0; c < classes.length; c++)\n                    if (!contains(\'.\' + classes[c], selectorTextArr))\n                        selectorTextArr.push(\'.\' + classes[c]);\n            }\n\n            // Extract CSS Rules\n            var extractedCSSText = "";\n            for (var i = 0; i < document.styleSheets.length; i++) {\n                var s = document.styleSheets[i];\n\n                try {\n                    if (!s.cssRules) continue;\n                } catch (e) {\n                    if (e.name !== \'SecurityError\') throw e; // for Firefox\n                    continue;\n                }\n\n                var cssRules = s.cssRules;\n                for (var r = 0; r < cssRules.length; r++) {\n                    if (contains(cssRules[r].selectorText, selectorTextArr))\n                        extractedCSSText += cssRules[r].cssText;\n                }\n            }\n            return extractedCSSText;\n\n            function contains(str, arr) {\n                return arr.indexOf(str) === -1 ? false : true;\n            }\n        }\n\n        function appendCSS(cssText, element) {\n            var styleElement = document.createElement("style");\n            styleElement.setAttribute("type", "text/css");\n            styleElement.innerHTML = cssText;\n            var refNode = element.hasChildNodes() ? element.children[0] : null;\n            element.insertBefore(styleElement, refNode);\n        }\n    };\n\n    // ** HELPER FUNCTIONS **\n    // svgString2Image\n    function svgString2Image(svgString, width, height, format, callback) {\n        var format = format ? format : \'png\';\n        var imgsrc = \'data:image/svg+xml;base64,\' + btoa(unescape(encodeURIComponent(svgString))); // Convert SVG string to data URL\n        var canvas = document.createElement("canvas");\n        var context = canvas.getContext("2d");\n        canvas.width = width;\n        canvas.height = height;\n        var image = new Image();\n        image.onload = function () {\n            context.clearRect(0, 0, width, height);\n            context.drawImage(image, 0, 0, width, height);\n            canvas.toBlob(function (blob) {\n                var filesize = Math.round(blob.length / 1024) + \' KB\';\n                if (callback) callback(blob, filesize);\n            });\n        };\n        image.src = imgsrc;\n    }\n\n\n}(window.UTIL = window.UTIL || {}, QAV));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVVRJTC5qcz83NDY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vS2VuLVEgQW5hbHlzaXNcbi8vQ29weXJpZ2h0IChDKSAyMDE2IFNoYXduIEJhbmFzaWNrXG4vL1xuLy8gICAgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuLy8gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuXG4vLyBKU2xpbnQgZGVjbGFyYXRpb25zXG4vKiBnbG9iYWwgd2luZG93LCAkLCBkMywgcmVzb3VyY2VzLCB3aW5kb3csIF8sIG5hdmlnYXRvciwgQmxvYiwgVVJMLCBST1RBLCBRQVYsIGRvY3VtZW50LCBldmVuUm91bmQqL1xuXG5cbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICAgbW9kZWxcbi8vKioqKioqKiBjdXN0b20gcm91bmRpbmcgLSB0byBldmVucyAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIGFub3RoZXIgYXR0ZW1wdCBhdCBjdXN0b20gcm91bmRpbmcgdG8gbWltaWMgcHFtZXRob2Q/IFwiYmFua2VycyAvIGdhdXNzaWFuIHJvdW5kaW5nXCJcbmZ1bmN0aW9uIGV2ZW5Sb3VuZChudW0sIGRlY2ltYWxQbGFjZXMpIHtcbiAgICB2YXIgZCA9IGRlY2ltYWxQbGFjZXMgfHwgMDtcbiAgICB2YXIgbSA9IE1hdGgucG93KDEwLCBkKTtcbiAgICB2YXIgbiA9ICsoZCA/IG51bSAqIG0gOiBudW0pLnRvRml4ZWQoOCk7IC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yc1xuICAgIHZhciBpID0gTWF0aC5mbG9vcihuKSxcbiAgICAgICAgZiA9IG4gLSBpO1xuICAgIHZhciBlID0gMWUtODsgLy8gQWxsb3cgZm9yIHJvdW5kaW5nIGVycm9ycyBpbiBmXG4gICAgdmFyIHIgPSAoZiA+IDAuNSAtIGUgJiYgZiA8IDAuNSArIGUpID9cbiAgICAgICAgKChpICUgMiA9PT0gMCkgPyBpIDogaSArIDEpIDogTWF0aC5yb3VuZChuKTtcbiAgICByZXR1cm4gZCA/IHIgLyBtIDogcjtcbn1cblxuZnVuY3Rpb24gamxvZyh0ZXh0LCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGNvbnNvbGUubG9nKFwidmFyIFwiICsgdGV4dCArIFwiID0gXCIgKyBKU09OLnN0cmluZ2lmeShlbGVtZW50KSArIFwiO1wiKTtcbn1cblxuXG4oZnVuY3Rpb24gKFVUSUwsIFFBViwgdW5kZWZpbmVkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgVVRJTC5jaGVja0lmT25saW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNPbmxpbmU7XG4gICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICAgICAgICAgIGlzT25saW5lID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc09ubGluZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzT25saW5lO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBIRUxQRVIgRlVOQ1RJT05TXG5cbiAgICBzdGFuZGFyZCBkZXZpYXRpb24gYW5kIGF2ZXJhZ2UgZnJvbTpcbiAgICBodHRwOi8vZGVyaWNrYmFpbGV5LmNvbS8yMDE0LzA5LzIxL2NhbGN1bGF0aW5nLXN0YW5kYXJkLWRldmlhdGlvbi13aXRoLWFycmF5LW1hcC1hbmQtYXJyYXktcmVkdWNlLWluLWphdmFzY3JpcHQvXG5cbiAgICB2YXJpYW5jZSBmcm9tOlxuICAgIGh0dHA6Ly93d3cuZW5kbWVtby5jb20vanMvanN0YXRpc3RpY3MucGhwXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAqL1xuXG4gICAgVVRJTC5zdGFuZGFyZERldmlhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGF2ZyA9IFVUSUwuYXZlcmFnZSh2YWx1ZXMpO1xuICAgICAgICB2YXIgc3F1YXJlRGlmZnMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSB2YWx1ZSAtIGF2ZztcbiAgICAgICAgICAgIHZhciBzcXJEaWZmID0gZGlmZiAqIGRpZmY7XG4gICAgICAgICAgICByZXR1cm4gc3FyRGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhdmdTcXVhcmVEaWZmMSA9IHNxdWFyZURpZmZzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1bSArIHZhbHVlO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgdmFyIGF2Z1NxdWFyZURpZmYgPSBldmVuUm91bmQoKGF2Z1NxdWFyZURpZmYxIC8gKHNxdWFyZURpZmZzLmxlbmd0aCAtIDEpKSwgOCk7XG4gICAgICAgIHZhciBzdGREZXYgPSBldmVuUm91bmQoKE1hdGguc3FydChhdmdTcXVhcmVEaWZmKSksIDgpO1xuICAgICAgICByZXR1cm4gc3RkRGV2O1xuICAgIH07XG5cbiAgICBVVElMLnZhcmlhbmNlID0gZnVuY3Rpb24gKGFycikge1xuICAgICAgICB2YXIgbGVuID0gMDtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID09PSBcIlwiKSB7fSBlbHNlIGlmIChpc05hTihhcnJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlbiA9IGxlbiArIDE7XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtICsgcGFyc2VGbG9hdChhcnJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2ID0gMDtcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgIHZhciBtZWFuID0gc3VtIC8gbGVuO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJbaV0gPT09IFwiXCIpIHt9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2ID0gdiArIChhcnJbaV0gLSBtZWFuKSAqIChhcnJbaV0gLSBtZWFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3V0cHV0MiA9IHYgLyBsZW47XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gZXZlblJvdW5kKG91dHB1dDIsIDYpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgVVRJTC5hdmVyYWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHN1bSA9IGRhdGEucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VtICsgdmFsdWU7XG4gICAgICAgIH0sIDApO1xuICAgICAgICB2YXIgYXZnID0gZXZlblJvdW5kKChzdW0gLyBkYXRhLmxlbmd0aCksIDgpO1xuICAgICAgICByZXR1cm4gYXZnO1xuICAgIH07XG5cbiAgICBVVElMLmRyYXdEYXRhdGFibGUgPSBmdW5jdGlvbiAoY29uZmlnT2JqKSB7XG4gICAgICAgICQoY29uZmlnT2JqLmRvbUVsZW1lbnQpLkRhdGFUYWJsZSh7XG4gICAgICAgICAgICBcImZpeGVkQ29sdW1uc1wiOiBjb25maWdPYmouZml4ZWQsXG4gICAgICAgICAgICBcInJldHJpZXZlXCI6IHRydWUsXG4gICAgICAgICAgICBcInNlYXJjaGluZ1wiOiBmYWxzZSxcbiAgICAgICAgICAgIFwib3JkZXJpbmdcIjogY29uZmlnT2JqLm9yZGVyaW5nLFxuICAgICAgICAgICAgXCJpbmZvXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJkZXN0cm95XCI6IHRydWUsXG4gICAgICAgICAgICBcInNjcm9sbFlcIjogODAwLFxuICAgICAgICAgICAgXCJzY3JvbGxDb2xsYXBzZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzY3JvbGxYXCI6IHRydWUsXG4gICAgICAgICAgICBcInBhZ2luZ1wiOiBmYWxzZSxcbiAgICAgICAgICAgIFwiZGF0YVwiOiBjb25maWdPYmouZGF0YSxcbiAgICAgICAgICAgIFwiY29sdW1uc1wiOiBjb25maWdPYmouaGVhZGVycyxcbiAgICAgICAgICAgIFwiY29sdW1uRGVmc1wiOiBjb25maWdPYmouY29sRGVmcyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHRhYmxlID0gJChjb25maWdPYmouZG9tRWxlbWVudCkuRGF0YVRhYmxlKCk7XG4gICAgICAgICQoY29uZmlnT2JqLmRvbUVsZW1lbnQgKyAnIHRib2R5JylcbiAgICAgICAgICAgIC5vbignbW91c2VlbnRlcicsICd0ZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sSWR4ID0gdGFibGUuY2VsbCh0aGlzKS5pbmRleCgpLmNvbHVtbjtcbiAgICAgICAgICAgICAgICAkKHRhYmxlLmNlbGxzKCkubm9kZXMoKSkucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgICAgICQodGFibGUuY29sdW1uKGNvbElkeCkubm9kZXMoKSkuYWRkQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkKHRhYmxlLmNlbGxzKCkubm9kZXMoKSkucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgICAgICQodGFibGUuY29sdW1ucygpLm5vZGVzKCkpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBVVElMLmFkZEZhY3RvclNlbGVjdENoZWNrYm94ZXNSb3RhdGlvbiA9IGZ1bmN0aW9uIChsb29wTGVuZ3RoKSB7XG5cbiAgICAgICAgLy8gY2xlYXIgY2hlY2tib3hlcyBpZiBwcmV2aW91c2x5IGFkZGVkIHRvIERPTVxuICAgICAgICB2YXIgY2hlY2tib3hGcmFtZUNoZWNrID0gJChcIiNjaGVja2JveEZyYW1lXCIpO1xuICAgICAgICBpZiAoY2hlY2tib3hGcmFtZUNoZWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNoZWNrYm94RnJhbWVDaGVjay5lbXB0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBmYWNUZXh0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5GYWN0b3I7XG5cbiAgICAgICAgLy8gYWRkIGNoZWNrYm94ZXMgdG8gRE9NIGFjY29yZGluZyB0byBudW1iZXIgZmFjdG9ycyBleHRyYWN0ZWRcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsb29wTGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnRlZEsgPSBrICsgMTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIGNoZWNrYm94LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgICAgICBjaGVja2JveC5uYW1lID0gXCJyYWRpb0NoZWNrXCI7XG4gICAgICAgICAgICBjaGVja2JveC52YWx1ZSA9IGluY3JlbWVudGVkSztcbiAgICAgICAgICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgICAgICAgIGNoZWNrYm94LmlkID0gXCJjaGVja0NoYXJ0XCIgKyBpbmNyZW1lbnRlZEs7XG5cbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbC5odG1sRm9yID0gXCJjaGVja0NoYXJ0XCIgKyBpbmNyZW1lbnRlZEs7XG4gICAgICAgICAgICBsYWJlbC5jbGFzc05hbWUgPSBcImNoZWNrYm94TGFiZWxcIjtcbiAgICAgICAgICAgIGxhYmVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGZhY1RleHQgKyBcIiBcIiArIGluY3JlbWVudGVkSykpO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoZWNrYm94RnJhbWVcIikuYXBwZW5kQ2hpbGQoY2hlY2tib3gpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjaGVja2JveEZyYW1lXCIpLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogICBtb2RlbFxuICAgIC8vICoqKioqIGNoZWNrIGZvciB1bmlxdWUgbmFtZXMgYW5kIHNhbml0aXplICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBVVElMLmNoZWNrVW5pcXVlTmFtZSA9IGZ1bmN0aW9uIChuYW1lc0Zyb21FeGlzdGluZ0RhdGEpIHtcbiAgICAgICAgdmFyIG5hbWVzVW5pcXVlQXJyYXlUZXN0MiA9IF8uY2xvbmVEZWVwKG5hbWVzRnJvbUV4aXN0aW5nRGF0YSk7XG4gICAgICAgIHZhciBuYW1lc1VuaXF1ZUFycmF5VGVzdCA9IF8udW5pcShuYW1lc1VuaXF1ZUFycmF5VGVzdDIpO1xuXG4gICAgICAgIGlmIChuYW1lc0Zyb21FeGlzdGluZ0RhdGEubGVuZ3RoICE9PSBuYW1lc1VuaXF1ZUFycmF5VGVzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXNGcm9tRXhpc3RpbmdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXBwaW5nIG91dCBcIi5cIiBiZWNhdXNlIG9mIGRpc3BsYXkgZXJyb3IgaW4gZGF0YXRhYmxlc1xuICAgICAgICAgICAgICAgIHZhciBpaSA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TmFtZSA9IG5hbWVzRnJvbUV4aXN0aW5nRGF0YVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5hbWUyID0gY3VycmVudE5hbWUucmVwbGFjZSgvXFwuL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIG5hbWVzRnJvbUV4aXN0aW5nRGF0YVtpXSA9IGlpICsgXCJfXCIgKyBjdXJyZW50TmFtZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5hbWVzRnJvbUV4aXN0aW5nRGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwcGluZyBvdXQgXCIuXCIgYmVjYXVzZSBvZiBkaXNwbGF5IGVycm9yIGluIGRhdGF0YWJsZXNcbiAgICAgICAgICAgICAgICBuYW1lc0Zyb21FeGlzdGluZ0RhdGFbal0gPSBuYW1lc0Zyb21FeGlzdGluZ0RhdGFbal0ucmVwbGFjZSgvXFwuL2csIFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZXNGcm9tRXhpc3RpbmdEYXRhO1xuICAgIH07XG5cbiAgICBVVElMLmNhbGN1bGF0ZVNvcnRUcmlhbmdsZVNoYXBlID0gZnVuY3Rpb24gKHB5cmFtaWRTaGFwZU51bWJlcnMpIHtcbiAgICAgICAgdmFyIHNvcnRQb3NzaWJsZVZhbHVlcyA9IFstNiwgLTUsIC00LCAtMywgLTIsIC0xLCAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxM107XG4gICAgICAgIHZhciBxYXZTb3J0VHJpYW5nbGVTaGFwZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRQb3NzaWJsZVZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBweXJhbWlkU2hhcGVOdW1iZXJzW2ldOyBqKyspIHtcbiAgICAgICAgICAgICAgICBxYXZTb3J0VHJpYW5nbGVTaGFwZS5wdXNoKHNvcnRQb3NzaWJsZVZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUUFWLnNldFN0YXRlKFwicWF2U29ydFRyaWFuZ2xlU2hhcGVcIiwgcWF2U29ydFRyaWFuZ2xlU2hhcGUpO1xuICAgICAgICByZXR1cm4gcWF2U29ydFRyaWFuZ2xlU2hhcGU7XG4gICAgfTtcblxuICAgIFVUSUwuc2FuaXRpemVVc2VySW5wdXRUZXh0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmIChfLmlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGlucHV0LnJlcGxhY2UoLzxzY3JpcHRbXj5dKj8+Lio/PFxcLzxcXC9zY3JpcHQ+L2dpLCAnJykuXG4gICAgICAgICAgICByZXBsYWNlKC88W1xcL1xcIV0qP1tePD5dKj8+L2dpLCAnJykuXG4gICAgICAgICAgICByZXBsYWNlKC88c3R5bGVbXj5dKj8+Lio/PFxcL3N0eWxlPi9naSwgJycpLlxuICAgICAgICAgICAgcmVwbGFjZSgvPCFbXFxzXFxTXSo/LS1bIFxcdFxcblxccl0qPi9naSwgJycpO1xuICAgICAgICAgICAgUUFWLnNldFN0YXRlKFwib3V0cHV0XCIsIG91dHB1dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgZXhwb3J0IHJvdXRpbmVzXG4gICAgVVRJTC50aHJlZURpZ2l0UGFkZGluZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiIFwiICsgZTtcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMTApIHtcbiAgICAgICAgICAgIHJldHVybiBcIiAgXCIgKyBlO1xuICAgICAgICB9IGVsc2UgaWYgKGUgPiA5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCIgXCIgKyBlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFVUSUwuY3VycmVudERhdGUxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgRGF5ID0gY3VycmVudERhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICBpZiAoRGF5IDwgMTApIHtcbiAgICAgICAgICAgIERheSA9ICcwJyArIERheTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgTW9udGggPSBjdXJyZW50RGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgICAgaWYgKE1vbnRoIDwgMTApIHtcbiAgICAgICAgICAgIE1vbnRoID0gJzAnICsgTW9udGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFllYXIgPSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICB2YXIgZnVsbERhdGUgPSBZZWFyICsgXCItXCIgKyBNb250aCArIFwiLVwiICsgRGF5O1xuICAgICAgICByZXR1cm4gZnVsbERhdGU7XG4gICAgfTtcblxuICAgIFVUSUwuY3VycmVudFRpbWUxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgTWludXRlcyA9IGN1cnJlbnRUaW1lLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgaWYgKE1pbnV0ZXMgPCAxMCkge1xuICAgICAgICAgICAgTWludXRlcyA9ICcwJyArIE1pbnV0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEhvdXIgPSBjdXJyZW50VGltZS5nZXRIb3VycygpO1xuICAgICAgICBpZiAoSG91ciA8IDEwKSB7XG4gICAgICAgICAgICBIb3VyID0gJzAnICsgSG91cjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBUaW1lID0gU3RyaW5nKEhvdXIpICsgXCItXCIgKyBTdHJpbmcoTWludXRlcyk7XG5cbiAgICAgICAgcmV0dXJuIFRpbWU7XG4gICAgfTtcblxuICAgIFVUSUwuY2hlY2tJZlZhbHVlSXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUsIGlucHV0Qm94SWQpIHtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgJChcIiNcIiArIGlucHV0Qm94SWQpLmNzcyhcImJvcmRlclwiLCBcInJlZCBzb2xpZCAzcHhcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKFwiI1wiICsgaW5wdXRCb3hJZCkuY3NzKFwiYm9yZGVyXCIsIFwibGlnaHRncmF5IHNvbGlkIDFweFwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogIERhdGEgTW9kZWxcbiAgICAvLyAqKioqKioqKioqICBBcmNoaXZlIGZ1bmN0aW9uIHRvIGFsbG93IHVuZG8gb2Ygcm90YXRpb25zICoqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgVVRJTC5hcmNoaXZlRmFjdG9yU2NvcmVTdGF0ZU1hdHJpeEFuZERhdGF0YWJsZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvLyBzYXZlUm90YXRpb25BcmNoaWV2ZUNvdW50ZXIgaXMgcmVzZXQgdG8gMSBvbiBjZW50cm9pZCBleHRyYWN0aW9uIGZ1bmN0aW9uIGNhbGxcblxuICAgICAgICAvLyBnZXQgY3VycmVudCB0YWJsZSBkYXRhIGluY2x1ZGluZyBmbGFnc1xuICAgICAgICB2YXIgdGFibGUgPSAkKCcjZmFjdG9yUm90YXRpb25UYWJsZTInKS5kYXRhVGFibGUoKTtcbiAgICAgICAgdmFyIGNoYXJ0RGF0YSA9IHRhYmxlLmZuR2V0RGF0YSgpO1xuXG5cbiAgICAgICAgLy8gZ2V0IGN1cnJlbnQgZm9vdGVyIGRhdGEgYW5kIHB1c2ggaW50byB0YWJsZSBkYXRhXG4gICAgICAgIHZhciBmb290ZXJEYXRhID0gUUFWLmdldFN0YXRlKFwiZXhwVmFyXCIpO1xuXG4gICAgICAgIC8vIGdldCBjb3B5IG9mIGN1cnJlbnQgc3RhdGUgbWF0cml4XG4gICAgICAgIHZhciByb3RGYWNTdGF0ZUFycmF5ID0gUUFWLmdldFN0YXRlKFwicm90RmFjU3RhdGVBcnJheVwiKTtcblxuICAgICAgICAvLyBnZXQgY29weSBvZiBjdXJyZW50IHJvdGF0aW9uIHRhYmxlIGhlYWRlcnMgKGZvciB1bmRvIGJpcG9sYXIgc3BsaXQgY2hhcnRpbmcpXG4gICAgICAgIHZhciBjb2x1bW5IZWFkZXJzQXJyYXkgPSBRQVYuZ2V0U3RhdGUoXCJjb2x1bW5IZWFkZXJzQXJyYXlcIik7XG5cbiAgICAgICAgdmFyIGFyY2hpdmVBcnJheSA9IFtdO1xuXG4gICAgICAgIC8vIHN0b3JlIGN1cnIgcm90YXRpb24gZGF0YSwgY2hhcnRkYXRhIHdpdGggdXNlciBmbGFncywgYW5kIGhlYWRlcnMgaW4gYXJjaGl2ZSBhcnJheVxuICAgICAgICBhcmNoaXZlQXJyYXkucHVzaChyb3RGYWNTdGF0ZUFycmF5LCBjaGFydERhdGEsIGNvbHVtbkhlYWRlcnNBcnJheSwgZm9vdGVyRGF0YSk7XG5cbiAgICAgICAgLy8gYXJjaGl2ZSBib3RoIGluIGxvY2FsIHN0b3JhZ2Ugd2l0aCBrZXkgKyBjb3VudGVyXG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInJvdEZhY1N0YXRlQXJyYXlBcmNoaXZlXCIgKyBST1RBLnNhdmVSb3RhdGlvbkFyY2hpdmVDb3VudGVyKFwiZ2V0XCIpLCBhcmNoaXZlQXJyYXkpO1xuXG4gICAgICAgIFJPVEEuc2F2ZVJvdGF0aW9uQXJjaGl2ZUNvdW50ZXIoXCJpbmNyZWFzZVwiKTtcbiAgICB9O1xuXG4gICAgLy8gdG9kbyAtIHJlbW92ZSBhdXRvY29tcGxldGU9XCJvZmZcIiBmb3IgRmlyZWZveCBmcm9tIGluZGV4Lmh0bWwgYW5kIHVzZSB0aGlzXG4gICAgLy8gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAvLyAgICAgICAgJCh3aW5kb3cpLnVubG9hZChmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgICAgICAgICQoJyNleGlzdGluZ0RhdGFiYXNlU2VsZWN0IHNlbGVjdCBvcHRpb24nKS5yZW1vdmUoKTtcbiAgICAvL1xuICAgIC8vICAgICAgICB9KTtcbiAgICAvLyAgICB9KSgpO1xuICAgIC8vXG5cblxuICAgIC8vIGN1c3RvbSBleHBvcnQgZnVuY3Rpb24gLSBhZGFwdGVkIGZyb20gSm9zc2VmIEhhcnVzaCAtIGh0dHBzOi8vanNmaWRkbGUubmV0L2pvc3NlZi9tM3JyTHprMC9cbiAgICBVVElMLmV4cG9ydFRvQ3N2ID0gZnVuY3Rpb24gKGZpbGVuYW1lLCByb3dzKSB7XG4gICAgICAgIHZhciBwcm9jZXNzUm93ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgdmFyIGZpbmFsVmFsID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJvd1tqXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbm5lclZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW5uZXJWYWx1ZS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2VhcmNoKC8oXCJ8LHxcXG4pL2cpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ1wiJyArIHJlc3VsdCArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbCArPSAnLCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsVmFsICs9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaW5hbFZhbCArICdcXG4nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjc3ZGaWxlID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3N2RmlsZSArPSBwcm9jZXNzUm93KHJvd3NbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbY3N2RmlsZV0sIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0L0NTVjtjaGFyc2V0PVVURi04OydcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuYXZpZ2F0b3IubXNTYXZlQmxvYikgeyAvLyBJRSAxMCtcbiAgICAgICAgICAgIG5hdmlnYXRvci5tc1NhdmVCbG9iKGJsb2IsIGZpbGVuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICBpZiAobGluay5kb3dubG9hZCAhPT0gdW5kZWZpbmVkKSB7IC8vIGZlYXR1cmUgZGV0ZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gQnJvd3NlcnMgdGhhdCBzdXBwb3J0IEhUTUw1IGRvd25sb2FkIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCB1cmwpO1xuICAgICAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIiwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIGxpbmsuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICAgICAgICAgICAgbGluay5jbGljaygpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuXG5cbiAgICBVVElMLmRyYXdTY3JlZVBsb3QgPSBmdW5jdGlvbiAoZGF0YUFycmF5KSB7XG4gICAgICAgIHZhciBpLCBkYXRhLCBjaGFydFNpemUsIG1hcmdpbiwgd2lkdGgsIGhlaWdodDtcbiAgICAgICAgdmFyIHRlbXBBcnJheSwgbWF4VmFsdWUsIHhUaWNrcztcblxuICAgICAgICBtYXhWYWx1ZSA9IF8ubWF4KGRhdGFBcnJheSk7XG4gICAgICAgIGlmIChtYXhWYWx1ZSA8IDEwICYmIG1heFZhbHVlID4gNSkge1xuICAgICAgICAgICAgbWF4VmFsdWUgPSAxMDtcbiAgICAgICAgfSBlbHNlIGlmIChtYXhWYWx1ZSA8IDUpIHtcbiAgICAgICAgICAgIG1heFZhbHVlID0gNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhUaWNrcyA9IGRhdGFBcnJheS5sZW5ndGg7XG4gICAgICAgIGlmICh4VGlja3MgPCA1KSB7XG4gICAgICAgICAgICB4VGlja3MgPSA1O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wQXJyYXkgPSB7fTtcbiAgICAgICAgICAgIHRlbXBBcnJheS5laWdlbiA9IGRhdGFBcnJheVtpXTtcbiAgICAgICAgICAgIHRlbXBBcnJheS5mYWN0b3IgPSAoaSArIDEpO1xuICAgICAgICAgICAgZGF0YS5wdXNoKHRlbXBBcnJheSk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydFNpemUgPSAkKHdpbmRvdykud2lkdGgoKSAvIDEuMjU7XG5cbiAgICAgICAgbWFyZ2luID0ge1xuICAgICAgICAgICAgdG9wOiAxNTAsXG4gICAgICAgICAgICByaWdodDogMTAsXG4gICAgICAgICAgICBib3R0b206IDQwLFxuICAgICAgICAgICAgbGVmdDogMTAwXG4gICAgICAgIH07XG5cbiAgICAgICAgd2lkdGggPSBjaGFydFNpemUgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgaWYgKHdpZHRoID4gNzAwKSB7XG4gICAgICAgICAgICB3aWR0aCA9IDcwMDtcbiAgICAgICAgfVxuICAgICAgICBoZWlnaHQgPSB3aWR0aCAtIG1hcmdpbi5ib3R0b20gLSA4MDtcblxuICAgICAgICAvLyBnZXQgY3VycmVudCBsYW5ndWFnZSB2YWx1ZVxuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBRQVYuZ2V0U3RhdGUoXCJsYW5ndWFnZVwiKTtcbiAgICAgICAgdmFyIHBsb3RUaXRsZSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJTY3JlZSBQbG90XCJdO1xuICAgICAgICB2YXIgeEF4aXNUaXRsZSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJGYWN0b3IgTnVtYmVyXCJdO1xuICAgICAgICB2YXIgeUF4aXNUaXRsZSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uRWlnZW52YWx1ZXM7XG5cbiAgICAgICAgLy8gU2V0IHRoZSByYW5nZXNcbiAgICAgICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKS5yYW5nZShbMCwgd2lkdGhdKTtcbiAgICAgICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKS5yYW5nZShbaGVpZ2h0LCAwXSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIHRoZSBheGVzICAgIHRvZG8gLSBmaXggYnVnIHdpdGggc3ViZGl2aWRlIHdoZW4gbGVzcyB0aGFuIDQgZmFjXG4gICAgICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKCkuc2NhbGUoeCkudGlja1N1YmRpdmlkZShmYWxzZSlcbiAgICAgICAgICAgIC5vcmllbnQoXCJib3R0b21cIikudGlja3MoOCk7XG5cbiAgICAgICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKS5zY2FsZSh5KS50aWNrU3ViZGl2aWRlKHRydWUpXG4gICAgICAgICAgICAub3JpZW50KFwibGVmdFwiKS50aWNrcyhtYXhWYWx1ZSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIHRoZSBsaW5lXG4gICAgICAgIHZhciB2YWx1ZWxpbmUgPSBkMy5zdmcubGluZSgpXG4gICAgICAgICAgICAueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4KGQuZmFjdG9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAueShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5KGQuZWlnZW4pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkcyB0aGUgc3ZnIGNhbnZhc1xuICAgICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KFwiI3NjcmVlUGxvdERpdlwiKVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInNjcmVlUGxvdFNWR1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgMjAgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICAgICAgLy8gU2NhbGUgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gICAgICAgIHguZG9tYWluKFswLCA4XSk7XG4gICAgICAgIHkuZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmVpZ2VuIDwgMTAgPyBtYXhWYWx1ZSA6IGQuZWlnZW47XG4gICAgICAgIH0pXSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHggYXhpcyB0aXRsZVxuICAgICAgICBzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHdpZHRoIC8gMilcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA0NSlcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLCBcImJvbGRcIilcbiAgICAgICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgXCIxMHB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxNHB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIkFyaWFsXCIpXG4gICAgICAgICAgICAudGV4dCh4QXhpc1RpdGxlKTtcblxuICAgICAgICAvLyBjcmVhdGUgWSBheGlzIGxhYmVsXG4gICAgICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtOTApXCIpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgMCAtIChtYXJnaW4ubGVmdCAvIDIpKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDAgLSAoaGVpZ2h0IC8gMikpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxNHB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIkFyaWFsXCIpXG4gICAgICAgICAgICAudGV4dCh5QXhpc1RpdGxlKTtcblxuICAgICAgICAvLyBjcmVhdGUgY2hhcnQgdGl0bGVcbiAgICAgICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGggLyAyKSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwIC0gKG1hcmdpbi50b3AgLyA4KSlcbiAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjMwcHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiQXJpYWxcIilcbiAgICAgICAgICAgIC50ZXh0KHBsb3RUaXRsZSk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSB2YWx1ZWxpbmUgcGF0aC5cbiAgICAgICAgc3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5lXCIpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgdmFsdWVsaW5lKGRhdGEpKVxuICAgICAgICAgICAgLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogJ2JsYWNrJyxcbiAgICAgICAgICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogJzJweCcsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgdGhlIFggQXhpc1xuICAgICAgICBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgWSBBeGlzXG4gICAgICAgIHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieSBheGlzXCIpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG5cbiAgICAgICAgc3ZnLnNlbGVjdEFsbChcIi50aWNrID4gdGV4dFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJBcmlhbFwiKTtcblxuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmRvdDJcIilcbiAgICAgICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkb3QyXCIpXG4gICAgICAgICAgICAuYXR0cihcImN4XCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgoZGF0YS5mYWN0b3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geShkYXRhLmVpZ2VuKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInJcIiwgMy41KTtcblxuICAgICAgICBzdmcuc2VsZWN0QWxsKCcuYXhpcyBsbmUsIC5heGlzIHBhdGgnKVxuICAgICAgICAgICAgLnN0eWxlKHtcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogJ2JsYWNrJyxcbiAgICAgICAgICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogJzFweCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIudGljazpub3QoOmZpcnN0LW9mLXR5cGUpIGxpbmVcIikuYXR0cihcInN0cm9rZVwiLCBcImJsYWNrXCIpLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgXCIxcHhcIik7XG4gICAgfTtcblxuXG5cbiAgICAvLyBQTkcgZG93bmxvYWRzIGFkYXB0ZWQgZnJvbSBOaWtpdGEgUm9rb3R5YW4gaHR0cDovL2JsLm9ja3Mub3JnL1Jva290eWFuLzA1NTZmOGZhY2JhZjM0NDUwN2NkYzQ1ZGMzNjIyMTc3XG4gICAgVVRJTC5kb3dubG9hZFBuZ0ltYWdlcyA9IGZ1bmN0aW9uIChzdmdTdHJpbmcsIHN2Z0NoYXJhY3RlcmlzdGljcywgbmFtZUNvbmZpZykge1xuICAgICAgICB2YXIgd2lkdGggPSBwYXJzZUludChzdmdDaGFyYWN0ZXJpc3RpY3Muc3R5bGUoXCJ3aWR0aFwiKSwgMTApICsgMjtcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KHN2Z0NoYXJhY3RlcmlzdGljcy5zdHlsZShcImhlaWdodFwiKSwgMTApO1xuICAgICAgICBzdmdTdHJpbmcySW1hZ2Uoc3ZnU3RyaW5nLCAyICogd2lkdGgsIDIgKiBoZWlnaHQsICdwbmcnLCBzYXZlKTsgLy8gcGFzc2VzIEJsb2IgYW5kIGZpbGVzaXplIFN0cmluZyB0byB0aGUgY2FsbGJhY2tcbiAgICAgICAgdmFyIGZpbGVuYW1lUG5nID0gbmFtZUNvbmZpZyArICcucG5nJztcblxuICAgICAgICBmdW5jdGlvbiBzYXZlKGRhdGFCbG9iLCBmaWxlc2l6ZSkge1xuICAgICAgICAgICAgc2F2ZUFzKGRhdGFCbG9iLCBmaWxlbmFtZVBuZyk7IC8vIEZpbGVTYXZlci5qcyBmdW5jdGlvblxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFVUSUwuZ2V0U1ZHU3RyaW5nID0gZnVuY3Rpb24gKHN2Z05vZGUpIHtcbiAgICAgICAgc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoJ3hsaW5rJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnKTtcbiAgICAgICAgdmFyIGNzc1N0eWxlVGV4dCA9IGdldENTU1N0eWxlcyhzdmdOb2RlKTtcbiAgICAgICAgYXBwZW5kQ1NTKGNzc1N0eWxlVGV4dCwgc3ZnTm9kZSk7XG5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICAgICAgICB2YXIgc3ZnU3RyaW5nID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmdOb2RlKTtcbiAgICAgICAgc3ZnU3RyaW5nID0gc3ZnU3RyaW5nLnJlcGxhY2UoLyhcXHcrKT86P3hsaW5rPS9nLCAneG1sbnM6eGxpbms9Jyk7IC8vIEZpeCByb290IHhsaW5rIHdpdGhvdXQgbmFtZXNwYWNlXG4gICAgICAgIHN2Z1N0cmluZyA9IHN2Z1N0cmluZy5yZXBsYWNlKC9OU1xcZCs6aHJlZi9nLCAneGxpbms6aHJlZicpOyAvLyBTYWZhcmkgTlMgbmFtZXNwYWNlIGZpeFxuXG4gICAgICAgIHJldHVybiBzdmdTdHJpbmc7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q1NTU3R5bGVzKHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvclRleHRBcnIgPSBbXTtcblxuICAgICAgICAgICAgLy8gQWRkIFBhcmVudCBlbGVtZW50IElkIGFuZCBDbGFzc2VzIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICBzZWxlY3RvclRleHRBcnIucHVzaCgnIycgKyBwYXJlbnRFbGVtZW50LmlkKTtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgcGFyZW50RWxlbWVudC5jbGFzc0xpc3QubGVuZ3RoOyBjKyspXG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWlucygnLicgKyBwYXJlbnRFbGVtZW50LmNsYXNzTGlzdFtjXSwgc2VsZWN0b3JUZXh0QXJyKSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JUZXh0QXJyLnB1c2goJy4nICsgcGFyZW50RWxlbWVudC5jbGFzc0xpc3RbY10pO1xuXG4gICAgICAgICAgICAvLyBBZGQgQ2hpbGRyZW4gZWxlbWVudCBJZHMgYW5kIENsYXNzZXMgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHBhcmVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IG5vZGVzW2ldLmlkO1xuICAgICAgICAgICAgICAgIGlmICghY29udGFpbnMoJyMnICsgaWQsIHNlbGVjdG9yVGV4dEFycikpXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yVGV4dEFyci5wdXNoKCcjJyArIGlkKTtcblxuICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gbm9kZXNbaV0uY2xhc3NMaXN0O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2xhc3Nlcy5sZW5ndGg7IGMrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWlucygnLicgKyBjbGFzc2VzW2NdLCBzZWxlY3RvclRleHRBcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JUZXh0QXJyLnB1c2goJy4nICsgY2xhc3Nlc1tjXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgQ1NTIFJ1bGVzXG4gICAgICAgICAgICB2YXIgZXh0cmFjdGVkQ1NTVGV4dCA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBkb2N1bWVudC5zdHlsZVNoZWV0c1tpXTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcy5jc3NSdWxlcykgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5uYW1lICE9PSAnU2VjdXJpdHlFcnJvcicpIHRocm93IGU7IC8vIGZvciBGaXJlZm94XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjc3NSdWxlcyA9IHMuY3NzUnVsZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBjc3NSdWxlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMoY3NzUnVsZXNbcl0uc2VsZWN0b3JUZXh0LCBzZWxlY3RvclRleHRBcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdGVkQ1NTVGV4dCArPSBjc3NSdWxlc1tyXS5jc3NUZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRyYWN0ZWRDU1NUZXh0O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb250YWlucyhzdHIsIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnIuaW5kZXhPZihzdHIpID09PSAtMSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZENTUyhjc3NUZXh0LCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICAgICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0L2Nzc1wiKTtcbiAgICAgICAgICAgIHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBjc3NUZXh0O1xuICAgICAgICAgICAgdmFyIHJlZk5vZGUgPSBlbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSA/IGVsZW1lbnQuY2hpbGRyZW5bMF0gOiBudWxsO1xuICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCByZWZOb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyAqKiBIRUxQRVIgRlVOQ1RJT05TICoqXG4gICAgLy8gc3ZnU3RyaW5nMkltYWdlXG4gICAgZnVuY3Rpb24gc3ZnU3RyaW5nMkltYWdlKHN2Z1N0cmluZywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZm9ybWF0ID0gZm9ybWF0ID8gZm9ybWF0IDogJ3BuZyc7XG4gICAgICAgIHZhciBpbWdzcmMgPSAnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3ZnU3RyaW5nKSkpOyAvLyBDb252ZXJ0IFNWRyBzdHJpbmcgdG8gZGF0YSBVUkxcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNhbnZhcy50b0Jsb2IoZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXNpemUgPSBNYXRoLnJvdW5kKGJsb2IubGVuZ3RoIC8gMTAyNCkgKyAnIEtCJztcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGJsb2IsIGZpbGVzaXplKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZS5zcmMgPSBpbWdzcmM7XG4gICAgfVxuXG5cbn0od2luZG93LlVUSUwgPSB3aW5kb3cuVVRJTCB8fCB7fSwgUUFWKSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvVVRJTC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=')}});