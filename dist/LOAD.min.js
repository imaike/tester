!function(I){function g(A){if(C[A])return C[A].exports;var t=C[A]={i:A,l:!1,exports:{}};return I[A].call(t.exports,t,t.exports,g),t.l=!0,t.exports}var C={};g.m=I,g.c=C,g.i=function(I){return I},g.d=function(I,C,A){g.o(I,C)||Object.defineProperty(I,C,{configurable:!1,enumerable:!0,get:A})},g.n=function(I){var C=I&&I.__esModule?function(){return I.default}:function(){return I};return g.d(C,"a",C),C},g.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},g.p="",g(g.s=7)}({7:function(module,exports){eval('//Ken-Q Analysis\n//Copyright (C) 2016 Shawn Banasick\n//\n//    This program is free software: you can redistribute it and/or modify\n//    it under the terms of the GNU General Public License as published by\n//    the Free Software Foundation, either version 3 of the License, or\n//    (at your option) any later version.\n\n\n// JSlint declarations\n/* global numeric, ROTA, jQuery, resources, alasql, CENTROID, VIEW, window, QAV, $, document, JQuery, evenRound, UTIL, localStorage, _ */\n\n(function(LOAD, QAV, undefined) {\n\n    // custom sorting function for rotation table to get factor grouping in right order\n    (function() {\n        $.extend($.fn.dataTableExt.oSort, {\n            "highestFactor-pre": function(a) {\n\n                var front = a.slice(0, 2);\n                var back = a.slice(3, a.length);\n\n                switch (front) {\n                    case "F1":\n                        return (parseInt(back));\n                    case "F2":\n                        return (parseInt(back) + 300);\n                    case "F3":\n                        return (parseInt(back) + 600);\n                    case "F4":\n                        return (parseInt(back) + 900);\n                    case "F5":\n                        return (parseInt(back) + 1200);\n                    case "F6":\n                        return (parseInt(back) + 1500);\n                    case "F7":\n                        return (parseInt(back) + 1800);\n                    default:\n                        return (parseInt(back) + 2100);\n                }\n            },\n\n            "highestFactor-asc": function(a, b) {\n                return ((a < b) ? -1 : ((a > b) ? 1 : 0));\n            },\n\n            "highestFactor-desc": function(a, b) {\n                return ((a < b) ? 1 : ((a > b) ? -1 : 0));\n            }\n        });\n    })();\n\n    // ****************************************************************** model\n    // *****  split bipolar factors and call dataTable update *****************\n    // ************************************************************************\n\n    // todo - is bipolar split keeping user-inserted flags for table re-draw????\n\n    LOAD.factorSplitFunction = function(factorNumber) {\n\n        // archive current state to undo split if called\n        UTIL.archiveFactorScoreStateMatrixAndDatatable();\n\n        // set split factor flag\n        var hasSplitFactor = (+(QAV.getState("hasSplitFactor")) + 1);\n        QAV.setState("hasSplitFactor", hasSplitFactor);\n\n        // archive headers for undo function chart redraw\n        var archiveHeaders = QAV.getState("factorLabels");\n        localStorage.setItem("splitFactorHeadersArchive" + hasSplitFactor, JSON.stringify(archiveHeaders));\n\n        // get respondent names\n        var results = [];\n        var loopLen1 = QAV.getState("qavRespondentNames").length;\n        var data = $(\'#factorRotationTable2\').DataTable();\n\n        // retrieve column headers\n        var headers = QAV.getState("columnHeadersArray");\n\n        // reconstruct headers\n        var headersIndexLookupArray = [];\n        for (var k = 0; k < headers.length; k++) {\n            var temp = headers[k].title;\n            headersIndexLookupArray.push(temp);\n        }\n\n        // construct look-up value\n        var formattedFactorNumber = "Ftr " + factorNumber;\n        var insertionNumber = headersIndexLookupArray.indexOf(formattedFactorNumber);\n\n        // push just results into new array\n        for (var i = 0; i < loopLen1; i++) {\n            var data2 = data.row(i).data();\n            results.push(data2);\n        }\n\n        // pull in the explnVariance\n        var explnVariance = QAV.getState("expVar");\n\n        // j loop through sorts\n        var listText, j;\n        var loopLength = results.length;\n        for (j = 0; j < loopLength; j++) {\n\n            // grab current values of factor to be split\n            var temp1 = results[j][insertionNumber];\n            var temp1Flag = results[j][insertionNumber + 1];\n\n            // invert signs of new split factor\n            var temp2 = -temp1;\n\n            // remove flag if insertion value is negative\n            if (temp2 < 0) {\n                temp1Flag = "false";\n            }\n\n            // remove flags for original factor if negative\n            if (results[j][insertionNumber] < 0) {\n                results[j][insertionNumber + 1] = "false";\n            }\n\n            // insert the now inverted new factor values\n            results[j].splice(insertionNumber + 2, 0, temp2);\n            results[j].splice(insertionNumber + 3, 0, temp1Flag);\n        }\n\n        // insert gaps for new split factor in explnVariance and eigenvalue rows\n        explnVariance.splice(insertionNumber + 2, 0, "");\n        explnVariance.splice(insertionNumber + 3, 0, "");\n        QAV.setState("expVar", explnVariance);\n\n        // append explnVariance and eigenvalue rows back into table data\n        var negativeFactorName1 = ("Ftr " + factorNumber + "2");\n        var negativeFactorName = negativeFactorName1.toString();\n\n        var positiveFactorName1 = ("Ftr " + factorNumber + "1");\n        var positiveFactorName = positiveFactorName1.toString();\n\n        // copy original header for spliced factor\n        var duplicateName = [{\n            "title": negativeFactorName,\n            class: "dt-head-center dt-body-right"\n        }, {\n            "title": "flag",\n            class: "dt-head-center dt-body-center"\n        }];\n\n        // splice in the name of the split factor\n        headers.splice(insertionNumber + 2, 0, duplicateName[0]);\n        headers.splice(insertionNumber + 3, 0, duplicateName[1]);\n\n        // change original factor name\n        var originalName = [{\n            "title": positiveFactorName,\n            class: "dt-head-center dt-body-right"\n        }, {\n            "title": "flag",\n            class: "dt-head-center dt-body-center"\n        }];\n        headers[insertionNumber] = originalName[0];\n        headers[insertionNumber + 1] = originalName[1];\n\n        // todo - fix double storage issue of headers hack to deal with selection of factors for bipolar split after a previous bipolar split\n\n        // set headers to storage for use by output function cascade (?)\n        QAV.setState("factorLabels", headers);\n        QAV.factorLabels = headers;\n        QAV.setState("columnHeadersArray", headers);\n\n        // redraw rotated factors dataTable\n        bipolarSplitTableRedraw(headers, results, explnVariance);\n\n        // clear output checkboxes\n        VIEW.removeOutputFactorCheckboxes();\n\n        // append bipolar split to the rotation history list\n        var language = QAV.getState("language");\n        var appendText = resources[language].translation.Factor;\n        var appendText2 = resources[language].translation["was split into Factor"];\n        var appendText3 = resources[language].translation["_1p and Factor"];\n        var appendText4 = resources[language].translation._2n;\n        var appendText5 = resources[language].translation.Undo;\n\n        listText = appendText + factorNumber + appendText2 + factorNumber + appendText3 + factorNumber + appendText4;\n        $("#rotationHistoryList").append(\'<li>\' + listText + \'<button class="deleteSplitFactorButton">\' + appendText5 + \'</button></li>\');\n    };\n\n\n\n    // ************************************************************ model-view\n    // *****  invert factor loadings ****************************************\n    // **********************************************************************\n\n    LOAD.factorInvertFunction = function(factorNumber, currentRotationTable) {\n        var listText, newData;\n        // archive factor rotation table\n        UTIL.archiveFactorScoreStateMatrixAndDatatable();\n\n        currentRotationTable = LOAD.invertFactor(factorNumber, currentRotationTable);\n\n        // update Rotation Table Matrix State\n        QAV.setState("rotFacStateArray", currentRotationTable);\n        // prep data for rotation table re-draw\n        newData = LOAD.prepChartDataArray2(currentRotationTable);\n        // re-draw rotation table from matrix state\n        var isRotatedFactorsTableUpdate = "destroy";\n        LOAD.drawRotatedFactorsTable2(isRotatedFactorsTableUpdate, "noFlag");\n\n        var language = QAV.getState("language");\n        var appendText = resources[language].translation.Factor;\n        var appendText2 = resources[language].translation["was inverted"];\n        var appendText3 = resources[language].translation.Undo;\n\n        // append text to rotation history\n        listText = appendText + " " + factorNumber + " " + appendText2;\n        $("#rotationHistoryList").append(\'<li>\' + listText + \'<button class="deleteButton">\' + appendText3 + \'</button></li>\');\n\n        // clear D3 plot and 2 factor chart\n        ROTA.reInitializePlotAndChart();\n        return currentRotationTable;\n    };\n\n    LOAD.invertFactor = function(factorNumber, currentRotationTable) {\n        // change the sign of the factor to invert\n        var loopLength = currentRotationTable.length;\n        var adjustedFactorNumber = factorNumber - 1;\n\n        for (var i = 0; i < loopLength; i++) {\n            currentRotationTable[i][adjustedFactorNumber] = -currentRotationTable[i][adjustedFactorNumber];\n        }\n        return currentRotationTable;\n    };\n\n    // **************************************************************  DATA MODEL\n    // **********  undo split factor rotation insertion *************************\n    // **************************************************************************\n\n    LOAD.undoSplitFactorRotation = function() {\n        var hasSplitFactor = (+(QAV.getState("hasSplitFactor")));\n\n        // reset headers array\n        var headers = JSON.parse(localStorage.getItem("splitFactorHeadersArchive" + hasSplitFactor));\n\n        QAV.setState("factorLabels", headers);\n        QAV.factorLabels = headers;\n        // get counter and data values\n        var getSaveRotationArchiveCounter = ROTA.saveRotationArchiveCounter("get");\n\n        // decrement hasSplitFactor for select factors for output checkboxes\n        hasSplitFactor = hasSplitFactor - 1;\n        QAV.setState("hasSplitFactor", hasSplitFactor);\n\n        // decrement counter\n        if (getSaveRotationArchiveCounter > 1) {\n            ROTA.saveRotationArchiveCounter("decrease");\n        }\n\n        // adjust counter value\n        var retrieveName = getSaveRotationArchiveCounter - 1;\n\n        // get row colors\n        var rowColorsGray = getGrayColors();\n        var rowColorsRainbow = getRainbowColors();\n\n        // get rowbackground and order from DOM user input radio\n        var rowBackground = $("#section6 input[name=state2]:checked").val();\n        var orderingColumn = +($("#section6 input[name=state1]:checked").val());\n\n\n        // retrieve archived data using the now adjusted counter\n        var newData2 = QAV.getState("rotFacStateArrayArchive" + retrieveName);\n\n        // re-set archived data to state matrix ==> "rotFactorStateArray"ip\n        var rotFacStateArrayPrep1 = _.cloneDeep(newData2[0]);\n        QAV.setState("rotFacStateArray", rotFacStateArrayPrep1);\n\n        // pull chart data from retrieved archive array\n        var chartData = newData2[1];\n\n        var explVar = newData2[3];\n        QAV.setState("expVar", explVar);\n\n        // pull headers from retrieved archive array\n        var columnHeadersArray = newData2[2];\n        QAV.setState("columnHeadersArray", columnHeadersArray);\n\n        // set targets from columnHeadersArray\n        var columnTargets = [];\n        var targetLoopLen = columnHeadersArray.length;\n        for (var k = 4; k < targetLoopLen; k += 2) {\n            columnTargets.push(k);\n        }\n\n        var columnTargets2 = [];\n        for (var m = 1; m < targetLoopLen; m += 2) {\n            columnTargets2.push(m);\n        }\n\n        // todo - DRY this out\n        // redraw the rotated factors table\n        var table = $(\'#factorRotationTable2\').DataTable();\n        table.destroy();\n        $(\'#factorRotationTable2\').empty();\n\n        var isUndo = "no";\n\n        LOAD.createFooter("factorRotationTable2", explVar, isUndo);\n\n        table = $("#factorRotationTable2").DataTable({\n            "retrieve": true,\n            "searching": false,\n            "ordering": true,\n            "info": false,\n            //"scrollY": 600,\n            "scrollCollapse": true,\n            "scrollX": true,\n            "paging": false,\n            "order": [\n                [orderingColumn, "asc"]\n            ],\n            "data": chartData,\n            "columns": columnHeadersArray,\n            "columnDefs": [{\n                \'type\': \'highestFactor\',\n                \'targets\': 2\n            }, {\n                \'targets\': columnTargets, // [2, 4, 6, 8, 10, 12, 14],\n                \'searchable\': false,\n                \'orderable\': true,\n                \'render\': function(data, dataIndex) { // (data, type, full, meta) {\n                    if (\n                        data === "") {\n                        return \'<input type="checkbox" class="sigCheckbox" /><label></label>\';\n                    } else {\n                        return \'<input type="checkbox" class="sigCheckbox" id="d\' + dataIndex + \'" value="\' + data + \'" defaultChecked="\' + (data === \'true\' ? \'checked\' : \'\') + \'"\' + (data === \'true\' ? \'checked="checked"\' : \'\') + \' /><label></label>\';\n                    }\n                }\n            }],\n            "createdRow": function(row, data, dataIndex) {\n                var rowGroup;\n                if (rowBackground === "gray") {\n                    rowGroup = data[2].slice(0, 2);\n                    //var rowGroupColor = (rowColorsGray[rowGroup]).toString();\n                    $(\'td\', row).css(\'background-color\', rowColorsGray[rowGroup]);\n                } else if (rowBackground === "colors") {\n                    rowGroup = data[2].slice(0, 2);\n                    //var rowGroupColor = (rowColorsGray[rowGroup]).toString();\n                    $(\'td\', row).css(\'background-color\', rowColorsRainbow[rowGroup]);\n                }\n            }\n        });\n\n        // clear out the 2 factor rotation chart and D3 plot\n        // reInitializePlotAndChart();\n        $("#chartAndTableDisplayContainer").hide();\n\n        // clear output checkboxes\n        VIEW.removeOutputFactorCheckboxes();\n\n        // todo - check to see if firefox still needs this\n        return false;\n    };\n\n    // ******************************************************************* view\n    // **********  draw rotated factors table using jquery dataTables   *******\n    // ************************************************************************\n\n    LOAD.drawRotatedFactorsTable2 = function(isRotatedFactorsTableUpdate, shouldFlag) {\n\n        // pull current table state from global variable\n        var chartData = QAV.getState("rotFacStateArray");\n\n        // format data for table\n        var newData = LOAD.prepChartDataArray2(chartData);\n\n        // pull out explVar\n        var expVar2 = QAV.getState("expVar");\n\n        // pull out eigenvalues data\n        newData.pop();\n\n        // get row colors\n        var rowColorsGray = getGrayColors();\n        var rowColorsRainbow = getRainbowColors();\n\n        // get rowbackground and order from DOM user input radio\n        var rowBackground = $("#section6 input[name=state2]:checked").val();\n        var orderingColumn = +($("#section6 input[name=state1]:checked").val());\n\n        // var declarations\n        var loopLength = chartData[0].length + 1;\n        var temp;\n        var columnHeadersArray = [];\n\n        ROTA.calculateFactorLoadingSignificanceLevel();\n\n        columnHeadersArray.push({\n            title: \'No.\',\n            class: "dt-head-center dt-body-center"\n        }, {\n            title: \'Respond.\',\n            class: \'dt-head-center dt-body-center\'\n        }, {\n            title: \'FG\',\n            class: "dt-head-center dt-body-center"\n        });\n\n        for (var i = 1; i < loopLength; i++) {\n\n            temp = {\n                title: \'Ftr \' + i,\n                class: "dt-head-center dt-body-right"\n            };\n            columnHeadersArray.push(temp);\n            columnHeadersArray.push({\n                title: \'flag\',\n                class: "dt-head-center dt-body-center"\n            });\n        }\n        columnHeadersArray.push({\n            title: \'h<sup>2</sup>\',\n            class: "dt-head-center dt-body-right"\n        });\n\n        QAV.setState("columnHeadersArray", columnHeadersArray);\n\n        var columnTargets = [];\n        var targetLoopLen = columnHeadersArray.length;\n        for (var k = 4; k < targetLoopLen; k += 2) {\n            columnTargets.push(k);\n        }\n\n        var columnTargets2 = [];\n        for (var m = 1; m < targetLoopLen; m += 2) {\n            columnTargets2.push(m);\n        }\n\n        // if table, remove from DOM and draw table\n        var table, factorSortedData;\n\n        if (isRotatedFactorsTableUpdate === "highlighter") {\n            factorSortedData = QAV.colorButtonChartData;\n            // unload that heavy property\n            QAV.colorButtonChartData = "";\n        } else {\n            factorSortedData = LOAD.rotationTableSortByFactor(newData);\n        }\n\n        var isUndo = "no";\n        LOAD.createFooter("factorRotationTable2", expVar2, isUndo);\n\n\n        // todo - temporarily disabled update because autoflagging issues\n        if (isRotatedFactorsTableUpdate === "yes") {\n\n\n            table = $(\'#factorRotationTable2\').DataTable();\n            table.clear();\n\n            LOAD.createFooter("factorRotationTable2", expVar2, isUndo);\n\n            table.rows.add(factorSortedData).draw();\n\n        } else if (isRotatedFactorsTableUpdate === "destroy") {\n\n            table = $(\'#factorRotationTable2\').DataTable();\n            table.destroy();\n            $(\'#factorRotationTable2\').empty();\n\n            LOAD.createFooter("factorRotationTable2", expVar2, "no");\n\n            table = $("#factorRotationTable2").DataTable({\n                "retrieve": true,\n                "searching": false,\n                "ordering": true,\n                "info": false,\n                // "scrollY": 600,\n                "scrollCollapse": true,\n                "scrollX": true,\n                "paging": false,\n                "order": [\n                    [orderingColumn, "asc"]\n                ],\n                "data": factorSortedData,\n                "columns": columnHeadersArray,\n                "columnDefs": [{\n                    \'type\': \'highestFactor\',\n                    \'targets\': 2\n                }, {\n                    \'targets\': columnTargets, // [ 4, 6, 8, 10, 12, 14, 16],\n                    \'searchable\': false,\n                    \'orderable\': true,\n                    \'render\': function(data, dataIndex) { // (data, type, full, meta) {\n                        if (\n                            data === "") {\n                            return "";\n                        } else if (shouldFlag === "flag") {\n\n                            return \'<input type="checkbox" class="sigCheckbox" id="d\' + dataIndex + \'" value="\' + data + \'" defaultChecked="\' + (data === \'true\' ? \'checked\' : \'\') + \'"\' + (data === \'true\' ? \'checked="checked"\' : \'\') + \' /><label></label>\';\n                        } else {\n                            return \'<input type="checkbox" class="sigCheckbox" /><label></label>\';\n                        }\n                    }\n                }],\n                "createdRow": function(row, data, dataIndex) {\n                    var rowGroup;\n                    if (rowBackground === "gray") {\n                        rowGroup = data[2].slice(0, 2);\n                        //var rowGroupColor = (rowColorsGray[rowGroup]).toString();\n                        $(\'td\', row).css(\'background-color\', rowColorsGray[rowGroup]);\n                    } else if (rowBackground === "colors") {\n                        rowGroup = data[2].slice(0, 2);\n                        //var rowGroupColor = (rowColorsGray[rowGroup]).toString();\n                        $(\'td\', row).css(\'background-color\', rowColorsRainbow[rowGroup]);\n                    }\n                }\n            });\n        } else {\n\n            // added for color button\n            if (isRotatedFactorsTableUpdate === "highlighter") {\n                table = $(\'#factorRotationTable2\').DataTable();\n                table.destroy();\n                $(\'#factorRotationTable2\').empty();\n                LOAD.createFooter("factorRotationTable2", expVar2, "no");\n            }\n            table = $("#factorRotationTable2").DataTable({\n                "retrieve": true,\n                "searching": false,\n                "ordering": true,\n                "info": false,\n                // "scrollY": 600,\n                "scrollCollapse": true,\n                "scrollX": true,\n                "paging": false,\n                "order": [\n                    [orderingColumn, "asc"]\n                ],\n                "data": factorSortedData,\n                "columns": columnHeadersArray,\n                "columnDefs": [{\n                    \'type\': \'highestFactor\',\n                    \'targets\': 2\n                }, {\n                    \'targets\': columnTargets, // [2, 4, 6, 8, 10, 12, 14],\n                    \'searchable\': false,\n                    \'orderable\': true,\n                    \'render\': function(data, dataIndex) { // (data, type, full, meta) {\n                        if (data === "") {\n                            return \'<input type="checkbox" class="sigCheckbox" /><label></label>\';\n                        } else {\n                            return \'<input type="checkbox" class="sigCheckbox" id="d\' + dataIndex + \'" value="\' + data + \'" defaultChecked="\' + (data === \'true\' ? \'checked\' : \'\') + \'"\' + (data === \'true\' ? \'checked="checked"\' : \'\') + \' /><label></label>\';\n                        }\n                    }\n                }],\n                "createdRow": function(row, data, dataIndex) {\n                    var rowGroup;\n                    if (rowBackground === "gray") {\n                        rowGroup = data[2].slice(0, 2);\n                        //var rowGroupColor = (rowColorsGray[rowGroup]).toString();\n                        $(\'td\', row).css(\'background-color\', rowColorsGray[rowGroup]);\n                    } else if (rowBackground === "colors") {\n                        rowGroup = data[2].slice(0, 2);\n                        //var rowGroupColor = (rowColorsGray[rowGroup]).toString();\n                        $(\'td\', row).css(\'background-color\', rowColorsRainbow[rowGroup]);\n                    }\n                }\n            });\n        }\n    };\n\n\n\n    LOAD.createFooter = function(element, expVar2, isUndo) {\n        var hasFooter = $("#factorRotationTable2 tfoot");\n        var checkFooter = ((hasFooter.text()));\n\n        if (checkFooter.length !== 0 || isUndo === "yes") {\n\n            var table = $(\'#factorRotationTable2\').DataTable();\n\n            for (var g = 0; g < expVar2.length; g++) {\n                var column = table.column(g);\n                $(column.footer()).html(expVar2[g]);\n            }\n        } else {\n            var footer = document.createElement(\'tfoot\');\n            var tr = document.createElement(\'tr\');\n\n            jQuery.each(expVar2, function(i, value) {\n                var th = document.createElement(\'th\');\n                th.innerHTML = value;\n                tr.appendChild(th);\n            });\n            footer.appendChild(tr);\n            document.getElementById(element).appendChild(footer);\n        }\n    };\n\n\n    // ************************************************************  DATA MODEL\n    // **********  undo factor rotation insertion ****************************\n    // ***********************************************************************\n    LOAD.undoFactorRotation = function() {\n\n        // get counter and data values\n        var getSaveRotationArchiveCounter = ROTA.saveRotationArchiveCounter("get");\n\n        // decrement counter\n        if (getSaveRotationArchiveCounter > 1) {\n            ROTA.saveRotationArchiveCounter("decrease");\n        }\n\n        // adjust counter value\n        var retrieveName = getSaveRotationArchiveCounter - 1;\n\n        // retrieve archived data using the now adjusted counter\n        var newData2 = QAV.getState("rotFacStateArrayArchive" + retrieveName);\n\n        // re-set archived data to state matrix ==> "rotFactorStateArray"ip\n        var rotFacStateArrayPrep1 = _.cloneDeep(newData2[0]);\n        QAV.setState("rotFacStateArray", rotFacStateArrayPrep1);\n\n        // pull chart data from retrieved archive array\n        var chartData = newData2[1];\n\n        var explVar = newData2[3];\n        QAV.setState("expVar", explVar);\n\n        var isUndo = "yes";\n\n        LOAD.createFooter("factorRotationTable2", explVar, isUndo);\n\n        // redraw the rotated factors table\n        var table = $(\'#factorRotationTable2\').DataTable();\n        table.clear();\n        table.rows.add(chartData).draw();\n\n        // clear out the 2 factor rotation chart and D3 plot\n        ROTA.reInitializePlotAndChart();\n    };\n\n    // ******************************************************  DATA MODEL\n    // **** chartData ARRAY TO resultsArray OBJECT FOR datatables *******\n    // ******************************************************************\n    LOAD.prepChartDataArray2 = function(chartData) {\n        var arrayLength = chartData.length;\n        var arrayLength2 = chartData[0].length;\n        var resultsArray = [];\n        var respondentNames = QAV.getState("qavRespondentNames");\n        var fSig = QAV.getState("fSigCriterionResults");\n        var rowH2 = QAV.getState("rowH2");\n\n        for (var j = 0; j < arrayLength; j++) {\n            var tempObj2 = [];\n            tempObj2.push(respondentNames[j]);\n\n            for (var m = 0; m < arrayLength2; m++) {\n                tempObj2.push(chartData[j][m]);\n                tempObj2.push(fSig[j][m]);\n            }\n            tempObj2.push(rowH2[j]);\n            resultsArray.push(tempObj2);\n        }\n        // calculate eigenvalues and variance and add to results array\n        var eigenvaluesAndVariance = ROTA.calculateEigenvaluesAndVariance2();\n        resultsArray.push(eigenvaluesAndVariance[0]);\n        return resultsArray;\n    };\n\n    LOAD.rotationTableSortByFactor = function(newData) {\n        var sortingArray = [];\n        var factorSortedData = [];\n        var tempObj;\n        var newData2 = _.cloneDeep(newData);\n\n        for (var i = 0, iLen = newData.length; i < iLen; i++) {\n            tempObj = {};\n            newData2[i].pop();\n            var pullNumbers = _.pick(newData2[i], _.isNumber);\n\n            tempObj.maxValue = _.max(pullNumbers);\n            tempObj.minValue = _.min(pullNumbers);\n            tempObj.sortNum = (i + 1);\n            tempObj.compareValue = (Math.abs(tempObj.maxValue) - Math.abs(tempObj.minValue));\n            if (tempObj.compareValue >= 0) {\n                tempObj.indexValue = _.indexOf(newData[i], tempObj.maxValue);\n                tempObj.subSortValue = tempObj.maxValue;\n            } else {\n                tempObj.indexValue = _.indexOf(newData[i], tempObj.minValue);\n                tempObj.subSortValue = Math.abs(tempObj.minValue);\n            }\n            tempObj.sort = newData[i];\n            sortingArray.push(tempObj);\n        }\n\n        var factorSortedArray = _.cloneDeep(sortingArray);\n        // sort object by two properties\n        factorSortedArray.sort(function(a, b) {\n            var value = a.indexValue - b.indexValue;\n            return value ? value : b.subSortValue - a.subSortValue;\n        });\n\n        var modifiedIndexValue = {\n            1: 1,\n            3: 2,\n            5: 3,\n            7: 4,\n            9: 5,\n            11: 6,\n            13: 7,\n            15: 8\n        };\n\n        var factorGroupNumber, lookUpIndexValue;\n        var subGroupCounter = 0;\n        for (var j = 0, jLen = factorSortedArray.length; j < jLen; j++) {\n            lookUpIndexValue = (factorSortedArray[j].indexValue);\n            if (j === 0 || lookUpIndexValue === factorSortedArray[j - 1].indexValue) {\n                subGroupCounter = subGroupCounter + 1;\n            } else {\n                subGroupCounter = 1;\n            }\n            factorGroupNumber = "F" + modifiedIndexValue[lookUpIndexValue] + "-" + subGroupCounter;\n            factorSortedArray[j].sort.splice(1, 0, factorGroupNumber);\n            factorSortedArray[j].sort.unshift(factorSortedArray[j].sortNum);\n            factorSortedData.push(factorSortedArray[j].sort);\n        }\n        return factorSortedData;\n    };\n\n    // **************************************************************  Data Model\n    // **********  set background colors of factor loading table ****************\n    // **************************************************************************\n    function getRainbowColors() {\n        var rowColorsRainbow = {\n            "F1": "#f7fcf0",\n            "F2": "#e0f3db",\n            "F3": "#ccebc5",\n            "F4": "#a8ddb5",\n            "F5": "#7bccc4",\n            "F6": "#4eb3d3",\n            "F7": "#2b8cbe",\n            "F8": "#9cbbd7"\n        };\n        return rowColorsRainbow;\n    }\n\n    function getGrayColors() {\n        var rowColorsGray = {\n            "F1": "#ffffff",\n            "F2": "#f0f0f0",\n            "F3": "#d9d9d9",\n            "F4": "#bdbdbd",\n            "F5": "#969696",\n            "F6": "#737373",\n            "F7": "#d9d9d9",\n            "F8": "whitesmoke"\n        };\n        return rowColorsGray;\n    }\n\n    // *********************************************************************** view\n    // *****  draw bipolar split rotated factors table using jquery dataTables ****\n    // ****************************************************************************\n\n    function bipolarSplitTableRedraw(headers, results, explVar) {\n\n        // get column ids for table formatting\n        var columnTargets = [];\n        var targetLoopLen = headers.length;\n        for (var k = 4; k < targetLoopLen; k += 2) {\n            columnTargets.push(k);\n        }\n        var columnTargets2 = [];\n        for (var m = 1; m < targetLoopLen; m += 2) {\n            columnTargets2.push(m);\n        }\n\n        // remove previous table and headers from DOM\n        var table = $(\'#factorRotationTable2\').DataTable();\n        table.destroy();\n        $(\'#factorRotationTable2\').empty();\n\n        var isUndo = "no";\n        LOAD.createFooter("factorRotationTable2", explVar, isUndo);\n\n        // get row colors\n        var rowColorsGray = getGrayColors();\n        var rowColorsRainbow = getRainbowColors();\n\n        // get rowbackground and order from DOM user input radio\n        var rowBackground = $("#section6 input[name=state2]:checked").val();\n        var orderingColumn = +($("#section6 input[name=state1]:checked").val());\n\n        // draw new table\n        table = $(\'#factorRotationTable2\').DataTable({\n            "retrieve": true,\n            "searching": false,\n            "ordering": true,\n            "info": false,\n            //"scrollY": 600,\n            // "scrollY": "auto",\n            "scrollCollapse": true,\n            "scrollX": true,\n            "paging": false,\n            "order": [\n                [orderingColumn, "asc"]\n            ],\n            "data": results,\n            "columns": headers,\n            "columnDefs": [{\n                \'type\': \'highestFactor\',\n                \'targets\': 2\n            }, {\n                \'targets\': columnTargets2, // todo - find out if this is working properly\n                \'className\': \'dt-body-right\',\n                \'orderable\': true,\n            }, {\n                \'targets\': [0],\n                \'className\': \'dt-body-center dt-body-name\',\n                \'orderable\': true\n            }, {\n                \'targets\': columnTargets, // [2, 4, 6, 8, 10, 12, 14],\n                \'searchable\': false,\n                \'orderable\': true,\n                \'className\': \'dt-body-right\',\n                \'render\': function(data, dataIndex) { // (data, type, full, meta) {\n                    if (\n                        data === "") {\n                        return \'<input type="checkbox" class="sigCheckbox" /><label></label>\';\n                    } else {\n                        return \'<input type="checkbox" class="sigCheckbox" id="d\' + dataIndex + \'" value="\' + data + \'" defaultChecked="\' + (data === \'true\' ? \'checked\' : \'\') + \'"\' + (data === \'true\' ? \'checked="checked"\' : \'\') + \' /><label></label>\';\n                    }\n                }\n            }],\n            "createdRow": function(row, data, dataIndex) {\n                var rowGroup;\n                if (rowBackground === "gray") {\n                    rowGroup = data[2].slice(0, 2);\n                    //var rowGroupColor = (rowColorsGray[rowGroup]).toString();\n                    $(\'td\', row).css(\'background-color\', rowColorsGray[rowGroup]);\n                } else if (rowBackground === "colors") {\n                    rowGroup = data[2].slice(0, 2);\n                    //var rowGroupColor = (rowColorsGray[rowGroup]).toString();\n                    $(\'td\', row).css(\'background-color\', rowColorsRainbow[rowGroup]);\n                }\n            }\n        });\n    }\n\n}(window.LOAD = window.LOAD || {}, QAV));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9MT0FELmpzPzY1MjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy9LZW4tUSBBbmFseXNpc1xuLy9Db3B5cmlnaHQgKEMpIDIwMTYgU2hhd24gQmFuYXNpY2tcbi8vXG4vLyAgICBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG5cbi8vIEpTbGludCBkZWNsYXJhdGlvbnNcbi8qIGdsb2JhbCBudW1lcmljLCBST1RBLCBqUXVlcnksIHJlc291cmNlcywgYWxhc3FsLCBDRU5UUk9JRCwgVklFVywgd2luZG93LCBRQVYsICQsIGRvY3VtZW50LCBKUXVlcnksIGV2ZW5Sb3VuZCwgVVRJTCwgbG9jYWxTdG9yYWdlLCBfICovXG5cbihmdW5jdGlvbihMT0FELCBRQVYsIHVuZGVmaW5lZCkge1xuXG4gICAgLy8gY3VzdG9tIHNvcnRpbmcgZnVuY3Rpb24gZm9yIHJvdGF0aW9uIHRhYmxlIHRvIGdldCBmYWN0b3IgZ3JvdXBpbmcgaW4gcmlnaHQgb3JkZXJcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICQuZXh0ZW5kKCQuZm4uZGF0YVRhYmxlRXh0Lm9Tb3J0LCB7XG4gICAgICAgICAgICBcImhpZ2hlc3RGYWN0b3ItcHJlXCI6IGZ1bmN0aW9uKGEpIHtcblxuICAgICAgICAgICAgICAgIHZhciBmcm9udCA9IGEuc2xpY2UoMCwgMik7XG4gICAgICAgICAgICAgICAgdmFyIGJhY2sgPSBhLnNsaWNlKDMsIGEubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZnJvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkYxXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnNlSW50KGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkYyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnNlSW50KGJhY2spICsgMzAwKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkYzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnNlSW50KGJhY2spICsgNjAwKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkY0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnNlSW50KGJhY2spICsgOTAwKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkY1XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnNlSW50KGJhY2spICsgMTIwMCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJGNlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwYXJzZUludChiYWNrKSArIDE1MDApO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRjdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocGFyc2VJbnQoYmFjaykgKyAxODAwKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocGFyc2VJbnQoYmFjaykgKyAyMTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBcImhpZ2hlc3RGYWN0b3ItYXNjXCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChhIDwgYikgPyAtMSA6ICgoYSA+IGIpID8gMSA6IDApKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIFwiaGlnaGVzdEZhY3Rvci1kZXNjXCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChhIDwgYikgPyAxIDogKChhID4gYikgPyAtMSA6IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkoKTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBtb2RlbFxuICAgIC8vICoqKioqICBzcGxpdCBiaXBvbGFyIGZhY3RvcnMgYW5kIGNhbGwgZGF0YVRhYmxlIHVwZGF0ZSAqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLy8gdG9kbyAtIGlzIGJpcG9sYXIgc3BsaXQga2VlcGluZyB1c2VyLWluc2VydGVkIGZsYWdzIGZvciB0YWJsZSByZS1kcmF3Pz8/P1xuXG4gICAgTE9BRC5mYWN0b3JTcGxpdEZ1bmN0aW9uID0gZnVuY3Rpb24oZmFjdG9yTnVtYmVyKSB7XG5cbiAgICAgICAgLy8gYXJjaGl2ZSBjdXJyZW50IHN0YXRlIHRvIHVuZG8gc3BsaXQgaWYgY2FsbGVkXG4gICAgICAgIFVUSUwuYXJjaGl2ZUZhY3RvclNjb3JlU3RhdGVNYXRyaXhBbmREYXRhdGFibGUoKTtcblxuICAgICAgICAvLyBzZXQgc3BsaXQgZmFjdG9yIGZsYWdcbiAgICAgICAgdmFyIGhhc1NwbGl0RmFjdG9yID0gKCsoUUFWLmdldFN0YXRlKFwiaGFzU3BsaXRGYWN0b3JcIikpICsgMSk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcImhhc1NwbGl0RmFjdG9yXCIsIGhhc1NwbGl0RmFjdG9yKTtcblxuICAgICAgICAvLyBhcmNoaXZlIGhlYWRlcnMgZm9yIHVuZG8gZnVuY3Rpb24gY2hhcnQgcmVkcmF3XG4gICAgICAgIHZhciBhcmNoaXZlSGVhZGVycyA9IFFBVi5nZXRTdGF0ZShcImZhY3RvckxhYmVsc1wiKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzcGxpdEZhY3RvckhlYWRlcnNBcmNoaXZlXCIgKyBoYXNTcGxpdEZhY3RvciwgSlNPTi5zdHJpbmdpZnkoYXJjaGl2ZUhlYWRlcnMpKTtcblxuICAgICAgICAvLyBnZXQgcmVzcG9uZGVudCBuYW1lc1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgbG9vcExlbjEgPSBRQVYuZ2V0U3RhdGUoXCJxYXZSZXNwb25kZW50TmFtZXNcIikubGVuZ3RoO1xuICAgICAgICB2YXIgZGF0YSA9ICQoJyNmYWN0b3JSb3RhdGlvblRhYmxlMicpLkRhdGFUYWJsZSgpO1xuXG4gICAgICAgIC8vIHJldHJpZXZlIGNvbHVtbiBoZWFkZXJzXG4gICAgICAgIHZhciBoZWFkZXJzID0gUUFWLmdldFN0YXRlKFwiY29sdW1uSGVhZGVyc0FycmF5XCIpO1xuXG4gICAgICAgIC8vIHJlY29uc3RydWN0IGhlYWRlcnNcbiAgICAgICAgdmFyIGhlYWRlcnNJbmRleExvb2t1cEFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaGVhZGVycy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBoZWFkZXJzW2tdLnRpdGxlO1xuICAgICAgICAgICAgaGVhZGVyc0luZGV4TG9va3VwQXJyYXkucHVzaCh0ZW1wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnN0cnVjdCBsb29rLXVwIHZhbHVlXG4gICAgICAgIHZhciBmb3JtYXR0ZWRGYWN0b3JOdW1iZXIgPSBcIkZ0ciBcIiArIGZhY3Rvck51bWJlcjtcbiAgICAgICAgdmFyIGluc2VydGlvbk51bWJlciA9IGhlYWRlcnNJbmRleExvb2t1cEFycmF5LmluZGV4T2YoZm9ybWF0dGVkRmFjdG9yTnVtYmVyKTtcblxuICAgICAgICAvLyBwdXNoIGp1c3QgcmVzdWx0cyBpbnRvIG5ldyBhcnJheVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvb3BMZW4xOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkYXRhMiA9IGRhdGEucm93KGkpLmRhdGEoKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChkYXRhMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwdWxsIGluIHRoZSBleHBsblZhcmlhbmNlXG4gICAgICAgIHZhciBleHBsblZhcmlhbmNlID0gUUFWLmdldFN0YXRlKFwiZXhwVmFyXCIpO1xuXG4gICAgICAgIC8vIGogbG9vcCB0aHJvdWdoIHNvcnRzXG4gICAgICAgIHZhciBsaXN0VGV4dCwgajtcbiAgICAgICAgdmFyIGxvb3BMZW5ndGggPSByZXN1bHRzLmxlbmd0aDtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxvb3BMZW5ndGg7IGorKykge1xuXG4gICAgICAgICAgICAvLyBncmFiIGN1cnJlbnQgdmFsdWVzIG9mIGZhY3RvciB0byBiZSBzcGxpdFxuICAgICAgICAgICAgdmFyIHRlbXAxID0gcmVzdWx0c1tqXVtpbnNlcnRpb25OdW1iZXJdO1xuICAgICAgICAgICAgdmFyIHRlbXAxRmxhZyA9IHJlc3VsdHNbal1baW5zZXJ0aW9uTnVtYmVyICsgMV07XG5cbiAgICAgICAgICAgIC8vIGludmVydCBzaWducyBvZiBuZXcgc3BsaXQgZmFjdG9yXG4gICAgICAgICAgICB2YXIgdGVtcDIgPSAtdGVtcDE7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBmbGFnIGlmIGluc2VydGlvbiB2YWx1ZSBpcyBuZWdhdGl2ZVxuICAgICAgICAgICAgaWYgKHRlbXAyIDwgMCkge1xuICAgICAgICAgICAgICAgIHRlbXAxRmxhZyA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGZsYWdzIGZvciBvcmlnaW5hbCBmYWN0b3IgaWYgbmVnYXRpdmVcbiAgICAgICAgICAgIGlmIChyZXN1bHRzW2pdW2luc2VydGlvbk51bWJlcl0gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tqXVtpbnNlcnRpb25OdW1iZXIgKyAxXSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBub3cgaW52ZXJ0ZWQgbmV3IGZhY3RvciB2YWx1ZXNcbiAgICAgICAgICAgIHJlc3VsdHNbal0uc3BsaWNlKGluc2VydGlvbk51bWJlciArIDIsIDAsIHRlbXAyKTtcbiAgICAgICAgICAgIHJlc3VsdHNbal0uc3BsaWNlKGluc2VydGlvbk51bWJlciArIDMsIDAsIHRlbXAxRmxhZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbnNlcnQgZ2FwcyBmb3IgbmV3IHNwbGl0IGZhY3RvciBpbiBleHBsblZhcmlhbmNlIGFuZCBlaWdlbnZhbHVlIHJvd3NcbiAgICAgICAgZXhwbG5WYXJpYW5jZS5zcGxpY2UoaW5zZXJ0aW9uTnVtYmVyICsgMiwgMCwgXCJcIik7XG4gICAgICAgIGV4cGxuVmFyaWFuY2Uuc3BsaWNlKGluc2VydGlvbk51bWJlciArIDMsIDAsIFwiXCIpO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJleHBWYXJcIiwgZXhwbG5WYXJpYW5jZSk7XG5cbiAgICAgICAgLy8gYXBwZW5kIGV4cGxuVmFyaWFuY2UgYW5kIGVpZ2VudmFsdWUgcm93cyBiYWNrIGludG8gdGFibGUgZGF0YVxuICAgICAgICB2YXIgbmVnYXRpdmVGYWN0b3JOYW1lMSA9IChcIkZ0ciBcIiArIGZhY3Rvck51bWJlciArIFwiMlwiKTtcbiAgICAgICAgdmFyIG5lZ2F0aXZlRmFjdG9yTmFtZSA9IG5lZ2F0aXZlRmFjdG9yTmFtZTEudG9TdHJpbmcoKTtcblxuICAgICAgICB2YXIgcG9zaXRpdmVGYWN0b3JOYW1lMSA9IChcIkZ0ciBcIiArIGZhY3Rvck51bWJlciArIFwiMVwiKTtcbiAgICAgICAgdmFyIHBvc2l0aXZlRmFjdG9yTmFtZSA9IHBvc2l0aXZlRmFjdG9yTmFtZTEudG9TdHJpbmcoKTtcblxuICAgICAgICAvLyBjb3B5IG9yaWdpbmFsIGhlYWRlciBmb3Igc3BsaWNlZCBmYWN0b3JcbiAgICAgICAgdmFyIGR1cGxpY2F0ZU5hbWUgPSBbe1xuICAgICAgICAgICAgXCJ0aXRsZVwiOiBuZWdhdGl2ZUZhY3Rvck5hbWUsXG4gICAgICAgICAgICBjbGFzczogXCJkdC1oZWFkLWNlbnRlciBkdC1ib2R5LXJpZ2h0XCJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJ0aXRsZVwiOiBcImZsYWdcIixcbiAgICAgICAgICAgIGNsYXNzOiBcImR0LWhlYWQtY2VudGVyIGR0LWJvZHktY2VudGVyXCJcbiAgICAgICAgfV07XG5cbiAgICAgICAgLy8gc3BsaWNlIGluIHRoZSBuYW1lIG9mIHRoZSBzcGxpdCBmYWN0b3JcbiAgICAgICAgaGVhZGVycy5zcGxpY2UoaW5zZXJ0aW9uTnVtYmVyICsgMiwgMCwgZHVwbGljYXRlTmFtZVswXSk7XG4gICAgICAgIGhlYWRlcnMuc3BsaWNlKGluc2VydGlvbk51bWJlciArIDMsIDAsIGR1cGxpY2F0ZU5hbWVbMV0pO1xuXG4gICAgICAgIC8vIGNoYW5nZSBvcmlnaW5hbCBmYWN0b3IgbmFtZVxuICAgICAgICB2YXIgb3JpZ2luYWxOYW1lID0gW3tcbiAgICAgICAgICAgIFwidGl0bGVcIjogcG9zaXRpdmVGYWN0b3JOYW1lLFxuICAgICAgICAgICAgY2xhc3M6IFwiZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1yaWdodFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwidGl0bGVcIjogXCJmbGFnXCIsXG4gICAgICAgICAgICBjbGFzczogXCJkdC1oZWFkLWNlbnRlciBkdC1ib2R5LWNlbnRlclwiXG4gICAgICAgIH1dO1xuICAgICAgICBoZWFkZXJzW2luc2VydGlvbk51bWJlcl0gPSBvcmlnaW5hbE5hbWVbMF07XG4gICAgICAgIGhlYWRlcnNbaW5zZXJ0aW9uTnVtYmVyICsgMV0gPSBvcmlnaW5hbE5hbWVbMV07XG5cbiAgICAgICAgLy8gdG9kbyAtIGZpeCBkb3VibGUgc3RvcmFnZSBpc3N1ZSBvZiBoZWFkZXJzIGhhY2sgdG8gZGVhbCB3aXRoIHNlbGVjdGlvbiBvZiBmYWN0b3JzIGZvciBiaXBvbGFyIHNwbGl0IGFmdGVyIGEgcHJldmlvdXMgYmlwb2xhciBzcGxpdFxuXG4gICAgICAgIC8vIHNldCBoZWFkZXJzIHRvIHN0b3JhZ2UgZm9yIHVzZSBieSBvdXRwdXQgZnVuY3Rpb24gY2FzY2FkZSAoPylcbiAgICAgICAgUUFWLnNldFN0YXRlKFwiZmFjdG9yTGFiZWxzXCIsIGhlYWRlcnMpO1xuICAgICAgICBRQVYuZmFjdG9yTGFiZWxzID0gaGVhZGVycztcbiAgICAgICAgUUFWLnNldFN0YXRlKFwiY29sdW1uSGVhZGVyc0FycmF5XCIsIGhlYWRlcnMpO1xuXG4gICAgICAgIC8vIHJlZHJhdyByb3RhdGVkIGZhY3RvcnMgZGF0YVRhYmxlXG4gICAgICAgIGJpcG9sYXJTcGxpdFRhYmxlUmVkcmF3KGhlYWRlcnMsIHJlc3VsdHMsIGV4cGxuVmFyaWFuY2UpO1xuXG4gICAgICAgIC8vIGNsZWFyIG91dHB1dCBjaGVja2JveGVzXG4gICAgICAgIFZJRVcucmVtb3ZlT3V0cHV0RmFjdG9yQ2hlY2tib3hlcygpO1xuXG4gICAgICAgIC8vIGFwcGVuZCBiaXBvbGFyIHNwbGl0IHRvIHRoZSByb3RhdGlvbiBoaXN0b3J5IGxpc3RcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5GYWN0b3I7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJ3YXMgc3BsaXQgaW50byBGYWN0b3JcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MyA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJfMXAgYW5kIEZhY3RvclwiXTtcbiAgICAgICAgdmFyIGFwcGVuZFRleHQ0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5fMm47XG4gICAgICAgIHZhciBhcHBlbmRUZXh0NSA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uVW5kbztcblxuICAgICAgICBsaXN0VGV4dCA9IGFwcGVuZFRleHQgKyBmYWN0b3JOdW1iZXIgKyBhcHBlbmRUZXh0MiArIGZhY3Rvck51bWJlciArIGFwcGVuZFRleHQzICsgZmFjdG9yTnVtYmVyICsgYXBwZW5kVGV4dDQ7XG4gICAgICAgICQoXCIjcm90YXRpb25IaXN0b3J5TGlzdFwiKS5hcHBlbmQoJzxsaT4nICsgbGlzdFRleHQgKyAnPGJ1dHRvbiBjbGFzcz1cImRlbGV0ZVNwbGl0RmFjdG9yQnV0dG9uXCI+JyArIGFwcGVuZFRleHQ1ICsgJzwvYnV0dG9uPjwvbGk+Jyk7XG4gICAgfTtcblxuXG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogbW9kZWwtdmlld1xuICAgIC8vICoqKioqICBpbnZlcnQgZmFjdG9yIGxvYWRpbmdzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBMT0FELmZhY3RvckludmVydEZ1bmN0aW9uID0gZnVuY3Rpb24oZmFjdG9yTnVtYmVyLCBjdXJyZW50Um90YXRpb25UYWJsZSkge1xuICAgICAgICB2YXIgbGlzdFRleHQsIG5ld0RhdGE7XG4gICAgICAgIC8vIGFyY2hpdmUgZmFjdG9yIHJvdGF0aW9uIHRhYmxlXG4gICAgICAgIFVUSUwuYXJjaGl2ZUZhY3RvclNjb3JlU3RhdGVNYXRyaXhBbmREYXRhdGFibGUoKTtcblxuICAgICAgICBjdXJyZW50Um90YXRpb25UYWJsZSA9IExPQUQuaW52ZXJ0RmFjdG9yKGZhY3Rvck51bWJlciwgY3VycmVudFJvdGF0aW9uVGFibGUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBSb3RhdGlvbiBUYWJsZSBNYXRyaXggU3RhdGVcbiAgICAgICAgUUFWLnNldFN0YXRlKFwicm90RmFjU3RhdGVBcnJheVwiLCBjdXJyZW50Um90YXRpb25UYWJsZSk7XG4gICAgICAgIC8vIHByZXAgZGF0YSBmb3Igcm90YXRpb24gdGFibGUgcmUtZHJhd1xuICAgICAgICBuZXdEYXRhID0gTE9BRC5wcmVwQ2hhcnREYXRhQXJyYXkyKGN1cnJlbnRSb3RhdGlvblRhYmxlKTtcbiAgICAgICAgLy8gcmUtZHJhdyByb3RhdGlvbiB0YWJsZSBmcm9tIG1hdHJpeCBzdGF0ZVxuICAgICAgICB2YXIgaXNSb3RhdGVkRmFjdG9yc1RhYmxlVXBkYXRlID0gXCJkZXN0cm95XCI7XG4gICAgICAgIExPQUQuZHJhd1JvdGF0ZWRGYWN0b3JzVGFibGUyKGlzUm90YXRlZEZhY3RvcnNUYWJsZVVwZGF0ZSwgXCJub0ZsYWdcIik7XG5cbiAgICAgICAgdmFyIGxhbmd1YWdlID0gUUFWLmdldFN0YXRlKFwibGFuZ3VhZ2VcIik7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0ID0gcmVzb3VyY2VzW2xhbmd1YWdlXS50cmFuc2xhdGlvbi5GYWN0b3I7XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MiA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb25bXCJ3YXMgaW52ZXJ0ZWRcIl07XG4gICAgICAgIHZhciBhcHBlbmRUZXh0MyA9IHJlc291cmNlc1tsYW5ndWFnZV0udHJhbnNsYXRpb24uVW5kbztcblxuICAgICAgICAvLyBhcHBlbmQgdGV4dCB0byByb3RhdGlvbiBoaXN0b3J5XG4gICAgICAgIGxpc3RUZXh0ID0gYXBwZW5kVGV4dCArIFwiIFwiICsgZmFjdG9yTnVtYmVyICsgXCIgXCIgKyBhcHBlbmRUZXh0MjtcbiAgICAgICAgJChcIiNyb3RhdGlvbkhpc3RvcnlMaXN0XCIpLmFwcGVuZCgnPGxpPicgKyBsaXN0VGV4dCArICc8YnV0dG9uIGNsYXNzPVwiZGVsZXRlQnV0dG9uXCI+JyArIGFwcGVuZFRleHQzICsgJzwvYnV0dG9uPjwvbGk+Jyk7XG5cbiAgICAgICAgLy8gY2xlYXIgRDMgcGxvdCBhbmQgMiBmYWN0b3IgY2hhcnRcbiAgICAgICAgUk9UQS5yZUluaXRpYWxpemVQbG90QW5kQ2hhcnQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSb3RhdGlvblRhYmxlO1xuICAgIH07XG5cbiAgICBMT0FELmludmVydEZhY3RvciA9IGZ1bmN0aW9uKGZhY3Rvck51bWJlciwgY3VycmVudFJvdGF0aW9uVGFibGUpIHtcbiAgICAgICAgLy8gY2hhbmdlIHRoZSBzaWduIG9mIHRoZSBmYWN0b3IgdG8gaW52ZXJ0XG4gICAgICAgIHZhciBsb29wTGVuZ3RoID0gY3VycmVudFJvdGF0aW9uVGFibGUubGVuZ3RoO1xuICAgICAgICB2YXIgYWRqdXN0ZWRGYWN0b3JOdW1iZXIgPSBmYWN0b3JOdW1iZXIgLSAxO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9vcExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50Um90YXRpb25UYWJsZVtpXVthZGp1c3RlZEZhY3Rvck51bWJlcl0gPSAtY3VycmVudFJvdGF0aW9uVGFibGVbaV1bYWRqdXN0ZWRGYWN0b3JOdW1iZXJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50Um90YXRpb25UYWJsZTtcbiAgICB9O1xuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogIERBVEEgTU9ERUxcbiAgICAvLyAqKioqKioqKioqICB1bmRvIHNwbGl0IGZhY3RvciByb3RhdGlvbiBpbnNlcnRpb24gKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBMT0FELnVuZG9TcGxpdEZhY3RvclJvdGF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYXNTcGxpdEZhY3RvciA9ICgrKFFBVi5nZXRTdGF0ZShcImhhc1NwbGl0RmFjdG9yXCIpKSk7XG5cbiAgICAgICAgLy8gcmVzZXQgaGVhZGVycyBhcnJheVxuICAgICAgICB2YXIgaGVhZGVycyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzcGxpdEZhY3RvckhlYWRlcnNBcmNoaXZlXCIgKyBoYXNTcGxpdEZhY3RvcikpO1xuXG4gICAgICAgIFFBVi5zZXRTdGF0ZShcImZhY3RvckxhYmVsc1wiLCBoZWFkZXJzKTtcbiAgICAgICAgUUFWLmZhY3RvckxhYmVscyA9IGhlYWRlcnM7XG4gICAgICAgIC8vIGdldCBjb3VudGVyIGFuZCBkYXRhIHZhbHVlc1xuICAgICAgICB2YXIgZ2V0U2F2ZVJvdGF0aW9uQXJjaGl2ZUNvdW50ZXIgPSBST1RBLnNhdmVSb3RhdGlvbkFyY2hpdmVDb3VudGVyKFwiZ2V0XCIpO1xuXG4gICAgICAgIC8vIGRlY3JlbWVudCBoYXNTcGxpdEZhY3RvciBmb3Igc2VsZWN0IGZhY3RvcnMgZm9yIG91dHB1dCBjaGVja2JveGVzXG4gICAgICAgIGhhc1NwbGl0RmFjdG9yID0gaGFzU3BsaXRGYWN0b3IgLSAxO1xuICAgICAgICBRQVYuc2V0U3RhdGUoXCJoYXNTcGxpdEZhY3RvclwiLCBoYXNTcGxpdEZhY3Rvcik7XG5cbiAgICAgICAgLy8gZGVjcmVtZW50IGNvdW50ZXJcbiAgICAgICAgaWYgKGdldFNhdmVSb3RhdGlvbkFyY2hpdmVDb3VudGVyID4gMSkge1xuICAgICAgICAgICAgUk9UQS5zYXZlUm90YXRpb25BcmNoaXZlQ291bnRlcihcImRlY3JlYXNlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRqdXN0IGNvdW50ZXIgdmFsdWVcbiAgICAgICAgdmFyIHJldHJpZXZlTmFtZSA9IGdldFNhdmVSb3RhdGlvbkFyY2hpdmVDb3VudGVyIC0gMTtcblxuICAgICAgICAvLyBnZXQgcm93IGNvbG9yc1xuICAgICAgICB2YXIgcm93Q29sb3JzR3JheSA9IGdldEdyYXlDb2xvcnMoKTtcbiAgICAgICAgdmFyIHJvd0NvbG9yc1JhaW5ib3cgPSBnZXRSYWluYm93Q29sb3JzKCk7XG5cbiAgICAgICAgLy8gZ2V0IHJvd2JhY2tncm91bmQgYW5kIG9yZGVyIGZyb20gRE9NIHVzZXIgaW5wdXQgcmFkaW9cbiAgICAgICAgdmFyIHJvd0JhY2tncm91bmQgPSAkKFwiI3NlY3Rpb242IGlucHV0W25hbWU9c3RhdGUyXTpjaGVja2VkXCIpLnZhbCgpO1xuICAgICAgICB2YXIgb3JkZXJpbmdDb2x1bW4gPSArKCQoXCIjc2VjdGlvbjYgaW5wdXRbbmFtZT1zdGF0ZTFdOmNoZWNrZWRcIikudmFsKCkpO1xuXG5cbiAgICAgICAgLy8gcmV0cmlldmUgYXJjaGl2ZWQgZGF0YSB1c2luZyB0aGUgbm93IGFkanVzdGVkIGNvdW50ZXJcbiAgICAgICAgdmFyIG5ld0RhdGEyID0gUUFWLmdldFN0YXRlKFwicm90RmFjU3RhdGVBcnJheUFyY2hpdmVcIiArIHJldHJpZXZlTmFtZSk7XG5cbiAgICAgICAgLy8gcmUtc2V0IGFyY2hpdmVkIGRhdGEgdG8gc3RhdGUgbWF0cml4ID09PiBcInJvdEZhY3RvclN0YXRlQXJyYXlcImlwXG4gICAgICAgIHZhciByb3RGYWNTdGF0ZUFycmF5UHJlcDEgPSBfLmNsb25lRGVlcChuZXdEYXRhMlswXSk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInJvdEZhY1N0YXRlQXJyYXlcIiwgcm90RmFjU3RhdGVBcnJheVByZXAxKTtcblxuICAgICAgICAvLyBwdWxsIGNoYXJ0IGRhdGEgZnJvbSByZXRyaWV2ZWQgYXJjaGl2ZSBhcnJheVxuICAgICAgICB2YXIgY2hhcnREYXRhID0gbmV3RGF0YTJbMV07XG5cbiAgICAgICAgdmFyIGV4cGxWYXIgPSBuZXdEYXRhMlszXTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwiZXhwVmFyXCIsIGV4cGxWYXIpO1xuXG4gICAgICAgIC8vIHB1bGwgaGVhZGVycyBmcm9tIHJldHJpZXZlZCBhcmNoaXZlIGFycmF5XG4gICAgICAgIHZhciBjb2x1bW5IZWFkZXJzQXJyYXkgPSBuZXdEYXRhMlsyXTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwiY29sdW1uSGVhZGVyc0FycmF5XCIsIGNvbHVtbkhlYWRlcnNBcnJheSk7XG5cbiAgICAgICAgLy8gc2V0IHRhcmdldHMgZnJvbSBjb2x1bW5IZWFkZXJzQXJyYXlcbiAgICAgICAgdmFyIGNvbHVtblRhcmdldHMgPSBbXTtcbiAgICAgICAgdmFyIHRhcmdldExvb3BMZW4gPSBjb2x1bW5IZWFkZXJzQXJyYXkubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBrID0gNDsgayA8IHRhcmdldExvb3BMZW47IGsgKz0gMikge1xuICAgICAgICAgICAgY29sdW1uVGFyZ2V0cy5wdXNoKGspO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbHVtblRhcmdldHMyID0gW107XG4gICAgICAgIGZvciAodmFyIG0gPSAxOyBtIDwgdGFyZ2V0TG9vcExlbjsgbSArPSAyKSB7XG4gICAgICAgICAgICBjb2x1bW5UYXJnZXRzMi5wdXNoKG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9kbyAtIERSWSB0aGlzIG91dFxuICAgICAgICAvLyByZWRyYXcgdGhlIHJvdGF0ZWQgZmFjdG9ycyB0YWJsZVxuICAgICAgICB2YXIgdGFibGUgPSAkKCcjZmFjdG9yUm90YXRpb25UYWJsZTInKS5EYXRhVGFibGUoKTtcbiAgICAgICAgdGFibGUuZGVzdHJveSgpO1xuICAgICAgICAkKCcjZmFjdG9yUm90YXRpb25UYWJsZTInKS5lbXB0eSgpO1xuXG4gICAgICAgIHZhciBpc1VuZG8gPSBcIm5vXCI7XG5cbiAgICAgICAgTE9BRC5jcmVhdGVGb290ZXIoXCJmYWN0b3JSb3RhdGlvblRhYmxlMlwiLCBleHBsVmFyLCBpc1VuZG8pO1xuXG4gICAgICAgIHRhYmxlID0gJChcIiNmYWN0b3JSb3RhdGlvblRhYmxlMlwiKS5EYXRhVGFibGUoe1xuICAgICAgICAgICAgXCJyZXRyaWV2ZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzZWFyY2hpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICBcIm9yZGVyaW5nXCI6IHRydWUsXG4gICAgICAgICAgICBcImluZm9cIjogZmFsc2UsXG4gICAgICAgICAgICAvL1wic2Nyb2xsWVwiOiA2MDAsXG4gICAgICAgICAgICBcInNjcm9sbENvbGxhcHNlXCI6IHRydWUsXG4gICAgICAgICAgICBcInNjcm9sbFhcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicGFnaW5nXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJvcmRlclwiOiBbXG4gICAgICAgICAgICAgICAgW29yZGVyaW5nQ29sdW1uLCBcImFzY1wiXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiZGF0YVwiOiBjaGFydERhdGEsXG4gICAgICAgICAgICBcImNvbHVtbnNcIjogY29sdW1uSGVhZGVyc0FycmF5LFxuICAgICAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFt7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnaGlnaGVzdEZhY3RvcicsXG4gICAgICAgICAgICAgICAgJ3RhcmdldHMnOiAyXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgJ3RhcmdldHMnOiBjb2x1bW5UYXJnZXRzLCAvLyBbMiwgNCwgNiwgOCwgMTAsIDEyLCAxNF0sXG4gICAgICAgICAgICAgICAgJ3NlYXJjaGFibGUnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnb3JkZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAncmVuZGVyJzogZnVuY3Rpb24oZGF0YSwgZGF0YUluZGV4KSB7IC8vIChkYXRhLCB0eXBlLCBmdWxsLCBtZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwic2lnQ2hlY2tib3hcIiAvPjxsYWJlbD48L2xhYmVsPic7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cInNpZ0NoZWNrYm94XCIgaWQ9XCJkJyArIGRhdGFJbmRleCArICdcIiB2YWx1ZT1cIicgKyBkYXRhICsgJ1wiIGRlZmF1bHRDaGVja2VkPVwiJyArIChkYXRhID09PSAndHJ1ZScgPyAnY2hlY2tlZCcgOiAnJykgKyAnXCInICsgKGRhdGEgPT09ICd0cnVlJyA/ICdjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcgLz48bGFiZWw+PC9sYWJlbD4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBcImNyZWF0ZWRSb3dcIjogZnVuY3Rpb24ocm93LCBkYXRhLCBkYXRhSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93R3JvdXA7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0JhY2tncm91bmQgPT09IFwiZ3JheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd0dyb3VwID0gZGF0YVsyXS5zbGljZSgwLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgLy92YXIgcm93R3JvdXBDb2xvciA9IChyb3dDb2xvcnNHcmF5W3Jvd0dyb3VwXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgJCgndGQnLCByb3cpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHJvd0NvbG9yc0dyYXlbcm93R3JvdXBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJvd0JhY2tncm91bmQgPT09IFwiY29sb3JzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93R3JvdXAgPSBkYXRhWzJdLnNsaWNlKDAsIDIpO1xuICAgICAgICAgICAgICAgICAgICAvL3ZhciByb3dHcm91cENvbG9yID0gKHJvd0NvbG9yc0dyYXlbcm93R3JvdXBdKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAkKCd0ZCcsIHJvdykuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgcm93Q29sb3JzUmFpbmJvd1tyb3dHcm91cF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2xlYXIgb3V0IHRoZSAyIGZhY3RvciByb3RhdGlvbiBjaGFydCBhbmQgRDMgcGxvdFxuICAgICAgICAvLyByZUluaXRpYWxpemVQbG90QW5kQ2hhcnQoKTtcbiAgICAgICAgJChcIiNjaGFydEFuZFRhYmxlRGlzcGxheUNvbnRhaW5lclwiKS5oaWRlKCk7XG5cbiAgICAgICAgLy8gY2xlYXIgb3V0cHV0IGNoZWNrYm94ZXNcbiAgICAgICAgVklFVy5yZW1vdmVPdXRwdXRGYWN0b3JDaGVja2JveGVzKCk7XG5cbiAgICAgICAgLy8gdG9kbyAtIGNoZWNrIHRvIHNlZSBpZiBmaXJlZm94IHN0aWxsIG5lZWRzIHRoaXNcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIHZpZXdcbiAgICAvLyAqKioqKioqKioqICBkcmF3IHJvdGF0ZWQgZmFjdG9ycyB0YWJsZSB1c2luZyBqcXVlcnkgZGF0YVRhYmxlcyAgICoqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIExPQUQuZHJhd1JvdGF0ZWRGYWN0b3JzVGFibGUyID0gZnVuY3Rpb24oaXNSb3RhdGVkRmFjdG9yc1RhYmxlVXBkYXRlLCBzaG91bGRGbGFnKSB7XG5cbiAgICAgICAgLy8gcHVsbCBjdXJyZW50IHRhYmxlIHN0YXRlIGZyb20gZ2xvYmFsIHZhcmlhYmxlXG4gICAgICAgIHZhciBjaGFydERhdGEgPSBRQVYuZ2V0U3RhdGUoXCJyb3RGYWNTdGF0ZUFycmF5XCIpO1xuXG4gICAgICAgIC8vIGZvcm1hdCBkYXRhIGZvciB0YWJsZVxuICAgICAgICB2YXIgbmV3RGF0YSA9IExPQUQucHJlcENoYXJ0RGF0YUFycmF5MihjaGFydERhdGEpO1xuXG4gICAgICAgIC8vIHB1bGwgb3V0IGV4cGxWYXJcbiAgICAgICAgdmFyIGV4cFZhcjIgPSBRQVYuZ2V0U3RhdGUoXCJleHBWYXJcIik7XG5cbiAgICAgICAgLy8gcHVsbCBvdXQgZWlnZW52YWx1ZXMgZGF0YVxuICAgICAgICBuZXdEYXRhLnBvcCgpO1xuXG4gICAgICAgIC8vIGdldCByb3cgY29sb3JzXG4gICAgICAgIHZhciByb3dDb2xvcnNHcmF5ID0gZ2V0R3JheUNvbG9ycygpO1xuICAgICAgICB2YXIgcm93Q29sb3JzUmFpbmJvdyA9IGdldFJhaW5ib3dDb2xvcnMoKTtcblxuICAgICAgICAvLyBnZXQgcm93YmFja2dyb3VuZCBhbmQgb3JkZXIgZnJvbSBET00gdXNlciBpbnB1dCByYWRpb1xuICAgICAgICB2YXIgcm93QmFja2dyb3VuZCA9ICQoXCIjc2VjdGlvbjYgaW5wdXRbbmFtZT1zdGF0ZTJdOmNoZWNrZWRcIikudmFsKCk7XG4gICAgICAgIHZhciBvcmRlcmluZ0NvbHVtbiA9ICsoJChcIiNzZWN0aW9uNiBpbnB1dFtuYW1lPXN0YXRlMV06Y2hlY2tlZFwiKS52YWwoKSk7XG5cbiAgICAgICAgLy8gdmFyIGRlY2xhcmF0aW9uc1xuICAgICAgICB2YXIgbG9vcExlbmd0aCA9IGNoYXJ0RGF0YVswXS5sZW5ndGggKyAxO1xuICAgICAgICB2YXIgdGVtcDtcbiAgICAgICAgdmFyIGNvbHVtbkhlYWRlcnNBcnJheSA9IFtdO1xuXG4gICAgICAgIFJPVEEuY2FsY3VsYXRlRmFjdG9yTG9hZGluZ1NpZ25pZmljYW5jZUxldmVsKCk7XG5cbiAgICAgICAgY29sdW1uSGVhZGVyc0FycmF5LnB1c2goe1xuICAgICAgICAgICAgdGl0bGU6ICdOby4nLFxuICAgICAgICAgICAgY2xhc3M6IFwiZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1jZW50ZXJcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0aXRsZTogJ1Jlc3BvbmQuJyxcbiAgICAgICAgICAgIGNsYXNzOiAnZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1jZW50ZXInXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpdGxlOiAnRkcnLFxuICAgICAgICAgICAgY2xhc3M6IFwiZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1jZW50ZXJcIlxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxvb3BMZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICB0ZW1wID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnRnRyICcgKyBpLFxuICAgICAgICAgICAgICAgIGNsYXNzOiBcImR0LWhlYWQtY2VudGVyIGR0LWJvZHktcmlnaHRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbHVtbkhlYWRlcnNBcnJheS5wdXNoKHRlbXApO1xuICAgICAgICAgICAgY29sdW1uSGVhZGVyc0FycmF5LnB1c2goe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnZmxhZycsXG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiZHQtaGVhZC1jZW50ZXIgZHQtYm9keS1jZW50ZXJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29sdW1uSGVhZGVyc0FycmF5LnB1c2goe1xuICAgICAgICAgICAgdGl0bGU6ICdoPHN1cD4yPC9zdXA+JyxcbiAgICAgICAgICAgIGNsYXNzOiBcImR0LWhlYWQtY2VudGVyIGR0LWJvZHktcmlnaHRcIlxuICAgICAgICB9KTtcblxuICAgICAgICBRQVYuc2V0U3RhdGUoXCJjb2x1bW5IZWFkZXJzQXJyYXlcIiwgY29sdW1uSGVhZGVyc0FycmF5KTtcblxuICAgICAgICB2YXIgY29sdW1uVGFyZ2V0cyA9IFtdO1xuICAgICAgICB2YXIgdGFyZ2V0TG9vcExlbiA9IGNvbHVtbkhlYWRlcnNBcnJheS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGsgPSA0OyBrIDwgdGFyZ2V0TG9vcExlbjsgayArPSAyKSB7XG4gICAgICAgICAgICBjb2x1bW5UYXJnZXRzLnB1c2goayk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sdW1uVGFyZ2V0czIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbSA9IDE7IG0gPCB0YXJnZXRMb29wTGVuOyBtICs9IDIpIHtcbiAgICAgICAgICAgIGNvbHVtblRhcmdldHMyLnB1c2gobSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0YWJsZSwgcmVtb3ZlIGZyb20gRE9NIGFuZCBkcmF3IHRhYmxlXG4gICAgICAgIHZhciB0YWJsZSwgZmFjdG9yU29ydGVkRGF0YTtcblxuICAgICAgICBpZiAoaXNSb3RhdGVkRmFjdG9yc1RhYmxlVXBkYXRlID09PSBcImhpZ2hsaWdodGVyXCIpIHtcbiAgICAgICAgICAgIGZhY3RvclNvcnRlZERhdGEgPSBRQVYuY29sb3JCdXR0b25DaGFydERhdGE7XG4gICAgICAgICAgICAvLyB1bmxvYWQgdGhhdCBoZWF2eSBwcm9wZXJ0eVxuICAgICAgICAgICAgUUFWLmNvbG9yQnV0dG9uQ2hhcnREYXRhID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZhY3RvclNvcnRlZERhdGEgPSBMT0FELnJvdGF0aW9uVGFibGVTb3J0QnlGYWN0b3IobmV3RGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNVbmRvID0gXCJub1wiO1xuICAgICAgICBMT0FELmNyZWF0ZUZvb3RlcihcImZhY3RvclJvdGF0aW9uVGFibGUyXCIsIGV4cFZhcjIsIGlzVW5kbyk7XG5cblxuICAgICAgICAvLyB0b2RvIC0gdGVtcG9yYXJpbHkgZGlzYWJsZWQgdXBkYXRlIGJlY2F1c2UgYXV0b2ZsYWdnaW5nIGlzc3Vlc1xuICAgICAgICBpZiAoaXNSb3RhdGVkRmFjdG9yc1RhYmxlVXBkYXRlID09PSBcInllc1wiKSB7XG5cblxuICAgICAgICAgICAgdGFibGUgPSAkKCcjZmFjdG9yUm90YXRpb25UYWJsZTInKS5EYXRhVGFibGUoKTtcbiAgICAgICAgICAgIHRhYmxlLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIExPQUQuY3JlYXRlRm9vdGVyKFwiZmFjdG9yUm90YXRpb25UYWJsZTJcIiwgZXhwVmFyMiwgaXNVbmRvKTtcblxuICAgICAgICAgICAgdGFibGUucm93cy5hZGQoZmFjdG9yU29ydGVkRGF0YSkuZHJhdygpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNSb3RhdGVkRmFjdG9yc1RhYmxlVXBkYXRlID09PSBcImRlc3Ryb3lcIikge1xuXG4gICAgICAgICAgICB0YWJsZSA9ICQoJyNmYWN0b3JSb3RhdGlvblRhYmxlMicpLkRhdGFUYWJsZSgpO1xuICAgICAgICAgICAgdGFibGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgJCgnI2ZhY3RvclJvdGF0aW9uVGFibGUyJykuZW1wdHkoKTtcblxuICAgICAgICAgICAgTE9BRC5jcmVhdGVGb290ZXIoXCJmYWN0b3JSb3RhdGlvblRhYmxlMlwiLCBleHBWYXIyLCBcIm5vXCIpO1xuXG4gICAgICAgICAgICB0YWJsZSA9ICQoXCIjZmFjdG9yUm90YXRpb25UYWJsZTJcIikuRGF0YVRhYmxlKHtcbiAgICAgICAgICAgICAgICBcInJldHJpZXZlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJzZWFyY2hpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgXCJvcmRlcmluZ1wiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiaW5mb1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAvLyBcInNjcm9sbFlcIjogNjAwLFxuICAgICAgICAgICAgICAgIFwic2Nyb2xsQ29sbGFwc2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInNjcm9sbFhcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInBhZ2luZ1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcIm9yZGVyXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgW29yZGVyaW5nQ29sdW1uLCBcImFzY1wiXVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IGZhY3RvclNvcnRlZERhdGEsXG4gICAgICAgICAgICAgICAgXCJjb2x1bW5zXCI6IGNvbHVtbkhlYWRlcnNBcnJheSxcbiAgICAgICAgICAgICAgICBcImNvbHVtbkRlZnNcIjogW3tcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaGlnaGVzdEZhY3RvcicsXG4gICAgICAgICAgICAgICAgICAgICd0YXJnZXRzJzogMlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgJ3RhcmdldHMnOiBjb2x1bW5UYXJnZXRzLCAvLyBbIDQsIDYsIDgsIDEwLCAxMiwgMTQsIDE2XSxcbiAgICAgICAgICAgICAgICAgICAgJ3NlYXJjaGFibGUnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ29yZGVyYWJsZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdyZW5kZXInOiBmdW5jdGlvbihkYXRhLCBkYXRhSW5kZXgpIHsgLy8gKGRhdGEsIHR5cGUsIGZ1bGwsIG1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEZsYWcgPT09IFwiZmxhZ1wiKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cInNpZ0NoZWNrYm94XCIgaWQ9XCJkJyArIGRhdGFJbmRleCArICdcIiB2YWx1ZT1cIicgKyBkYXRhICsgJ1wiIGRlZmF1bHRDaGVja2VkPVwiJyArIChkYXRhID09PSAndHJ1ZScgPyAnY2hlY2tlZCcgOiAnJykgKyAnXCInICsgKGRhdGEgPT09ICd0cnVlJyA/ICdjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcgLz48bGFiZWw+PC9sYWJlbD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cInNpZ0NoZWNrYm94XCIgLz48bGFiZWw+PC9sYWJlbD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgXCJjcmVhdGVkUm93XCI6IGZ1bmN0aW9uKHJvdywgZGF0YSwgZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dHcm91cDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0JhY2tncm91bmQgPT09IFwiZ3JheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dHcm91cCA9IGRhdGFbMl0uc2xpY2UoMCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciByb3dHcm91cENvbG9yID0gKHJvd0NvbG9yc0dyYXlbcm93R3JvdXBdKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgndGQnLCByb3cpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHJvd0NvbG9yc0dyYXlbcm93R3JvdXBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyb3dCYWNrZ3JvdW5kID09PSBcImNvbG9yc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dHcm91cCA9IGRhdGFbMl0uc2xpY2UoMCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciByb3dHcm91cENvbG9yID0gKHJvd0NvbG9yc0dyYXlbcm93R3JvdXBdKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgndGQnLCByb3cpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHJvd0NvbG9yc1JhaW5ib3dbcm93R3JvdXBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBhZGRlZCBmb3IgY29sb3IgYnV0dG9uXG4gICAgICAgICAgICBpZiAoaXNSb3RhdGVkRmFjdG9yc1RhYmxlVXBkYXRlID09PSBcImhpZ2hsaWdodGVyXCIpIHtcbiAgICAgICAgICAgICAgICB0YWJsZSA9ICQoJyNmYWN0b3JSb3RhdGlvblRhYmxlMicpLkRhdGFUYWJsZSgpO1xuICAgICAgICAgICAgICAgIHRhYmxlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAkKCcjZmFjdG9yUm90YXRpb25UYWJsZTInKS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIExPQUQuY3JlYXRlRm9vdGVyKFwiZmFjdG9yUm90YXRpb25UYWJsZTJcIiwgZXhwVmFyMiwgXCJub1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYmxlID0gJChcIiNmYWN0b3JSb3RhdGlvblRhYmxlMlwiKS5EYXRhVGFibGUoe1xuICAgICAgICAgICAgICAgIFwicmV0cmlldmVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInNlYXJjaGluZ1wiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBcIm9yZGVyaW5nXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJpbmZvXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC8vIFwic2Nyb2xsWVwiOiA2MDAsXG4gICAgICAgICAgICAgICAgXCJzY3JvbGxDb2xsYXBzZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwic2Nyb2xsWFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwicGFnaW5nXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwib3JkZXJcIjogW1xuICAgICAgICAgICAgICAgICAgICBbb3JkZXJpbmdDb2x1bW4sIFwiYXNjXCJdXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcImRhdGFcIjogZmFjdG9yU29ydGVkRGF0YSxcbiAgICAgICAgICAgICAgICBcImNvbHVtbnNcIjogY29sdW1uSGVhZGVyc0FycmF5LFxuICAgICAgICAgICAgICAgIFwiY29sdW1uRGVmc1wiOiBbe1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdoaWdoZXN0RmFjdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RhcmdldHMnOiAyXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAndGFyZ2V0cyc6IGNvbHVtblRhcmdldHMsIC8vIFsyLCA0LCA2LCA4LCAxMCwgMTIsIDE0XSxcbiAgICAgICAgICAgICAgICAgICAgJ3NlYXJjaGFibGUnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ29yZGVyYWJsZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdyZW5kZXInOiBmdW5jdGlvbihkYXRhLCBkYXRhSW5kZXgpIHsgLy8gKGRhdGEsIHR5cGUsIGZ1bGwsIG1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJzaWdDaGVja2JveFwiIC8+PGxhYmVsPjwvbGFiZWw+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJzaWdDaGVja2JveFwiIGlkPVwiZCcgKyBkYXRhSW5kZXggKyAnXCIgdmFsdWU9XCInICsgZGF0YSArICdcIiBkZWZhdWx0Q2hlY2tlZD1cIicgKyAoZGF0YSA9PT0gJ3RydWUnID8gJ2NoZWNrZWQnIDogJycpICsgJ1wiJyArIChkYXRhID09PSAndHJ1ZScgPyAnY2hlY2tlZD1cImNoZWNrZWRcIicgOiAnJykgKyAnIC8+PGxhYmVsPjwvbGFiZWw+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIFwiY3JlYXRlZFJvd1wiOiBmdW5jdGlvbihyb3csIGRhdGEsIGRhdGFJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93R3JvdXA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3dCYWNrZ3JvdW5kID09PSBcImdyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93R3JvdXAgPSBkYXRhWzJdLnNsaWNlKDAsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgcm93R3JvdXBDb2xvciA9IChyb3dDb2xvcnNHcmF5W3Jvd0dyb3VwXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJ3RkJywgcm93KS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCByb3dDb2xvcnNHcmF5W3Jvd0dyb3VwXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocm93QmFja2dyb3VuZCA9PT0gXCJjb2xvcnNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93R3JvdXAgPSBkYXRhWzJdLnNsaWNlKDAsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgcm93R3JvdXBDb2xvciA9IChyb3dDb2xvcnNHcmF5W3Jvd0dyb3VwXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJ3RkJywgcm93KS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCByb3dDb2xvcnNSYWluYm93W3Jvd0dyb3VwXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4gICAgTE9BRC5jcmVhdGVGb290ZXIgPSBmdW5jdGlvbihlbGVtZW50LCBleHBWYXIyLCBpc1VuZG8pIHtcbiAgICAgICAgdmFyIGhhc0Zvb3RlciA9ICQoXCIjZmFjdG9yUm90YXRpb25UYWJsZTIgdGZvb3RcIik7XG4gICAgICAgIHZhciBjaGVja0Zvb3RlciA9ICgoaGFzRm9vdGVyLnRleHQoKSkpO1xuXG4gICAgICAgIGlmIChjaGVja0Zvb3Rlci5sZW5ndGggIT09IDAgfHwgaXNVbmRvID09PSBcInllc1wiKSB7XG5cbiAgICAgICAgICAgIHZhciB0YWJsZSA9ICQoJyNmYWN0b3JSb3RhdGlvblRhYmxlMicpLkRhdGFUYWJsZSgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IGV4cFZhcjIubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gdGFibGUuY29sdW1uKGcpO1xuICAgICAgICAgICAgICAgICQoY29sdW1uLmZvb3RlcigpKS5odG1sKGV4cFZhcjJbZ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZvb3RlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rmb290Jyk7XG4gICAgICAgICAgICB2YXIgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXG4gICAgICAgICAgICBqUXVlcnkuZWFjaChleHBWYXIyLCBmdW5jdGlvbihpLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciB0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XG4gICAgICAgICAgICAgICAgdGguaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb290ZXIuYXBwZW5kQ2hpbGQodHIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCkuYXBwZW5kQ2hpbGQoZm9vdGVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgREFUQSBNT0RFTFxuICAgIC8vICoqKioqKioqKiogIHVuZG8gZmFjdG9yIHJvdGF0aW9uIGluc2VydGlvbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBMT0FELnVuZG9GYWN0b3JSb3RhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIGdldCBjb3VudGVyIGFuZCBkYXRhIHZhbHVlc1xuICAgICAgICB2YXIgZ2V0U2F2ZVJvdGF0aW9uQXJjaGl2ZUNvdW50ZXIgPSBST1RBLnNhdmVSb3RhdGlvbkFyY2hpdmVDb3VudGVyKFwiZ2V0XCIpO1xuXG4gICAgICAgIC8vIGRlY3JlbWVudCBjb3VudGVyXG4gICAgICAgIGlmIChnZXRTYXZlUm90YXRpb25BcmNoaXZlQ291bnRlciA+IDEpIHtcbiAgICAgICAgICAgIFJPVEEuc2F2ZVJvdGF0aW9uQXJjaGl2ZUNvdW50ZXIoXCJkZWNyZWFzZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBjb3VudGVyIHZhbHVlXG4gICAgICAgIHZhciByZXRyaWV2ZU5hbWUgPSBnZXRTYXZlUm90YXRpb25BcmNoaXZlQ291bnRlciAtIDE7XG5cbiAgICAgICAgLy8gcmV0cmlldmUgYXJjaGl2ZWQgZGF0YSB1c2luZyB0aGUgbm93IGFkanVzdGVkIGNvdW50ZXJcbiAgICAgICAgdmFyIG5ld0RhdGEyID0gUUFWLmdldFN0YXRlKFwicm90RmFjU3RhdGVBcnJheUFyY2hpdmVcIiArIHJldHJpZXZlTmFtZSk7XG5cbiAgICAgICAgLy8gcmUtc2V0IGFyY2hpdmVkIGRhdGEgdG8gc3RhdGUgbWF0cml4ID09PiBcInJvdEZhY3RvclN0YXRlQXJyYXlcImlwXG4gICAgICAgIHZhciByb3RGYWNTdGF0ZUFycmF5UHJlcDEgPSBfLmNsb25lRGVlcChuZXdEYXRhMlswXSk7XG4gICAgICAgIFFBVi5zZXRTdGF0ZShcInJvdEZhY1N0YXRlQXJyYXlcIiwgcm90RmFjU3RhdGVBcnJheVByZXAxKTtcblxuICAgICAgICAvLyBwdWxsIGNoYXJ0IGRhdGEgZnJvbSByZXRyaWV2ZWQgYXJjaGl2ZSBhcnJheVxuICAgICAgICB2YXIgY2hhcnREYXRhID0gbmV3RGF0YTJbMV07XG5cbiAgICAgICAgdmFyIGV4cGxWYXIgPSBuZXdEYXRhMlszXTtcbiAgICAgICAgUUFWLnNldFN0YXRlKFwiZXhwVmFyXCIsIGV4cGxWYXIpO1xuXG4gICAgICAgIHZhciBpc1VuZG8gPSBcInllc1wiO1xuXG4gICAgICAgIExPQUQuY3JlYXRlRm9vdGVyKFwiZmFjdG9yUm90YXRpb25UYWJsZTJcIiwgZXhwbFZhciwgaXNVbmRvKTtcblxuICAgICAgICAvLyByZWRyYXcgdGhlIHJvdGF0ZWQgZmFjdG9ycyB0YWJsZVxuICAgICAgICB2YXIgdGFibGUgPSAkKCcjZmFjdG9yUm90YXRpb25UYWJsZTInKS5EYXRhVGFibGUoKTtcbiAgICAgICAgdGFibGUuY2xlYXIoKTtcbiAgICAgICAgdGFibGUucm93cy5hZGQoY2hhcnREYXRhKS5kcmF3KCk7XG5cbiAgICAgICAgLy8gY2xlYXIgb3V0IHRoZSAyIGZhY3RvciByb3RhdGlvbiBjaGFydCBhbmQgRDMgcGxvdFxuICAgICAgICBST1RBLnJlSW5pdGlhbGl6ZVBsb3RBbmRDaGFydCgpO1xuICAgIH07XG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogIERBVEEgTU9ERUxcbiAgICAvLyAqKioqIGNoYXJ0RGF0YSBBUlJBWSBUTyByZXN1bHRzQXJyYXkgT0JKRUNUIEZPUiBkYXRhdGFibGVzICoqKioqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBMT0FELnByZXBDaGFydERhdGFBcnJheTIgPSBmdW5jdGlvbihjaGFydERhdGEpIHtcbiAgICAgICAgdmFyIGFycmF5TGVuZ3RoID0gY2hhcnREYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGFycmF5TGVuZ3RoMiA9IGNoYXJ0RGF0YVswXS5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHRzQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIHJlc3BvbmRlbnROYW1lcyA9IFFBVi5nZXRTdGF0ZShcInFhdlJlc3BvbmRlbnROYW1lc1wiKTtcbiAgICAgICAgdmFyIGZTaWcgPSBRQVYuZ2V0U3RhdGUoXCJmU2lnQ3JpdGVyaW9uUmVzdWx0c1wiKTtcbiAgICAgICAgdmFyIHJvd0gyID0gUUFWLmdldFN0YXRlKFwicm93SDJcIik7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnJheUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgdGVtcE9iajIgPSBbXTtcbiAgICAgICAgICAgIHRlbXBPYmoyLnB1c2gocmVzcG9uZGVudE5hbWVzW2pdKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBhcnJheUxlbmd0aDI7IG0rKykge1xuICAgICAgICAgICAgICAgIHRlbXBPYmoyLnB1c2goY2hhcnREYXRhW2pdW21dKTtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqMi5wdXNoKGZTaWdbal1bbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcE9iajIucHVzaChyb3dIMltqXSk7XG4gICAgICAgICAgICByZXN1bHRzQXJyYXkucHVzaCh0ZW1wT2JqMik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIGVpZ2VudmFsdWVzIGFuZCB2YXJpYW5jZSBhbmQgYWRkIHRvIHJlc3VsdHMgYXJyYXlcbiAgICAgICAgdmFyIGVpZ2VudmFsdWVzQW5kVmFyaWFuY2UgPSBST1RBLmNhbGN1bGF0ZUVpZ2VudmFsdWVzQW5kVmFyaWFuY2UyKCk7XG4gICAgICAgIHJlc3VsdHNBcnJheS5wdXNoKGVpZ2VudmFsdWVzQW5kVmFyaWFuY2VbMF0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0c0FycmF5O1xuICAgIH07XG5cbiAgICBMT0FELnJvdGF0aW9uVGFibGVTb3J0QnlGYWN0b3IgPSBmdW5jdGlvbihuZXdEYXRhKSB7XG4gICAgICAgIHZhciBzb3J0aW5nQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGZhY3RvclNvcnRlZERhdGEgPSBbXTtcbiAgICAgICAgdmFyIHRlbXBPYmo7XG4gICAgICAgIHZhciBuZXdEYXRhMiA9IF8uY2xvbmVEZWVwKG5ld0RhdGEpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gbmV3RGF0YS5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBPYmogPSB7fTtcbiAgICAgICAgICAgIG5ld0RhdGEyW2ldLnBvcCgpO1xuICAgICAgICAgICAgdmFyIHB1bGxOdW1iZXJzID0gXy5waWNrKG5ld0RhdGEyW2ldLCBfLmlzTnVtYmVyKTtcblxuICAgICAgICAgICAgdGVtcE9iai5tYXhWYWx1ZSA9IF8ubWF4KHB1bGxOdW1iZXJzKTtcbiAgICAgICAgICAgIHRlbXBPYmoubWluVmFsdWUgPSBfLm1pbihwdWxsTnVtYmVycyk7XG4gICAgICAgICAgICB0ZW1wT2JqLnNvcnROdW0gPSAoaSArIDEpO1xuICAgICAgICAgICAgdGVtcE9iai5jb21wYXJlVmFsdWUgPSAoTWF0aC5hYnModGVtcE9iai5tYXhWYWx1ZSkgLSBNYXRoLmFicyh0ZW1wT2JqLm1pblZhbHVlKSk7XG4gICAgICAgICAgICBpZiAodGVtcE9iai5jb21wYXJlVmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgICAgIHRlbXBPYmouaW5kZXhWYWx1ZSA9IF8uaW5kZXhPZihuZXdEYXRhW2ldLCB0ZW1wT2JqLm1heFZhbHVlKTtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqLnN1YlNvcnRWYWx1ZSA9IHRlbXBPYmoubWF4VmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBPYmouaW5kZXhWYWx1ZSA9IF8uaW5kZXhPZihuZXdEYXRhW2ldLCB0ZW1wT2JqLm1pblZhbHVlKTtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqLnN1YlNvcnRWYWx1ZSA9IE1hdGguYWJzKHRlbXBPYmoubWluVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcE9iai5zb3J0ID0gbmV3RGF0YVtpXTtcbiAgICAgICAgICAgIHNvcnRpbmdBcnJheS5wdXNoKHRlbXBPYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZhY3RvclNvcnRlZEFycmF5ID0gXy5jbG9uZURlZXAoc29ydGluZ0FycmF5KTtcbiAgICAgICAgLy8gc29ydCBvYmplY3QgYnkgdHdvIHByb3BlcnRpZXNcbiAgICAgICAgZmFjdG9yU29ydGVkQXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhLmluZGV4VmFsdWUgLSBiLmluZGV4VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZSA6IGIuc3ViU29ydFZhbHVlIC0gYS5zdWJTb3J0VmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBtb2RpZmllZEluZGV4VmFsdWUgPSB7XG4gICAgICAgICAgICAxOiAxLFxuICAgICAgICAgICAgMzogMixcbiAgICAgICAgICAgIDU6IDMsXG4gICAgICAgICAgICA3OiA0LFxuICAgICAgICAgICAgOTogNSxcbiAgICAgICAgICAgIDExOiA2LFxuICAgICAgICAgICAgMTM6IDcsXG4gICAgICAgICAgICAxNTogOFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBmYWN0b3JHcm91cE51bWJlciwgbG9va1VwSW5kZXhWYWx1ZTtcbiAgICAgICAgdmFyIHN1Ykdyb3VwQ291bnRlciA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gZmFjdG9yU29ydGVkQXJyYXkubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgICBsb29rVXBJbmRleFZhbHVlID0gKGZhY3RvclNvcnRlZEFycmF5W2pdLmluZGV4VmFsdWUpO1xuICAgICAgICAgICAgaWYgKGogPT09IDAgfHwgbG9va1VwSW5kZXhWYWx1ZSA9PT0gZmFjdG9yU29ydGVkQXJyYXlbaiAtIDFdLmluZGV4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzdWJHcm91cENvdW50ZXIgPSBzdWJHcm91cENvdW50ZXIgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJHcm91cENvdW50ZXIgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmFjdG9yR3JvdXBOdW1iZXIgPSBcIkZcIiArIG1vZGlmaWVkSW5kZXhWYWx1ZVtsb29rVXBJbmRleFZhbHVlXSArIFwiLVwiICsgc3ViR3JvdXBDb3VudGVyO1xuICAgICAgICAgICAgZmFjdG9yU29ydGVkQXJyYXlbal0uc29ydC5zcGxpY2UoMSwgMCwgZmFjdG9yR3JvdXBOdW1iZXIpO1xuICAgICAgICAgICAgZmFjdG9yU29ydGVkQXJyYXlbal0uc29ydC51bnNoaWZ0KGZhY3RvclNvcnRlZEFycmF5W2pdLnNvcnROdW0pO1xuICAgICAgICAgICAgZmFjdG9yU29ydGVkRGF0YS5wdXNoKGZhY3RvclNvcnRlZEFycmF5W2pdLnNvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWN0b3JTb3J0ZWREYXRhO1xuICAgIH07XG5cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAgRGF0YSBNb2RlbFxuICAgIC8vICoqKioqKioqKiogIHNldCBiYWNrZ3JvdW5kIGNvbG9ycyBvZiBmYWN0b3IgbG9hZGluZyB0YWJsZSAqKioqKioqKioqKioqKioqXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBmdW5jdGlvbiBnZXRSYWluYm93Q29sb3JzKCkge1xuICAgICAgICB2YXIgcm93Q29sb3JzUmFpbmJvdyA9IHtcbiAgICAgICAgICAgIFwiRjFcIjogXCIjZjdmY2YwXCIsXG4gICAgICAgICAgICBcIkYyXCI6IFwiI2UwZjNkYlwiLFxuICAgICAgICAgICAgXCJGM1wiOiBcIiNjY2ViYzVcIixcbiAgICAgICAgICAgIFwiRjRcIjogXCIjYThkZGI1XCIsXG4gICAgICAgICAgICBcIkY1XCI6IFwiIzdiY2NjNFwiLFxuICAgICAgICAgICAgXCJGNlwiOiBcIiM0ZWIzZDNcIixcbiAgICAgICAgICAgIFwiRjdcIjogXCIjMmI4Y2JlXCIsXG4gICAgICAgICAgICBcIkY4XCI6IFwiIzljYmJkN1wiXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3dDb2xvcnNSYWluYm93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEdyYXlDb2xvcnMoKSB7XG4gICAgICAgIHZhciByb3dDb2xvcnNHcmF5ID0ge1xuICAgICAgICAgICAgXCJGMVwiOiBcIiNmZmZmZmZcIixcbiAgICAgICAgICAgIFwiRjJcIjogXCIjZjBmMGYwXCIsXG4gICAgICAgICAgICBcIkYzXCI6IFwiI2Q5ZDlkOVwiLFxuICAgICAgICAgICAgXCJGNFwiOiBcIiNiZGJkYmRcIixcbiAgICAgICAgICAgIFwiRjVcIjogXCIjOTY5Njk2XCIsXG4gICAgICAgICAgICBcIkY2XCI6IFwiIzczNzM3M1wiLFxuICAgICAgICAgICAgXCJGN1wiOiBcIiNkOWQ5ZDlcIixcbiAgICAgICAgICAgIFwiRjhcIjogXCJ3aGl0ZXNtb2tlXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJvd0NvbG9yc0dyYXk7XG4gICAgfVxuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogdmlld1xuICAgIC8vICoqKioqICBkcmF3IGJpcG9sYXIgc3BsaXQgcm90YXRlZCBmYWN0b3JzIHRhYmxlIHVzaW5nIGpxdWVyeSBkYXRhVGFibGVzICoqKipcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICBmdW5jdGlvbiBiaXBvbGFyU3BsaXRUYWJsZVJlZHJhdyhoZWFkZXJzLCByZXN1bHRzLCBleHBsVmFyKSB7XG5cbiAgICAgICAgLy8gZ2V0IGNvbHVtbiBpZHMgZm9yIHRhYmxlIGZvcm1hdHRpbmdcbiAgICAgICAgdmFyIGNvbHVtblRhcmdldHMgPSBbXTtcbiAgICAgICAgdmFyIHRhcmdldExvb3BMZW4gPSBoZWFkZXJzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgayA9IDQ7IGsgPCB0YXJnZXRMb29wTGVuOyBrICs9IDIpIHtcbiAgICAgICAgICAgIGNvbHVtblRhcmdldHMucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sdW1uVGFyZ2V0czIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbSA9IDE7IG0gPCB0YXJnZXRMb29wTGVuOyBtICs9IDIpIHtcbiAgICAgICAgICAgIGNvbHVtblRhcmdldHMyLnB1c2gobSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgcHJldmlvdXMgdGFibGUgYW5kIGhlYWRlcnMgZnJvbSBET01cbiAgICAgICAgdmFyIHRhYmxlID0gJCgnI2ZhY3RvclJvdGF0aW9uVGFibGUyJykuRGF0YVRhYmxlKCk7XG4gICAgICAgIHRhYmxlLmRlc3Ryb3koKTtcbiAgICAgICAgJCgnI2ZhY3RvclJvdGF0aW9uVGFibGUyJykuZW1wdHkoKTtcblxuICAgICAgICB2YXIgaXNVbmRvID0gXCJub1wiO1xuICAgICAgICBMT0FELmNyZWF0ZUZvb3RlcihcImZhY3RvclJvdGF0aW9uVGFibGUyXCIsIGV4cGxWYXIsIGlzVW5kbyk7XG5cbiAgICAgICAgLy8gZ2V0IHJvdyBjb2xvcnNcbiAgICAgICAgdmFyIHJvd0NvbG9yc0dyYXkgPSBnZXRHcmF5Q29sb3JzKCk7XG4gICAgICAgIHZhciByb3dDb2xvcnNSYWluYm93ID0gZ2V0UmFpbmJvd0NvbG9ycygpO1xuXG4gICAgICAgIC8vIGdldCByb3diYWNrZ3JvdW5kIGFuZCBvcmRlciBmcm9tIERPTSB1c2VyIGlucHV0IHJhZGlvXG4gICAgICAgIHZhciByb3dCYWNrZ3JvdW5kID0gJChcIiNzZWN0aW9uNiBpbnB1dFtuYW1lPXN0YXRlMl06Y2hlY2tlZFwiKS52YWwoKTtcbiAgICAgICAgdmFyIG9yZGVyaW5nQ29sdW1uID0gKygkKFwiI3NlY3Rpb242IGlucHV0W25hbWU9c3RhdGUxXTpjaGVja2VkXCIpLnZhbCgpKTtcblxuICAgICAgICAvLyBkcmF3IG5ldyB0YWJsZVxuICAgICAgICB0YWJsZSA9ICQoJyNmYWN0b3JSb3RhdGlvblRhYmxlMicpLkRhdGFUYWJsZSh7XG4gICAgICAgICAgICBcInJldHJpZXZlXCI6IHRydWUsXG4gICAgICAgICAgICBcInNlYXJjaGluZ1wiOiBmYWxzZSxcbiAgICAgICAgICAgIFwib3JkZXJpbmdcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiaW5mb1wiOiBmYWxzZSxcbiAgICAgICAgICAgIC8vXCJzY3JvbGxZXCI6IDYwMCxcbiAgICAgICAgICAgIC8vIFwic2Nyb2xsWVwiOiBcImF1dG9cIixcbiAgICAgICAgICAgIFwic2Nyb2xsQ29sbGFwc2VcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2Nyb2xsWFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJwYWdpbmdcIjogZmFsc2UsXG4gICAgICAgICAgICBcIm9yZGVyXCI6IFtcbiAgICAgICAgICAgICAgICBbb3JkZXJpbmdDb2x1bW4sIFwiYXNjXCJdXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJkYXRhXCI6IHJlc3VsdHMsXG4gICAgICAgICAgICBcImNvbHVtbnNcIjogaGVhZGVycyxcbiAgICAgICAgICAgIFwiY29sdW1uRGVmc1wiOiBbe1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ2hpZ2hlc3RGYWN0b3InLFxuICAgICAgICAgICAgICAgICd0YXJnZXRzJzogMlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICd0YXJnZXRzJzogY29sdW1uVGFyZ2V0czIsIC8vIHRvZG8gLSBmaW5kIG91dCBpZiB0aGlzIGlzIHdvcmtpbmcgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAnY2xhc3NOYW1lJzogJ2R0LWJvZHktcmlnaHQnLFxuICAgICAgICAgICAgICAgICdvcmRlcmFibGUnOiB0cnVlLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICd0YXJnZXRzJzogWzBdLFxuICAgICAgICAgICAgICAgICdjbGFzc05hbWUnOiAnZHQtYm9keS1jZW50ZXIgZHQtYm9keS1uYW1lJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJhYmxlJzogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICd0YXJnZXRzJzogY29sdW1uVGFyZ2V0cywgLy8gWzIsIDQsIDYsIDgsIDEwLCAxMiwgMTRdLFxuICAgICAgICAgICAgICAgICdzZWFyY2hhYmxlJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ29yZGVyYWJsZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2NsYXNzTmFtZSc6ICdkdC1ib2R5LXJpZ2h0JyxcbiAgICAgICAgICAgICAgICAncmVuZGVyJzogZnVuY3Rpb24oZGF0YSwgZGF0YUluZGV4KSB7IC8vIChkYXRhLCB0eXBlLCBmdWxsLCBtZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwic2lnQ2hlY2tib3hcIiAvPjxsYWJlbD48L2xhYmVsPic7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cInNpZ0NoZWNrYm94XCIgaWQ9XCJkJyArIGRhdGFJbmRleCArICdcIiB2YWx1ZT1cIicgKyBkYXRhICsgJ1wiIGRlZmF1bHRDaGVja2VkPVwiJyArIChkYXRhID09PSAndHJ1ZScgPyAnY2hlY2tlZCcgOiAnJykgKyAnXCInICsgKGRhdGEgPT09ICd0cnVlJyA/ICdjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcgLz48bGFiZWw+PC9sYWJlbD4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBcImNyZWF0ZWRSb3dcIjogZnVuY3Rpb24ocm93LCBkYXRhLCBkYXRhSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93R3JvdXA7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0JhY2tncm91bmQgPT09IFwiZ3JheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd0dyb3VwID0gZGF0YVsyXS5zbGljZSgwLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgLy92YXIgcm93R3JvdXBDb2xvciA9IChyb3dDb2xvcnNHcmF5W3Jvd0dyb3VwXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgJCgndGQnLCByb3cpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHJvd0NvbG9yc0dyYXlbcm93R3JvdXBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJvd0JhY2tncm91bmQgPT09IFwiY29sb3JzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93R3JvdXAgPSBkYXRhWzJdLnNsaWNlKDAsIDIpO1xuICAgICAgICAgICAgICAgICAgICAvL3ZhciByb3dHcm91cENvbG9yID0gKHJvd0NvbG9yc0dyYXlbcm93R3JvdXBdKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAkKCd0ZCcsIHJvdykuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgcm93Q29sb3JzUmFpbmJvd1tyb3dHcm91cF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59KHdpbmRvdy5MT0FEID0gd2luZG93LkxPQUQgfHwge30sIFFBVikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvTE9BRC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9')}});